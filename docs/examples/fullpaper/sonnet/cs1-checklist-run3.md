# CS1 条件D: Structured Checklist — RAG引用リナンバリング (Run 3)

> **Run**: CS1-D-Run3
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

## 1. 問題の背景と文脈

RAG（Retrieval-Augmented Generation）システムでは、LLMが外部知識ベースから検索した文書を参照しながら回答を生成する。検索エンジンは内部的に `source_3`、`source_7` のような識別子でドキュメントを管理しており、LLMはこれらの識別子をプロンプト経由で受け取り、回答文中に埋め込む形で引用を示す。

ユーザー体験の観点からは、引用は `[1]`、`[2]`、`[3]` のような連番形式が望ましい。連番形式はページ末尾の参考文献リストとの対応が直感的であり、学術論文・技術文書・チャットUIいずれにおいても標準的な慣習に沿っている。

一方、LLMのトークン生成はストリーミング方式で行われる。GPT-4やClaude等の現行モデルはトークンを順次生成し、クライアントに逐次送信する。この方式はTime to First Token（TTFT）を最小化し、ユーザーの待機感を軽減する利点があるが、文章の末尾まで確定しなければ「どの引用が最終的に使用されたか」が不明という状況を生む。

問題の核心は、「ストリーミングによるリアルタイム表示」と「引用番号の一貫性」という2つの要求が、同一の生成プロセスに対して相反する制約を課している点にある。

---

## 2. 対立する要求やトレードオフ

### トレードオフ A: リアルタイム性 vs. 番号の確定性

ストリーミング表示を優先すると、LLMが生成したトークンを即座にユーザーへ送信することになる。しかし引用番号は「全文における引用の出現順」に依存するため、先頭部分のみが届いた段階では確定した番号を割り当てられない。

- **リアルタイム性を優先**: 仮番号を表示し、後から差し替える。ユーザーは番号が変化するという混乱を経験する。
- **確定性を優先**: ストリーミングを停止し、全文生成後に引用番号を付与してから一括送信する。TTFTが大幅に悪化し、ユーザーは長い沈黙を待つことになる。

### トレードオフ B: 引用の先着順割り当て vs. 意味的な重要度順

最初に出現した引用に `[1]` を割り当てる先着順は実装が単純だが、主題に最も関連度の高い引用が `[4]` や `[5]` になる場合がある。引用番号の小ささが重要度の指標と誤解されるリスクがある。

一方、重要度順に番号を振ろうとすると、全引用が確定するまで番号割り当てを保留する必要があり、リアルタイム表示と衝突する。

### トレードオフ C: フロントエンド処理の複雑度 vs. バックエンド処理の複雑度

引用リナンバリングをバックエンド（サーバー側）で処理する場合、LLMの出力を中間層で変換してからストリーミングする仕組みが必要になる。バックエンドのロジックは複雑化するが、クライアントへのインターフェースはシンプルに保てる。

フロントエンドで処理する場合、生ストリームをそのまま送信し、クライアント側でリアルタイムにパースおよびリナンバリングを行う。バックエンドはシンプルになるが、各クライアント実装（Web、モバイル、API直接利用等）で同一ロジックを実装しなければならない。

---

## 3. 分析の対象範囲

本分析は以下の範囲を対象とする。

**対象とする範囲:**
- RAGシステムにおけるLLM出力のストリーミングパイプライン
- 引用識別子（内部ID）から連番（表示用番号）へのマッピング処理
- フロントエンドへのストリーミングプロトコル（SSE / WebSocket）
- ストリーム完了後の引用リスト（ソース一覧）との整合性検証

**対象外とする範囲:**
- 検索エンジン（ベクターDB、BM25等）の実装詳細
- LLMのプロンプトエンジニアリング全般（引用埋め込み方法の最適化は含む）
- 引用の信頼性評価・ファクトチェック
- 多言語対応・アクセシビリティ

---

## 4. 現状のアーキテクチャと制約

### 典型的なRAGストリーミングアーキテクチャ

```
[User Query]
    ↓
[Retrieval Engine]
    → source_1: "..."
    → source_3: "..."
    → source_7: "..."
    ↓
[LLM (Streaming)]
    → Token: "この"
    → Token: "問題"
    → Token: "は"
    → Token: "[source_3]"
    → Token: "で"
    → Token: "指摘"
    → ...
    ↓
[Client (SSE/WebSocket)]
```

### 制約

**制約1: LLMの逐次生成**
現行のTransformerベースのLLMは自己回帰的にトークンを生成する。生成済みトークンを後から修正する機構は標準的なAPIに存在しない（OpenAI API、Anthropic API共に）。

**制約2: ストリーミングプロトコルの単方向性**
SSE（Server-Sent Events）は単方向プロトコルであり、一度送信したイベントをサーバー側から取り消すことはできない。WebSocketは双方向だが、送信済みメッセージの差し替えはアプリケーション層で別途プロトコルを定義する必要がある。

**制約3: 引用パターンの多様性**
LLMが出力する引用形式はプロンプト設計に依存し、`[source_3]`、`(source_3)`、`source_3`、`Source 3` など複数の形式が混在しうる。正規表現による完全な検出は困難。

**制約4: 引用の分割トークン化**
`[source_3]` という文字列は、トークナイザーの分割単位によっては `[`, `source`, `_`, `3`, `]` のように複数トークンに分割されて順次到着する。単一トークンでの引用検出ができない場合がある。

---

## 5. 既存の解決アプローチとその限界

### 5.1 アプローチ1: バッファリング後一括変換

**手法:**
LLMの全出力をサーバー側バッファに蓄積し、生成完了後に引用識別子を連番に変換してからクライアントへ一括送信する。

**利点:**
- 実装がシンプル
- 番号の一貫性が保証される
- フロントエンドへのインターフェースが通常のHTTPレスポンスと同等

**限界:**
- LLM生成時間（通常数秒〜数十秒）の間、ユーザーは無反応の画面を見続ける
- TTFTが長くなり、ユーザー体験が著しく低下する
- ネットワーク障害時に全出力が失われるリスク

---

### 5.2 アプローチ2: 内部IDをそのまま表示

**手法:**
`source_3` のような内部IDをそのままユーザーに表示し、リナンバリングを行わない。

**利点:**
- 実装コストがゼロ
- 番号変化の問題が発生しない

**限界:**
- ユーザー体験が著しく低下する（意味不明な識別子が表示される）
- UIデザインとの整合性が取れない（参考文献リストが `[source_7]` のような形式になる）
- 識別子の命名規則が外部漏洩するセキュリティ上のリスク

---

### 5.3 アプローチ3: 後付け差し替え（プレースホルダー方式）

**手法:**
ストリーミング中は仮の番号（例: `[?]` またはインクリメント番号）を表示し、ストリーム完了後にUIを更新して最終番号に差し替える。

**利点:**
- ストリーミングのリアルタイム性は維持される
- 最終的な番号の一貫性は保証できる

**限界:**
- ユーザーが読み途中に番号が変化するという混乱が発生する
- 番号変化のタイミングによっては、ユーザーが古い番号でメモを取るなど誤った行動をとりうる
- 差し替え処理のUIアニメーションが視覚的ノイズになる

---

### 5.4 アプローチ4: 先着順マッピング（ストリーム内でインクリメント）

**手法:**
ストリーミング中に引用識別子が最初に出現した順に連番を割り当て、一度割り当てた番号は変更しない。サーバー側またはクライアント側でマッピングテーブルを管理する。

```
初回出現: source_7 → [1]
2回目出現: source_3 → [2]
source_7 再出現 → [1] (既存マッピングを使用)
```

**利点:**
- ストリーミング中に確定した番号を表示できる
- 一度表示した番号が変わらない
- 実装の複雑度が中程度

**限界:**
- 引用の出現順が意味的な重要度順と一致しない場合、番号の意味が直感に反する
- 引用識別子の検出が複数トークンにまたがる場合の処理が必要
- ストリーム完了後のソース一覧との整合性検証ロジックが別途必要

---

## 6. 問題の本質的な困難

本問題の本質的な困難は、**「位置依存性」と「時間的前方参照の不可能性」の組み合わせ**にある。

引用の連番は「文書全体における出現順」という位置に依存した情報である。しかしストリーミング生成では、任意の時点 `t` において、時点 `t` より後に来るテキストは未確定である。つまり、時点 `t` で表示する引用番号は、まだ存在しない将来の情報を参照せずに決定しなければならない。

これは本質的に「因果性の制約」であり、ソフトウェアの実装工夫だけでは完全には解消できない。

解消の方向性は2つに限られる:
1. **制約を受け入れ、先着順を「正しい順序」と定義する** — 将来の情報への依存を断ち切る
2. **生成プロセスを変え、事前に引用順序を確定させる** — ストリーミング開始前に引用リストを生成する二段階生成

どちらの方向性も完全な解決ではなく、それぞれ固有のコストを持つ。重要なのは、このトレードオフを明示的に認識した上でアーキテクチャを選択することである。

---

## 7. 解決策

### 7.1 基本原理

**先着順マッピングを「仕様」として採用し、二段階メタデータプリフェッチで補完する。**

ストリーミング中に引用識別子が最初に出現した順に連番を確定的に割り当てる。この「先着順」を実装上の妥協ではなく、明示的な設計仕様として定義する。

加えて、LLMの回答生成前にメタデータ生成フェーズを設け、「このクエリに対してどの引用が使用されるか」を事前に推定する補助ステップを設ける。ただしこれは補助的なものであり、主たる保証はストリームパース時のマッピングが行う。

**三つの不変条件を設ける:**
1. 一度割り当てた `source_X → [N]` のマッピングはストリーム内で変更しない
2. ストリーム完了時のソース一覧は、ストリーム中に使用されたマッピングと同一のテーブルから生成する
3. ソース一覧に含まれる引用はすべて本文中に少なくとも1回登場したものに限定する

---

### 7.2 実装方針

#### 7.2.1 サーバー側: ストリーム変換レイヤー

LLMとクライアントの間に変換レイヤー（Transform Stream）を挿入する。

```
LLM Stream → Citation Parser → Renumber Transform → Client SSE Stream
                    ↓
              Mapping Table
              { source_7: 1, source_3: 2, ... }
```

**Citation Parser の責務:**
- LLMの出力トークンをバッファリングしながら引用パターンを検出する
- 検出パターン例: `/\[source_\d+\]/g`、`/\(source_\d+\)/g`
- トークン境界をまたぐ場合のために最小バッファ幅を設定する（例: 直近20文字）

**Renumber Transform の責務:**
- マッピングテーブルを参照し、`source_X` → `[N]` に変換する
- `source_X` が未登録の場合、新しい連番を割り当ててテーブルに追加する
- 変換済みテキストをクライアントへ送信する

**ストリーム完了時の処理:**
- マッピングテーブルから `{ source_id, display_number, title, url }` のリストを生成する
- 番号順にソートしてクライアントへ `citations` イベントとして送信する

#### 7.2.2 SSEプロトコル設計

```
event: delta
data: {"text": "この問題は"}

event: delta
data: {"text": "[1]"}

event: delta
data: {"text": "で指摘されており、"}

event: delta
data: {"text": "[2]"}

event: delta
data: {"text": "でも同様の..."}

event: citations
data: {
  "citations": [
    {"number": 1, "source_id": "source_7", "title": "...", "url": "..."},
    {"number": 2, "source_id": "source_3", "title": "...", "url": "..."}
  ]
}

event: done
data: {}
```

#### 7.2.3 フロントエンド側の処理

フロントエンドは `delta` イベントを受信するたびにテキストを追記する。テキスト中の `[N]` はそのまま表示する（番号は確定済みのため差し替え不要）。

`citations` イベント受信時に参考文献リストをDOMに追加する。このイベントは必ずストリーム完了直前に到着するため、本文と参考文献の整合性は保たれる。

#### 7.2.4 引用検出のエッジケース処理

**問題:** `[source_7]` が `[`, `source`, `_`, `7`, `]` のように5トークンに分割される場合。

**対処:** サーバー側の変換レイヤーでスライディングウィンドウバッファを使用する。

```python
class CitationStreamTransformer:
    def __init__(self):
        self.buffer = ""
        self.mapping = {}  # source_id -> display_number
        self.counter = 0
        self.PATTERN = re.compile(r'\[source_(\d+)\]')

    def process_token(self, token: str) -> str:
        self.buffer += token
        result = ""
        last_safe_end = 0

        # パターンマッチを試みる
        for match in self.PATTERN.finditer(self.buffer):
            # マッチ前のテキストを出力
            result += self.buffer[last_safe_end:match.start()]
            # 引用を変換
            source_id = f"source_{match.group(1)}"
            result += f"[{self._get_or_assign(source_id)}]"
            last_safe_end = match.end()

        # バッファの末尾に未完成の引用がある可能性を考慮
        # "[source_" で始まる未完成文字列は保留する
        safe_to_flush = self._find_safe_flush_point(self.buffer[last_safe_end:])
        result += self.buffer[last_safe_end:last_safe_end + safe_to_flush]
        self.buffer = self.buffer[last_safe_end + safe_to_flush:]

        return result

    def _get_or_assign(self, source_id: str) -> int:
        if source_id not in self.mapping:
            self.counter += 1
            self.mapping[source_id] = self.counter
        return self.mapping[source_id]

    def _find_safe_flush_point(self, text: str) -> int:
        # "[source_" の部分文字列が末尾にある場合、その手前までを安全とする
        PARTIAL = "[source_"
        for i in range(len(PARTIAL), 0, -1):
            if text.endswith(PARTIAL[:i]):
                return len(text) - i
        return len(text)
```

---

## 8. 検証条件

### 検証条件 1: 基本的なリナンバリング

**Given:** LLMが `source_7` を最初に参照し、その後 `source_3` を参照するストリームを生成する

**When:** クライアントがSSEストリームを受信する

**Then:**
- `source_7` の最初の出現が `[1]` として表示される
- `source_3` の最初の出現が `[2]` として表示される
- ストリーム完了後の `citations` イベントに `{number: 1, source_id: "source_7"}` と `{number: 2, source_id: "source_3"}` が含まれる

---

### 検証条件 2: 同一引用の再出現

**Given:** LLMが `source_7` を2回参照するストリームを生成する

**When:** クライアントがSSEストリームを受信する

**Then:**
- `source_7` の初回出現が `[1]` として表示される
- `source_7` の2回目の出現も `[1]` として表示される（番号変化なし）
- `citations` イベントに `source_7` が1エントリのみ含まれる

---

### 検証条件 3: 番号の不変性

**Given:** ストリーミング中に `[1]` が既にクライアントに送信されている

**When:** その後のトークンで新たな引用が出現する

**Then:**
- 既に送信済みの `[1]` は変更されない
- 新たな引用には `[2]` 以降の番号が割り当てられる
- ページをリロードせずに同一セッションで同じ回答を見ているユーザーには番号の変化が観察されない

---

### 検証条件 4: ソース一覧との整合性

**Given:** ストリーム中に `[1]`、`[2]`、`[1]` の順で引用が出現した

**When:** `citations` イベントが送信される

**Then:**
- `citations` リストの長さは2である（重複なし）
- `citations[0].number === 1` かつ `citations[1].number === 2` である
- `citations` リストに本文中に出現しなかった引用は含まれない

---

### 検証条件 5: トークン境界をまたぐ引用の検出

**Given:** `[source_7]` が `[source_` と `7]` の2つのトークンに分割されて到着する

**When:** 変換レイヤーが各トークンを処理する

**Then:**
- `[source_` 受信時点では引用は変換されず保留される
- `7]` 受信時点で `[source_7]` が検出され、`[1]` として変換される
- クライアントには `[1]` として送信される（`[source_` や `7]` として送信されない）

---

### 検証条件 6: 引用を含まない回答

**Given:** LLMが引用識別子を一切含まない回答を生成する

**When:** クライアントがSSEストリームを受信する

**Then:**
- `citations` イベントは空のリスト `[]` を持つ、またはイベント自体が省略される
- テキストは変換されずにそのままクライアントへ送信される
- エラーは発生しない

---

## 9. 制約、限界、今後の課題

### 制約

**制約1: LLMへの出力形式の強制**
変換レイヤーが機能するためには、LLMが引用を一定の形式で出力することが前提条件である。プロンプトで `[source_N]` 形式を強制するが、LLMが指示を無視したり形式を変形させたりする場合がある。プロンプトの安定性に依存する部分がある。

**制約2: 先着順の意味的限界**
本設計では意味的に重要な引用が小さい番号を得る保証はない。引用の出現順はLLMの生成ロジックに依存するため、番号の小ささを重要度の指標と解釈することは誤りである。ユーザーへのUI上の説明が必要な場合がある。

**制約3: ネットワーク断絶時の中断**
ストリーミング中にネットワークが断絶した場合、部分的なテキストと不完全な引用リストが表示される可能性がある。再接続・再送信のプロトコルは本設計の範囲外である。

### 限界

**限界1: 多言語・多形式の引用パターン**
現設計は `[source_N]` という単一の引用形式を仮定している。実運用では複数の形式が混在する場合や、多言語ドキュメントを扱う場合に検出パターンの拡張が必要になる。

**限界2: 分散システムへの適用**
複数のLLMインスタンスが並列で部分回答を生成するシステム（Speculative Decoding等）では、本設計のストリーム変換レイヤーが単一のマッピングテーブルを維持する前提が崩れる。分散マッピング管理の追加設計が必要。

**限界3: レイテンシへの影響**
変換レイヤーのバッファリングは最大で「最長の引用識別子の長さ分」のレイテンシをトークン送信に加える。通常は数十ミリ秒以下だが、非常に長い識別子を用いるシステムでは影響が生じうる。

### 今後の課題

**課題1: 引用の信頼性スコア付き表示**
引用番号に加えて信頼性スコア（relevance score）を表示することで、ユーザーが引用の品質を評価できるようにする。これは本設計のSSEプロトコルを拡張することで対応可能である。

**課題2: インタラクティブな引用展開**
ユーザーが `[1]` をクリックすると該当ドキュメントのスニペットがインラインで展開される機能。本設計の `citations` イベントにスニペット情報を含めることで実現できる。

**課題3: 引用の事前推定による改善**
二段階生成（引用候補の事前推定 → 本文生成）を採用し、引用番号を本文生成開始前に確定させることで、より意味的に整合した番号付けが可能になる。ただし全体的なレイテンシが増加するため、ユーザー体験とのトレードオフ評価が必要である。

**課題4: ストリーミングの中断・再開プロトコル**
SSEの `Last-Event-ID` ヘッダーを活用し、ネットワーク断絶後の再接続時に中断位置からストリームを再開する機構。引用マッピングテーブルの状態をサーバー側でセッションと紐付けて保持する必要がある。
