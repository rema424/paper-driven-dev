# CS2 条件D: Checklist — マルチテナントSaaSセッション管理 (Run 2)

> **Run**: CS2-D-Run2
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c79be-a201-7ea1-9813-21e13dd22c80)
> **Model**: GPT-5.2 (via Codex)

---

1. 問題の背景と文脈
マルチテナントSaaSでは、1ユーザーがPC・スマホなど複数端末で同時利用する一方、管理者は不正利用時に当該ユーザーの全セッションを即時停止したいです。さらにAPIサーバーは水平スケール前提のため、特定ノードのメモリ状態に依存しない設計が必要です。加えて、認証は全リクエストで実行されるため、遅延がそのままUXとコストに直結します。

2. 対立する要求やトレードオフ
- `低レイテンシ` と `即時失効`: JWTのみのローカル検証は速いが、失効反映が遅れます。
- `強整合性` と `可用性/スケール`: 毎回中央ストア照会は正確だが遅く、障害時に認証経路が弱くなります。
- `短命トークン` と `UX/負荷`: 短い有効期限は安全だが、更新頻度が上がり負荷と再認証ストレスが増えます。
- `テナント分離` と `運用簡素化`: 厳密分離は安全だが実装・運用は複雑化します。

3. 分析の対象範囲
対象は「ログイン時のセッション発行」「リクエスト認証」「管理者によるユーザー単位失効」「失効伝播」「スケール時の一貫性と性能」です。
対象外はMFA詳細、外部IdP連携詳細、課金・監査UI設計です。

4. 現状のアーキテクチャと制約（想定）
APIサーバーは無状態で複数台、認証はBearerトークン、共有データ層にRedisとRDBを利用可能とします。
制約は、スティッキーセッション不可、テナント境界厳守、失効反映SLOを秒未満、認証オーバーヘッドを低p99に抑えることです。

5. 既存の解決アプローチとその限界
5.1 アプローチ1: 完全ステートレスJWT — 手法: 署名検証のみ / 利点: 最速・スケール容易 / 限界: 即時失効が困難。
5.2 アプローチ2: サーバー内メモリセッション — 手法: ノード保持 / 利点: 実装容易 / 限界: 水平スケール・ノード障害に弱い。
5.3 アプローチ3: 毎回中央ストア照会（セッションDB/Redis） — 手法: トークン都度照会 / 利点: 失効反映が正確 / 限界: レイテンシ増、ストア依存。
5.4 アプローチ4: ハイブリッド（短命Access + 中央失効状態） — 手法: 通常はローカル検証、失効は共有状態で判定 / 利点: 速度と即時性の両立 / 限界: キャッシュ失効制御が難しい。

6. 問題の本質的な困難
「分散環境での即時制御」と「各リクエストの極小遅延」を同時に満たす点です。
特に、失効情報の伝播遅延・キャッシュ整合・障害時挙動を設計しないと、即時失効か低遅延のどちらかが破綻します。

7. 解決策
7.1 基本原理
- Access Tokenは短命JWT（例: 5分）でローカル検証。
- `user_session_version` をトークンに含め、Redisの最新版と比較して失効判定。
- 管理者失効時は対象ユーザーのversionを原子的にインクリメントし、全ノードへイベント配信。
- Refresh Tokenは中央管理し、失効時に即時削除。
- キー空間は `tenant_id` で厳密に分離。

7.2 実装方針
1. ログイン時に `session_id` を端末単位で発行し、JWT claimsに `tenant_id/user_id/session_id/version` を格納。
2. 認証ミドルウェアは署名検証後、L1メモリキャッシュの `user_version` を参照。未ヒット時のみRedis参照。
3. 管理者失効APIはRedis Lua等で `version++` とRefresh削除を原子的に実行し、Pub/Subで全APIノードのL1キャッシュを即時無効化。
4. セッション台帳はRDBへ非同期反映し監査可能にする。
5. 水平スケール時はAPIノード無状態のまま追加・削除可能。

8. 検証条件（Given/When/Then）
- Given 同一ユーザーが2端末でログイン済み When 両端末から同時にAPI呼び出し Then 両方200で通る。
- Given 管理者が対象ユーザーを失効実行 When 失効後に既存Access TokenでAPI呼び出し Then 全端末で即時に401となる。
- Given APIサーバー台数を増減 When 認証トラフィックを継続投入 Then 認証成功率と失効反映SLOを維持する。
- Given Redis一時遅延 When 認証要求が発生 Then L1ヒット時はp99遅延目標内、ミス時も劣化が許容範囲。
- Given 異なるテナントで同一user_id文字列 When 片方テナントで失効 Then 他テナントの認証結果に影響しない。

9. 制約、限界、今後の課題
ネットワーク分断時に「絶対即時」は保証困難で、実運用ではSLO定義（例: 1秒以内）と監視が必要です。Redis/PubSub依存のため、再送可能なイベント基盤（Stream/Kafka）やリカバリ手順が必要です。今後は、リージョン間失効伝播、端末単位失効、異常検知連動の自動失効を拡張課題とするのが妥当です。
