# Output #023

**1. 問題の背景と文脈**
マルチテナントSaaSでは、`tenant_id`ごとに独立した認証境界を保ちつつ、同一ユーザーの複数端末利用（PC/スマホ等）を許可する必要があります。加えて、インシデント対応や退職時対応のため、管理者が対象ユーザーのセッションを全ノードで即時失効できることが重要です。さらに、サーバーの増減（水平スケール）時にも認証挙動が変わらず、認証レイテンシを低く保つことが求められます。

**2. 対立する要求やトレードオフ**
1. 低レイテンシ vs 即時失効
認証をローカル完結すると速いが、失効反映が遅れやすいです。
2. ステートレス性 vs 制御性
完全JWTはスケールしやすいが、個別セッション失効が難しいです。
3. 長寿命トークン vs セキュリティ
長寿命は再認証負荷を下げるが、漏えい時リスク時間が伸びます。
4. 強い整合性 vs 運用コスト
厳密同期は安全だが、分散環境でコスト・複雑性が増えます。

**3. 分析の対象範囲**
対象は、ログイン/リフレッシュ/認証ミドルウェア/管理者失効/APIノード間の失効伝播です。
対象外は、IdP連携の詳細、MFA仕様、UI設計、課金ロジックです。

**4. 現状のアーキテクチャと制約（想定）**
`LB -> stateless API nodes` の構成を前提に、共有の `Redis`（高速状態）と `RDB`（監査・永続）を使います。
制約は、`sticky session`非依存、`tenant_id`単位の厳密分離、失効反映を1秒未満目標、認証のp95を低水準維持です。

**5. 既存の解決アプローチとその限界**
**5.1 アプローチ1: 完全ステートレスJWT**
手法: 各リクエストで署名検証のみ。
利点: 低レイテンシ・高スケーラビリティ。
限界: 管理者による即時失効が難しい（TTLまで有効）。

**5.2 アプローチ2: 中央セッション照会（毎回DB/Redis参照）**
手法: トークンをキーに中央ストアを毎回照会。
利点: 失効制御が容易。
限界: ネットワーク往復で遅延増、中央依存が強い。

**5.3 アプローチ3: サーバーメモリセッション（sticky前提）**
手法: ノード内メモリ管理。
利点: 単体性能は高い。
限界: 水平スケール・フェイルオーバー・即時全体失効に弱い。

**6. 問題の本質的な困難**
本質は、分散環境で「ほぼ即時の全体失効」と「認証のローカル高速処理」を同時成立させる点です。つまり、失効整合性とレイテンシ最適化の両立が核心です。

**7. 解決策**
**7.1 基本原理**
`短寿命Access Token + 中央失効状態 + イベント伝播` のハイブリッド方式を採用します。
単位は「ユーザー全体」と「端末別セッション」の2階層で管理します。

**7.2 実装方針**
`session_id`を端末ごとに発行し、`Access Token`に `tenant_id, user_id, session_id, user_epoch, exp` を含めます。
認証時は、まずローカル署名検証し、その後 `Redis` の失効情報（`revoked_session`, `user_epoch`）をL1キャッシュ経由で確認します。
管理者失効は2種類です。
- 単一端末失効: `session_id`を失効化してイベント配信。
- 全端末失効: `user_epoch`をインクリメントしてイベント配信。
各APIノードはイベント受信でローカルキャッシュを即時無効化し、次リクエストから拒否します。
これにより、同時ログインと即時失効、水平スケール、低遅延を両立します。

**8. 検証条件（Given/When/Then）**
1. Given 同一ユーザーが端末A/Bでログイン済み
When 両端末から同時にAPI呼び出し
Then 両方とも認証成功し、別`session_id`として追跡できる。

2. Given ユーザーが複数セッションを保持
When 管理者が「全セッション失効」を実行
Then 1秒以内に全ノードで当該ユーザーの既存トークンが拒否される。

3. Given 端末A/Bがログイン済み
When 管理者が端末Aの`session_id`のみ失効
Then Aは拒否され、Bは継続利用できる。

4. Given APIノードをN台からN+M台へ増設
When 認証トラフィックを継続投入
Then セッション整合性を崩さず、認証成功率と失効挙動が維持される。

5. Given p95認証遅延目標を定義
When 通常負荷で計測
Then p95が目標内（例: 認証追加遅延 < 5ms）に収まる。

6. Given `tenant_A` と `tenant_B` に同一`user_id`文字列が存在
When `tenant_A`管理者が失効操作
Then `tenant_B`のセッションには影響しない。

**9. 制約、限界、今後の課題**
失効伝播はネットワーク障害時に短い遅延窓が発生し得ます。Redis依存が高く、障害時ポリシー（fail-open/fail-closed）の設計が必要です。短寿命トークンでもTTL内のリスク窓は残ります。今後は、失効イベントの再送保証、WebSocket強制ログアウト通知、異常検知ベースの自動失効を追加すると堅牢性が上がります。
