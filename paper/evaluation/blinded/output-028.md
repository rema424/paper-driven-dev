# Output #028

**題目: マルチテナントSaaSにおける低遅延・即時失効対応セッション管理設計**

**§1. 問題定義**
**§1.1 背景**
マルチテナントSaaSでは、同一ユーザーが複数端末から同時利用する一方、管理者は不正利用時に対象ユーザーのセッションを即時停止できる必要があります。さらに、オートスケール環境ではアプリケーションノードが動的に増減するため、セッション状態をノード内メモリに閉じる設計は成立しません。加えて、認証処理は全API呼び出しのホットパスであり、遅延増加は直接的にUXとコストへ影響します。

**§1.2 矛盾する要求（対立するトレードオフ）**
1. 即時失効（強整合）と低レイテンシ（ローカル判定）は原理的に緊張関係にあります。
2. 水平スケーリング（ステートレス化）とセッション一貫性（共有状態管理）は実装上の負荷が競合します。
3. 複数端末同時ログイン（利便性）と侵害時の被害最小化（セキュリティ）は運用上のトレードオフを持ちます。
4. テナント分離（厳密な隔離）と運用単純性（共通基盤利用）も相反しやすい要件です。

**§1.3 本文書の範囲**
本稿は、APIリクエスト認証に関わるセッション管理層を対象とします。認証要素（MFA、IdP連携）や課金・監査の全体設計は対象外とします。

**§2. 現状のアーキテクチャと制約**
想定環境は、ロードバランサ配下のステートレスAPIノード群、永続DB、分散KVS（例: Redis Cluster）です。制約は以下です。
1. セッションキーは常に `tenant_id` を含み、テナント越境参照を禁止すること。
2. 管理者失効は全ノードへサブ秒で伝播すること（運用SLO）。
3. 認証レイテンシはホットパスで最小化すること（例: p99 < 10ms）。
4. ノード増減時にスティッキーセッションへ依存しないこと。

**§3. 既存アプローチとその限界**
**§3.1 アプローチ1: ノード内ステートフルセッション — 手法 / 利点 / 限界**
手法: 各ノードのメモリにセッション保持し、LBでスティッキー接続。
利点: 認証は高速。
限界: 水平スケール・障害復旧・即時失効の全体整合が困難。

**§3.2 アプローチ2: 完全ステートレスJWT — 手法 / 利点 / 限界**
手法: 署名JWTのみで認証、サーバ側セッション状態を持たない。
利点: スケール容易、DB照会不要。
限界: 発行済みトークンの即時失効が困難。短TTL化すると再発行負荷が増える。

**§3.3 アプローチ3: 毎リクエスト集中イントロスペクション — 手法 / 利点 / 限界**
手法: すべてのAPI呼び出しで中央セッションストア照会。
利点: 失効反映が強い。
限界: ネットワーク往復が必須となり、レイテンシと可用性が中央依存になる。

**§4. 問題の本質**
本問題は「認証データプレーンの局所高速判定」と「失効制御プレーンの全体一貫性」を両立する分散整合問題です。特に、`ユーザー単位の即時失効` と `端末単位の同時セッション維持` を同時に満たす状態モデルが核となります。

**§5. 提案手法**
**§5.1 基本原理**
1. データプレーンと制御プレーンを分離する。
2. セッションは `session_id`（端末単位）で管理し、ユーザー単位失効は `user_epoch` の単調増加で表現する。
3. アクセストークンは短寿命署名JWT、リフレッシュはサーバ管理（失効可能）とする。
4. 認証判定は「署名検証 + ローカルL1キャッシュ参照」を基本とし、ミス時のみ分散KVS参照。

有効条件の例:
`valid = sig_ok ∧ not_expired ∧ token.user_epoch == current_user_epoch(tenant,user) ∧ sid_not_revoked`

**§5.2 実装アーキテクチャ**
1. **Auth Service**: ログイン時に `session_id` 発行、`tenant_id/user_id/device_id/user_epoch` を記録。
2. **Session Control Store (Redis Cluster)**: `user_epoch` と `revoked_sid` を保持。
3. **System of Record (RDB)**: 監査・復旧用にセッション履歴を永続化。
4. **Invalidation Bus (Pub/Sub or Stream)**: 失効イベントを全APIノードへ即時配信。
5. **API Node L1 Cache**: ホットユーザーの `user_epoch` を保持し、認証遅延を最小化。

管理者失効フロー:
`user_epoch` を原子的にインクリメントし、イベント配信。以後、旧epochトークンは全端末で無効。

**§6. 検証可能な性質（Given/When/Then）**
1. **同時ログイン性**
Given 同一ユーザーが未ログイン
When 端末A/Bから連続ログイン
Then 異なる `session_id` が2件Activeとなり、両方のAPI認証が成功する。

2. **ユーザー単位即時失効**
Given ユーザーUにActiveセッションが3件ある
When 管理者がUを失効し `user_epoch` を更新
Then 更新前epochのトークンは、全ノードでSLO内（例: 1秒以内）に拒否される。

3. **端末単位失効の選択性**
Given 端末A/Bで同時ログイン中
When 端末Aの `session_id` のみ失効
Then Aは拒否され、Bは継続して成功する。

4. **水平スケール不変性**
Given APIノード数Nで運用中
When N+Mへスケールアウト
Then 認証成功率・失効反映SLO・誤拒否率が許容範囲内で維持される。

5. **低遅延性**
Given L1キャッシュヒット率99%以上
When 通常トラフィックで認証を実行
Then 認証処理のp99遅延は目標値（例: 10ms未満）を満たす。

6. **テナント分離性**
Given 同一 `user_id` がテナントT1/T2に存在
When T1で失効操作
Then T2のセッション判定結果は変化しない。

**§7. 制約と今後の課題**
厳密な「瞬時失効」はネットワーク分断下で理論的限界があります。本提案は「運用上即時（サブ秒SLO）」を目標とする現実解です。今後の課題は、1) 分断時ポリシー（fail-open/fail-closed）の明確化、2) 失効イベント再送・順序保証の形式検証、3) リスクベース認証との統合、4) 大規模テナント偏在時のホットキー緩和です。
