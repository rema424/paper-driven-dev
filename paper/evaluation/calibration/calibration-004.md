# Calibration #004

## 1. 問題定義

### 1.1 背景
RAGシステムでは、検索結果（例: `source_3`, `source_7`）を根拠としてLLMが回答文を生成し、本文中に引用マーカー（例: `[source_7]`）を埋め込みます。ユーザー表示では、**実際に本文で使用された引用のみ**を対象に、可読性の高い連番（`[1]`, `[2]`, …）へ変換し、対応するソース一覧と紐付けて提示したい、という要件が一般的です。
しかしLLM出力がストリーミングで到着する場合、全文確定前に「最終的にどの引用が出るか」を前提とした連番付けは難しく見えます。

### 1.2 矛盾する要求（対立するトレードオフ）
- **(A) リアルタイム表示**（低レイテンシ・逐次描画） vs **(B) グローバル整合のある連番**（全文を見て初めて確定するような採番規則）
- **(A) 表示の安定性**（一度出た `[1]` が変わらない） vs **(B) 任意の順序規則**（例: 検索順位順・`citedSourceIds`順など、後から決まる順に並べたい）

### 1.3 本文書の範囲
- 対象: **ストリーミング中に本文の引用表記を連番表示し、ソース一覧と整合させるレンダリング設計**（クライアント/サーバ双方の責務分割を含む）
- 非対象: 検索品質、引用の正しさ（幻覚）、モデル学習、検索ランキング最適化

---

## 2. 現状のアーキテクチャと制約
- 入力:
  - 検索結果集合 `Sources = { source_i -> (title, url, snippet, …) }`
- LLM出力（ストリーミング）:
  - 構造化JSON: `{ body: "...[source_7]...", citedSourceIds: [...] }`
- 制約:
  - ストリームは通常**追記型**であり、過去に送ったトークン自体はサーバ側では取り消せない
  - `body` はJSON文字列であり、チャンク境界で `[` や `source_` が分断され得る（部分トークン問題）
  - LLMが出す `citedSourceIds` は、本文と不整合（不足・過剰・順序違い）になり得る

---

## 3. 既存アプローチとその限界

### 3.1 アプローチ1: 二段階レンダリング（全文バッファ後に一括変換）
- 手法: ストリームを最後まで蓄積し、本文全体から引用を抽出→連番化→描画
- 利点: 実装が単純、最終整合性が取りやすい、表示が揺れない
- 限界: ストリーミングの価値（逐次表示・体感速度）を失う

### 3.2 アプローチ2: ストリーミング中は `[source_N]` のまま表示し、最後に置換
- 手法: 途中は内部IDをそのまま見せ、完了後に `[1]` へ変換して再描画
- 利点: 低レイテンシで表示開始できる
- 限界: 途中表示が読みにくい／完了時に表示が変わる（コピー&ペースト・スクロール・読解の一貫性を損なう）

### 3.3 アプローチ3: 仮番号で逐次表示し、後でバックパッチ（DOM差分更新/テキストモデル）
- 手法: 途中は仮の採番で表示し、最終規則（例: `citedSourceIds`順）確定後に過去箇所も含めて番号を更新
- 利点: 任意の最終順序規則を満たせる
- 限界: 実装・状態管理が複雑、番号が途中で変わる（UIの揺れ）、選択範囲・アクセシビリティ・ログ整合の扱いが難しい

### 3.4 アプローチ4: LLMに `[1]` 連番を直接出させ、別途対応表も出させる
- 手法: プロンプト/スキーマで「本文は `[1]` で出力、別フィールドで `[{n:1, sourceId:"source_7"}]`」などを要求
- 利点: クライアントの置換処理が軽くなる可能性
- 限界: モデルが不整合を起こしやすい（本文と対応表の齟齬）、フォーマット逸脱時の復旧が難しい

---

## 4. 問題の本質
本問題は「**オンライン（逐次）処理**で、引用という"後から現れる集合"に対して**密な連番ラベル**を付けたい」点にあります。
一般に、採番規則が「全文を見ないと決まらない（非プレフィックス単調）」場合、ストリーミング中に"最終的に正しい番号"を確定できません。したがって解は次のいずれかに収束します。

1) **採番規則自体を"逐次確定可能（プレフィックス単調）"に定義し直す**
2) **過去表示の更新（バックパッチ）を許容する**（＝リアルタイム"確定"表示は諦める）

---

## 5. 提案手法

### 5.1 基本原理
**採番規則を「本文中での初出順（first-appearance order）」と明示的に定義**し、ストリーミング中に初めて `[source_X]` を観測した瞬間に表示番号を確定します。

- ルール: `body` を左から右へ読んだとき、最初に出現した未登録 `sourceId` に次の番号を割り当てる
  - 例: `...[source_7]... [source_3]... [source_7]...` → `source_7=>1`, `source_3=>2`
- このルールは**逐次確定可能**であり、一度割り当てた番号は将来のテキストによって覆りません（追記型ストリームと整合）。

補足: もし事業要件として「検索順位順」等を厳密に求めるなら、**§1.2のトレードオフにより**リアルタイムで"最終的に正しい連番"を保証できないため、バックパッチ方式（§3.3）を採用するか、要件側で順序規則を見直す必要があります。

### 5.2 実装アーキテクチャ
#### コンポーネント
1. **Stream Field Extractor**
   - ストリームから `body` の増分（`body_delta`）を取り出す（APIがフィールドデルタを提供しない場合は増分JSONパーサ/SAX風の状態機械で抽出）
2. **Citation Renumberer（逐次変換器）**
   - `body_delta` を受け、`[source_123]` トークンを検出して `[n]` に置換
   - チャンク境界分断に備え、末尾に小さな **tailBuffer** を保持（例: 最大 `"[source_" + 数字 + "]"` 程度）
3. **Citation Registry（採番台帳）**
   - `Map<sourceId, number>` と `Array<sourceId>`（number→sourceId）を保持
   - 新規sourceId検出時に `number = size+1` を確定し、ソース一覧UIへイベント通知
4. **Renderer**
   - 本文は `[n]` を表示しつつ、内部的には `data-source-id="source_7"` を保持できる形（例: クリックでソース詳細を開く）で描画
   - ソース一覧は「新規採番が確定した順（=初出順）」に `[n]` を追加していく
5. **Finalizer / Reconciler**
   - 完了時に、(a) 本文から観測した sourceId 集合 と (b) LLMの `citedSourceIds` を突合
   - 不整合があれば、表示整合の観点では **本文観測結果を正**として `citedSourceIds` を再生成（ログでモデル品質監視に回す）

#### 逐次置換の最小データ構造（概念）
- `displayNoBySourceId: Map<string,int>`
- `sourceIdByDisplayNo: string[]`（1-indexed運用でも0-indexed+1でも可）
- `tailBuffer: string`（未確定の末尾断片）
- 置換ポリシー:
  - **完全に閉じた**引用トークン（例: `"[source_7]"`）を検出した時点でのみ採番・置換
  - 未知sourceId（検索結果に存在しない等）は、`[?]` 表示や原文保持など、プロダクト方針で規定（重要なのは"勝手に採番して参照不能にしない"こと）

---

## 6. 検証可能な性質
1. **初出順採番**
   - Given `body` が `"...[source_7]...[source_3]..."` の順にストリーミングされる
     when 逐次レンダリングする
     then 表示は `...[1]...[2]...` となり、台帳は `1->source_7, 2->source_3` になる
2. **同一sourceIdの再出現で番号が安定**
   - Given `"...[source_7]... [source_7]..."`
     when 逐次レンダリングする
     then 両方とも `[1]` になり、台帳サイズは1のままで増えない
3. **チャンク分断耐性**
   - Given チャンクが `"...[sour"` と `"ce_7]..."` に分割されて到着する
     when 逐次処理する
     then `"[source_7]"` が完全に揃うまで採番せず、揃った時点で一度だけ `[1]` を出力する
4. **ソース一覧の逐次拡張**
   - Given 新規引用がストリーム中で初めて出現する
     when Citation Registry が採番する
     then ソース一覧UIに `[n] sourceId` が末尾追加され、既存項目の番号は変化しない
5. **`citedSourceIds` 不整合の検出**
   - Given LLMが `citedSourceIds` に本文未出現の `source_9` を含める
     when Finalizer が突合する
     then 表示用の参照リストは本文観測分のみになり、不整合が記録される
6. **完了後の番号不変**
   - Given 任意のタイミングで途中まで表示された本文がある
     when ストリーム完了してFinalizerが走る
     then 既に表示された引用番号は変化しない（再採番が発生しない）

---

## 7. 制約と今後の課題
- 制約（前提）:
  - 採番規則を**初出順**とする（これを外すと、リアルタイムで"最終的に正しい"連番を確定できない）
  - 引用トークン形式（例: `[source_7]`）が一定である（逸脱時の復旧方針が別途必要）
  - ストリームが追記型である（途中の内容差し替えを行う生成方式では、より強いテキストモデルと再レンダリングが必要）
- 今後の課題:
  - 解析容易性のため、`body` 内のプレーンテキスト引用ではなく、`segments: [{text:"...", cites:["source_7"]}]` のような**引用を構造要素化**した出力スキーマへ移行（正規表現依存を減らす）
  - 引用の集合・位置をサーバ側で正規化して返す（クライアント実装差を減らし、監査ログを作りやすくする）
  - モデルの誤引用（存在しないsourceId、根拠不一致）を検知・抑制する評価指標と運用（本設計は"表示の整合"を主目的とし、真偽判定は別問題）
