# CS1 条件A: Conventional — RAG引用リナンバリング (Run 4)

> **Run**: CS1-A-Run4
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c7995-e456-7361-9146-c3a6bb548a22)
> **Model**: GPT-5.2 (via Codex)

---

**結論**
要件を同時に満たすには、`source_id -> 表示番号` の**不変マップをストリーム中に逐次確定**する方式が最適です。
実装は「`Citation Registry` + `ストリーム引用パーサ` + `最終整合チェック`」の3点で構成します。

**設計分析（方式比較）**
1. 生成後に一括採番（後処理）
- 長所: 実装が簡単
- 短所: ストリーミング中に `[1]` を出せないので要件違反

2. 検索順位で事前固定（`source_3 -> [3]` など）
- 長所: 番号は絶対に変わらない
- 短所: 最初に `[3]` が出るなど読みにくく、連番性が弱い

3. 初出順で逐次固定（推奨）
- 長所: ストリーミング中に即時表示でき、番号も不変、最終一覧も自然な連番
- 短所: ストリーム中の引用トークンを確実にパースする実装が必要

**推奨アーキテクチャ**
- `Source Catalog`: 検索結果を安定ID付きで保持（`source_3`, `source_7`）
- `Citation Registry`（応答単位）
  - `id_to_num: Map<source_id, int>`（書き込み1回のみ）
  - `num_to_source: Map<int, SourceMeta>`
  - `next_num: int`（1から単調増加）
- `Stream Parser/Rewriter`
  - LLM出力中の引用マーカー（例: `<cite id="source_7"/>`）を検出
  - 初出なら番号を確定し、`[n]` に置換して即時表示
  - 既出なら同じ `[n]` を再利用
- `Finalizer`
  - 完了時に `num` 昇順でソース一覧を生成
  - 表示本文中の番号集合と一覧の整合を検証

**処理フロー**
1. 検索結果に安定 `source_id` を付与してLLMへ渡す
2. プロンプトで「引用は必ず構造化マーカーで出力」と強制
3. ストリーム受信ごとにマーカーを解析（チャンク分断対応バッファあり）
4. `source_id` 初出時のみ `next_num` を割り当て（以後不変）
5. ユーザーには即時に `[n]` を表示
6. `done` 時に `[n] -> ソース情報` を確定出力
7. 整合チェック失敗時はエラーイベントを記録しフォールバック表示

**不変条件（これで要件を保証）**
- `id_to_num` は一度入れたら変更しない
- `next_num` は増えるだけ
- 最終ソース一覧は `id_to_num` からのみ生成する

この3条件で、
- ストリーミング中リアルタイム表示
- 一度表示した番号は不変
- 完了時の一覧と本文が整合
を満たせます。

**実装上の注意**
- 引用は自由テキスト（`source_7` 文字列）ではなく、必ず機械可読タグにする
- `source_id` 不正値は `[?]` などで明示し、監視ログに送る
- 採番スコープは「1回答ごと」に分離する（会話全体で共有しない）
