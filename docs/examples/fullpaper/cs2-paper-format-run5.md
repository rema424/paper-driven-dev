# CS2 条件B: Paper Format — マルチテナントSaaSセッション管理 (Run 5)

> **Run**: CS2-B-Run5
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c79b1-a42a-7503-9c4c-682de490aedd)
> **Model**: GPT-5.2 (via Codex)

---

# マルチテナントSaaSにおける低遅延かつ即時失効可能な分散セッション管理方式

## 要旨
本稿は、マルチテナントSaaSにおけるセッション管理について、(1)同一ユーザーの複数端末同時ログイン、(2)管理者による即時失効、(3)水平スケーリング、(4)認証レイテンシ最小化、を同時達成する設計を提案する。提案は、短命アクセストークンと状態管理付きリフレッシュセッションを組み合わせたハイブリッド方式である。各ユーザーに単調増加の`user_version`を導入し、失効時にバージョンを原子的に更新して全ノードへ配信する。通常認証はローカル検証中心で完結し、分散キャッシュ参照を最小化するため、低遅延と高スループットを両立できる。加えて、配信障害時の整合性維持手順を定義し、実運用上の安全性を確保する。

## キーワード
マルチテナントSaaS、セッション管理、トークン失効、水平スケーリング、低レイテンシ認証

## 1. はじめに
SaaS基盤では、認証を「速く」「止めずに」「すぐ止められる」ことが同時に要求される。特にマルチテナント環境では、テナント境界の厳格な分離と、管理操作の即応性が不可欠である。一方、完全ステートレス認証は失効即時性とトレードオフを持つ。本稿はこのトレードオフを、短命トークンと分散状態管理の分離で解決する。

## 2. 問題設定
要求を以下に定義する。
1. 同一`(tenant_id, user_id)`が複数端末から同時ログイン可能であること。
2. 管理者が特定ユーザーの全セッションを即時無効化できること。
3. APIサーバー台数の増減に対して認証機能が線形に拡張可能であること。
4. 各リクエスト認証のp99レイテンシを最小化すること。

## 3. 提案方式

### 3.1 全体アーキテクチャ
提案方式は次の4層で構成する。
1. 認証ミドルウェア層（各APIノード上、ステートレス実行）。
2. セッション制御層（ログイン・更新・失効API）。
3. 分散キャッシュ層（Redis Cluster想定、`user_version`とセッション状態を保持）。
4. 永続層（RDB、監査・復旧用）。

### 3.2 トークンとセッションモデル
アクセストークンには`tenant_id, user_id, sid, user_version, exp`を含める。寿命は短く（例: 1〜5分）設定する。
リフレッシュトークンはランダムな不透明トークンとし、ハッシュ化して保存する。端末ごとに`sid`を発行するため、同時ログインは`sid`多重化で自然に成立する。

### 3.3 認証アルゴリズム
通常リクエストでは次を実行する。

```text
Algorithm Auth(τ)
1: 署名・有効期限をローカルで検証
2: k = (tenant_id, user_id)
3: v_cur = L1メモリキャッシュ[k]（miss時のみRedis参照）
4: if τ.user_version < v_cur then Reject
5: if sid失効フラグが有効 then Reject
6: Accept
```

主要経路はローカル署名検証とメモリ参照のみで完結するため、低遅延である。

### 3.4 即時失効プロトコル
管理者がユーザー失効を実行した場合、以下を1トランザクションで行う。
1. `user_version`をインクリメント。
2. 当該ユーザーの有効`sid`を失効状態へ更新。
3. 失効イベントを配信（Pub/SubまたはStream）。

各APIノードはイベント受信時にL1キャッシュを更新し、旧`user_version`トークンを即時拒否する。これにより「再ログイン待ち」なしで全端末を停止できる。

## 4. 正当性と障害時動作
命題: `user_version`が単調増加し、全リクエストで`τ.user_version < v_cur`を検査する限り、失効操作以後に発行済み旧トークンは受理されない。
理由: 失効で`v_cur`が増分され、旧トークンの`user_version`は不変であるため、不等式が必ず成立する。

配信障害時はフェイルセーフとして、認証ミドルウェアをRedis強制参照モードへ切替える。レイテンシは増えるが、失効整合性を優先できる。

## 5. 性能考察
期待認証遅延を次で近似する。
\[
E[L] = L_{sig} + pL_{L1} + (1-p)(L_{redis}+L_{L1})
\]
ここで\(p\)はL1ヒット率である。\(p\)が高いほどネットワーク往復が減少し、p99は署名検証＋メモリアクセスに近づく。
また、APIノードはセッション状態をローカル保持しないため、水平スケーリング時にスティッキーセッションを不要化できる。

## 6. 結論
本稿の方式は、短命アクセストークン、`user_version`失効制御、イベント配信、L1キャッシュを統合し、要求4条件を同時に満たす。特に、即時失効と低遅延の対立を「通常時ローカル判定、失効時のみ状態同期」に分離した点が有効である。今後は、テナントごとの鍵分離、リージョン間複製遅延下での失効SLO検証、実測ベンチマークによるp99評価を進める。
