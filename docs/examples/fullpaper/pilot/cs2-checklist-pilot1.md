# CS2 条件D (Pilot): Structured Checklist — セッション管理

> **Run**: CS2-D-Pilot1
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP)
> **Model**: GPT-5.2 (via Codex)
> **Purpose**: D条件プロンプトの妥当性確認（本解析には含めない）

---

1. 問題の背景と文脈
マルチテナントSaaSでは、認証は全リクエストの共通ホットパスです。
今回は「複数端末同時ログイン」「管理者による即時失効」「水平スケール」「低レイテンシ」を同時達成する必要があり、単純なJWT-onlyや単純なサーバー内セッションでは要件を満たしにくい状況です。

2. 対立する要求やトレードオフ
1. 即時失効 vs 低レイテンシ
毎回中央ストア照会すれば失効は強いですが、認証遅延が増えます。
2. ステートレス運用 vs 強いセッション制御
完全ステートレスJWTは高速ですが、管理者失効が難しくなります。
3. 強整合性 vs 可用性
失効を全ノード即時反映したい一方、分散環境ではネットワーク分断時に遅延・不整合リスクがあります。
4. セキュリティ強化 vs UX
短寿命トークンは安全ですが、更新頻度が増えて実装・運用負荷が上がります。

3. 分析の対象範囲
対象: 認証トークン、セッション生成/失効、ユーザー単位失効、ノード間反映、レイテンシ最適化。
対象外: 認可（RBAC詳細）、MFA、課金、監査UI。

4. 現状のアーキテクチャと制約
前提アーキテクチャ: LB配下のステートレスAPIノード群、共有Redis、永続DB。
制約:
- テナント分離必須（`tenant_id`を全キー・全判定に含める）
- スティッキーセッション非依存
- ノード増減時に再配備なしで同一挙動
- 認証処理はP99遅延を極小化（例: 追加遅延3ms程度を目標）

5. 既存の解決アプローチとその限界
5.1 アプローチ1: サーバー内メモリセッション — 手法 / 利点 / 限界
手法: 各ノードのメモリにセッション保持。
利点: 超低遅延。
限界: 水平スケールと失効同期に弱く、ノード障害で消失。

5.2 アプローチ2: 中央セッションストア照会（Opaque Token） — 手法 / 利点 / 限界
手法: 毎回Redis/DBでセッション検証。
利点: 即時失効しやすい。
限界: 全リクエストでネットワークI/Oが発生し遅延・コスト増。

5.3 アプローチ3: 純JWT（ステートレス） — 手法 / 利点 / 限界
手法: 署名検証のみで認証。
利点: 高速・高スケール。
限界: 発行済みトークンの即時失効が難しい。

5.4 アプローチ4: ハイブリッド（短命JWT + 失効状態） — 手法 / 利点 / 限界
手法: JWTはローカル検証、失効状態は軽量に共有。
利点: 速度と失効制御の両立。
限界: キャッシュ無効化・イベント配信の運用設計が必要。

6. 問題の本質的な困難
本質は「分散環境での失効状態伝播」を、認証ホットパスの速度を落とさずに扱う点です。
特に「管理者操作から全ノード反映までの時間」と「通常時の毎回照会回避」の両立が難所です。

7. 解決策
7.1 基本原理
- 短命Access Token（JWT, 例5分）+ Refresh Tokenの二層構成。
- ユーザー単位の`session_epoch`（失効バージョン）を導入。
- JWTに`tenant_id`,`user_id`,`session_id`,`epoch`を埋め込む。
- 管理者失効時は`session_epoch`をインクリメントし、既存JWTを一括無効化。
- 各端末は別`session_id`で同時ログイン可能。

7.2 実装方針
1. データモデル
`user_auth_state(tenant_id,user_id,session_epoch,updated_at)`
`sessions(tenant_id,session_id,user_id,device_id,status,refresh_hash,expires_at)`
2. 認証フロー
JWT署名・expをローカル検証し、`session_epoch`をローカルキャッシュ→必要時Redis参照で比較。
3. 管理者の即時失効
`session_epoch++`を原子的更新し、Pub/Subで全ノードにキャッシュ無効化通知。
4. Refresh Token制御
ローテーション方式＋失効済みセッションの再発行拒否。
5. 水平スケール対応
APIノードは無状態、Redis/DB共有、キーは必ず`tenant_id`名前空間付き。

8. 検証条件（Given/When/Then）
1. Given 同一ユーザーが端末A/Bを保有
When 両端末でログイン
Then `session_id`が2件発行され、双方のAPI認証が成功する。

2. Given 端末A/Bで有効トークン利用中
When 管理者が当該ユーザーを失効
Then 反映SLO内（例1秒以内）でA/Bとも401になり、Refreshも拒否される。

3. Given APIノードをN台からN+M台へ増設
When 新規ノードへトラフィックを振る
Then 認証結果と失効判定が既存ノードと一致する。

4. Given 通常トラフィック（キャッシュヒット主体）
When 認証ミドルウェアを計測
Then 追加レイテンシが目標内（例P99 3ms以下）となる。

5. Given テナントAのユーザートークン
When テナントBのリソースへアクセス
Then `tenant_id`不一致で必ず拒否される。

9. 制約、限界、今後の課題
- 「即座」は分散環境では厳密0ms保証は不可で、SLO定義が必要です。
- Redis障害時の方針（fail-open/fail-closed）を事前決定すべきです。
- マルチリージョン化時は失効伝播遅延が増えるため、リージョン間同期設計が追加課題です。
- 今後は監査ログ整備、失効操作の可観測性、カオステストを実施すべきです。
