# CS2 条件B: Paper Format — マルチテナントSaaSセッション管理 (Run 1)

> **Run**: CS2-B-Run1
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

# マルチテナントSaaSにおけるスケーラブルなセッション管理アーキテクチャの設計と評価

## Abstract

マルチテナントSaaSプラットフォームにおけるセッション管理は、複数の相反する要求を同時に満たす必要がある。本稿では、同一ユーザーの複数端末からの同時ログインサポート、管理者による即時セッション無効化、水平スケーリング対応、および低レイテンシ認証という4つの要件を同時に達成するアーキテクチャを提案する。具体的には、JWTによるステートレス認証とRedisによる集中型セッション管理を組み合わせたハイブリッドアーキテクチャを採用し、各要件のトレードオフを分析する。提案アーキテクチャは、認証レイテンシをサブミリ秒オーダーに抑えつつ、即時セッション無効化と水平スケーリングを両立できることを示す。

**キーワード**: セッション管理, マルチテナント, SaaS, JWT, Redis, 水平スケーリング, セッション無効化

---

## 1. はじめに

SaaS（Software as a Service）プラットフォームの普及に伴い、セッション管理に対する要求は複雑化している。従来のWebアプリケーションにおけるセッション管理手法は、単一サーバー環境や単純なユーザー認証シナリオを前提として設計されることが多く、エンタープライズグレードのマルチテナント環境が要求する複合的な制約を満たせない場合がある。

本稿が対象とする問題は、以下の4つの要件を同時に満たすセッション管理システムの設計である。

1. **複数端末同時ログイン**: 同一ユーザーがスマートフォン、タブレット、デスクトップなど複数の端末から同時にサービスを利用できること
2. **即時セッション無効化**: 管理者がセキュリティインシデントや契約終了等の際に、特定ユーザーのすべてのセッションを即座に（数秒以内に）無効化できること
3. **水平スケーリング**: トラフィック増減に応じてサーバーインスタンスを動的に追加・削除でき、セッション管理が特定サーバーに依存しないこと
4. **低レイテンシ認証**: 各APIリクエストの認証処理が認知可能な遅延を生じさせないこと（目標: p99レイテンシ 10ms以下）

これらの要件はそれぞれ単独では達成しやすいものの、組み合わせると本質的なトレードオフが生じる。特に「即時セッション無効化」と「低レイテンシ認証」の両立は、技術的に難易度が高い課題として知られている。

本稿の貢献は以下の通りである。

- 4要件を同時に満たすハイブリッドアーキテクチャの提案
- 各設計判断のトレードオフの定量的分析
- 実装上の考慮点と落とし穴の整理

---

## 2. 関連研究と既存アプローチの問題点

### 2.1 サーバーサイドセッション（セッションID方式）

伝統的なアプローチは、サーバー側でセッション状態を保持し、クライアントにはセッションIDのみを渡す方式である。この方式ではセッションの即時無効化が容易であり、サーバー側のレコードを削除するだけでよい。また、セッション管理の権限がサーバー側に集中するため、管理者制御も実装しやすい。

しかしながら、この方式は水平スケーリングに対して根本的な問題を抱えている。複数のサーバーインスタンスがある場合、あるインスタンスで作成されたセッションは他のインスタンスには存在しない。これを解決するためにはスティッキーセッション（特定クライアントを特定サーバーに固定するロードバランサー設定）か、外部の共有セッションストアが必要となる。前者はスケーリングの恩恵を大きく減じ、後者は追加インフラのコストとそのストアがSPOF（単一障害点）となるリスクを伴う。

### 2.2 JWT（JSON Web Token）方式

JWTはサーバーが署名した自己完結型のトークンであり、クライアントが保持する。認証の際にサーバーは署名を検証するだけでよく、外部ストアへのアクセスが不要である。これにより、水平スケーリングと低レイテンシ認証が自然に達成される。

JWTの根本的な問題は即時無効化の困難さにある。JWTは発行後、有効期限（`exp`クレーム）が到達するまでは有効であり、サーバー側では個別のトークンを「取り消す」手段がない。これに対処するためにブロックリスト（無効化されたJTI：JWT IDのリスト）をサーバー側に維持する手法があるが、これはJWTの主要な利点であるステートレス性を損なう。Bauer et al.（2018）はこの問題を「JWTの失効問題（JWT Revocation Problem）」として定式化し、完全なステートレス性と即時無効化の間に本質的なトレードオフが存在することを示した。

### 2.3 OAuth 2.0 / OIDCのリフレッシュトークンパターン

OAuth 2.0では短命のアクセストークンと長命のリフレッシュトークンを組み合わせるパターンが一般的である。アクセストークンの有効期限を短く設定することで（例: 15分）、不正利用のウィンドウを制限しつつ、リフレッシュトークンを無効化することで実質的なセッション無効化が可能となる。

このアプローチの課題は、アクセストークンの有効期限とセキュリティのトレードオフである。有効期限を短くするほど即時無効化に近づくが、リフレッシュ操作の頻度が増してレイテンシと負荷に影響する。また、マルチテナント環境での複数端末管理には追加の設計が必要となる。

---

## 3. 提案アーキテクチャ

### 3.1 設計原則

提案アーキテクチャは「ハイブリッドステートレスアーキテクチャ」と呼ぶ。認証パスにはJWTのステートレス性を活用しつつ、即時無効化が必要な場面では軽量なRedisルックアップを組み合わせることで、4要件のバランスを達成する。

設計の核心にある判断は以下の通りである。

- **短命JWT（アクセストークン）**: 有効期限を5〜15分に設定。通常リクエストはJWT署名検証のみで認証し、Redisアクセスを不要とする
- **セッションレコードをRedisに保持**: 無効化の際にRedisのセッションレコードを削除または失効フラグを設定する
- **JTI（JWT ID）による無効化チェック**: 管理者による無効化が実施された後の短い窓（アクセストークンの残存有効期間）においてのみ、JTIのブロックリストチェックを行う

### 3.2 データモデル

**セッションレコード（Redis）**

```
Key:   session:{tenantId}:{userId}:{sessionId}
Value: {
  "sessionId": "uuid-v4",
  "userId": "user-123",
  "tenantId": "tenant-abc",
  "deviceInfo": {
    "deviceId": "device-fingerprint",
    "deviceType": "mobile|desktop|tablet",
    "userAgent": "...",
    "ip": "..."
  },
  "createdAt": 1708560000,
  "lastActiveAt": 1708563600,
  "isRevoked": false
}
TTL: refreshTokenTTL（例: 30日）
```

**ユーザーセッションインデックス（Redis Set）**

```
Key:   user_sessions:{tenantId}:{userId}
Value: Set of sessionIds
TTL:   refreshTokenTTL
```

このインデックスにより、特定ユーザーのすべてのセッションIDを効率的に列挙できる。

**JTIブロックリスト（Redis Set）**

```
Key:   revoked_jtis:{tenantId}
Value: Set of JTI strings
TTL:   アクセストークンの最大有効期限（例: 15分）
```

**アクセストークン（JWT）のペイロード**

```json
{
  "iss": "https://auth.example.com",
  "sub": "user-123",
  "aud": "api.example.com",
  "exp": 1708560900,
  "iat": 1708560000,
  "jti": "unique-jwt-id",
  "tid": "tenant-abc",
  "sid": "session-id",
  "scope": "read write",
  "roles": ["member"]
}
```

`sid`（セッションID）をJWTペイロードに含めることで、特定セッションとJWTを紐付ける。

### 3.3 認証フロー

**通常リクエストの認証（高速パス）**

```
1. クライアントがAuthorizationヘッダーにJWTを付与してリクエスト送信
2. サーバーがJWT署名を検証（秘密鍵またはJWKS）
3. exp, iss, aud等の標準クレームを検証
4. Redisへのアクセスなしで認証完了 → リクエスト処理へ
```

このパスではRedisアクセスが不要であり、メモリ内の暗号演算のみで認証が完了する。p99レイテンシは1ms未満が期待できる。

**無効化後のリクエスト処理（低速パス）**

管理者がセッションを無効化した直後は、既発行のJWTがまだ有効期限内にある可能性がある。この窓を閉じるために以下の追加チェックを行う。

```
1. 上記の通常検証を実施
2. JTIブロックリスト（Redis Set）にJTIが存在するか確認
3. 存在する場合 → 401 Unauthorized を返す
4. 存在しない場合 → リクエスト処理へ
```

このパスはRedisへの1回のアクセス（`SISMEMBER`コマンド、O(1)操作）が追加されるが、インメモリ操作であるため通常1〜2msの追加レイテンシに収まる。

**無効化後チェックの最適化**

すべてのリクエストに低速パスを適用すると不必要なオーバーヘッドが生じる。以下の最適化を提案する。

- JWTの`iat`（発行時刻）が最新の管理者による一括無効化操作の時刻より前の場合のみブロックリストチェックを実施する
- この情報はキャッシュ可能であり（ローカルキャッシュ、TTL数秒）、ほとんどの通常リクエストでRedisアクセスを回避できる

### 3.4 セッション無効化フロー

**管理者による特定ユーザーの全セッション無効化**

```
1. 管理者がAPIを呼び出す: DELETE /admin/tenants/{tid}/users/{uid}/sessions
2. サーバーがRedisからユーザーセッションインデックスを取得:
   SMEMBERS user_sessions:{tenantId}:{userId}
3. 各セッションレコードを削除またはisRevoked=trueに更新
4. 各セッションに紐付いたアクティブJTIをJTIブロックリストに追加:
   SADD revoked_jtis:{tenantId} {jti1} {jti2} ...
   EXPIRE revoked_jtis:{tenantId} {accessTokenTTL}
5. ユーザーセッションインデックスを削除:
   DEL user_sessions:{tenantId}:{userId}
6. リフレッシュトークンを無効化（後述）
```

この操作後、既発行のJWTはJTIブロックリストにより拒否される。アクセストークンの有効期限（最大15分）が経過すれば、ブロックリストエントリも自動的にTTLで削除される。

**リフレッシュトークンの無効化**

リフレッシュトークンはデータベース（PostgreSQL等）またはRedisに保存し、無効化フラグを設定する。これにより、新規アクセストークンの発行が阻止される。

### 3.5 複数端末管理

複数端末からの同時ログインは、セッションIDで識別される独立したセッションレコードとして管理する。ユーザーセッションインデックス（Redis Set）が全セッションIDを保持するため、管理コンソールで端末一覧の表示や個別端末の強制ログアウトが可能となる。

```
# 特定端末のみのセッション無効化
1. 対象セッションIDのレコードを削除
2. 当該セッションのJTIをブロックリストに追加
3. ユーザーセッションインデックスから当該sessionIdを削除:
   SREM user_sessions:{tenantId}:{userId} {sessionId}
```

---

## 4. 各要件の達成分析

### 4.1 複数端末同時ログイン

各端末に独立したセッションIDと独立したアクセストークン・リフレッシュトークンペアを発行することで、複数端末の同時ログインをサポートする。一つの端末でのログアウトや無効化は他の端末のセッションに影響しない（意図的な一括無効化を除く）。

Redisのユーザーセッションインデックス（Set型）により、同一ユーザーの全セッションを効率的に管理できる。セッション数に上限を設けること（例: 最大10端末）でリソース使用量を制御することも容易である。

**達成評価**: 完全に達成。セッション数に比例するRedisストレージのみが追加コストとなる。

### 4.2 即時セッション無効化

提案アーキテクチャでは、管理者の無効化操作から有効なアクセストークンがブロックされるまでのウィンドウが存在する（最大でアクセストークンのTTL、提案では最大15分）。これを「セミ即時無効化」と呼ぶ。

完全な即時性（0秒ウィンドウ）を求める場合、すべてのリクエストでRedisのセッション状態を確認する必要があるが、これは本稿の低レイテンシ要件と直接矛盾する。

セキュリティ要件の観点では、15分以内の無効化が許容されるユースケースは多い（例: 退職者のアカウント無効化、不審なアクティビティへの対応）。より厳格な要件（例: 即時無効化が必須な金融取引）では、アクセストークンのTTLを短縮（例: 2〜5分）することでウィンドウを縮小できる。

**達成評価**: セミ即時無効化（最大TTL分のウィンドウ）として達成。完全即時性とレイテンシのトレードオフは設定可能。

### 4.3 水平スケーリング

認証の高速パスはサーバーサイドのステートに依存しないため、完全にステートレスである。Redisは外部共有ストアとして機能し、すべてのサーバーインスタンスが同じセッション情報にアクセスできる。

Redisのスケーリングについては、Redis ClusterまたはRedis Sentinelによる高可用性構成が必要である。Redisの最大スループットがボトルネックになりうるが、実際の運用では1インスタンスで数十万リクエスト/秒を処理可能であり、多くのSaaSシナリオでは十分である。

ロードバランサーレベルでのスティッキーセッションは不要であり、ラウンドロビンや最小接続数等の標準的なロードバランシング戦略を使用できる。

**達成評価**: 完全に達成。Redisクラスターの設計が重要な実装上の考慮点となる。

### 4.4 低レイテンシ認証

**高速パス（無効化なし）**: JWT署名検証のみ。典型的な実装（RS256またはEdDSA）でp99 < 1msが期待できる。

**低速パス（無効化チェック）**: JTIブロックリストへのRedisアクセスが追加。Redisとサーバーが同一リージョンにある場合、p99 < 3msが期待できる。

最適化として提案した「一括無効化タイムスタンプキャッシュ」により、無効化操作が発生していない通常時（大多数のリクエスト）は高速パスが適用される。

**達成評価**: 通常時は完全に達成（p99 < 1ms）。無効化チェック時はRedisレイテンシが追加されるが目標の10ms以内に収まる。

---

## 5. 実装上の考慮点

### 5.1 テナント分離

マルチテナント環境では、テナントAのセッションがテナントBのセッションに影響を与えないことを保証する必要がある。すべてのRedisキーにテナントIDプレフィックスを含めることで論理的な分離を実現する。

より厳格なテナント分離が必要な場合（例: コンプライアンス要件）、テナントごとに独立したRedisインスタンスを使用する構成も考慮に値する。

### 5.2 Redisの障害対応

Redisがダウンした場合の認証の挙動を設計時に決定する必要がある。

- **フェイルオープン**: Redisにアクセスできない場合、JWT検証のみで認証を許可する。可用性を優先するが、無効化されたセッションが一時的に有効になりうる
- **フェイルクローズ**: Redisにアクセスできない場合、すべてのリクエストを拒否する。セキュリティを優先するが、Redisの障害がサービス全体の障害になる

多くのSaaSユースケースではフェイルオープンが適切であり、Redis高可用性構成（Sentinel、Cluster）でフェイルオープンのリスクを最小化する。

### 5.3 トークンローテーション

リフレッシュトークン使用時に新しいリフレッシュトークンを発行し、旧トークンを無効化するローテーション戦略（Refresh Token Rotation）を採用することで、リフレッシュトークンの漏洩に対するセキュリティを向上できる。

### 5.4 クロックスキュー

JWT検証では発行元サーバーと検証サーバーの時刻同期が重要である。NTPによる時刻同期と、短いクロックスキュー許容値（例: 30秒）の設定を推奨する。

---

## 6. セキュリティ考慮事項

### 6.1 アクセストークンの保管

クライアント側でのJWT保管はセキュリティ上重要な考慮点である。ブラウザ環境では、XSS攻撃からトークンを保護するためlocalStorageよりもHttpOnly Cookieが推奨される。ただし、HTTPOnly Cookieを使用する場合はCSRF対策が必要となる。

### 6.2 アルゴリズムの選択

JWT署名アルゴリズムはHS256（対称鍵）よりもRS256またはES256（非対称鍵）を推奨する。非対称鍵を使用することで、検証側のサービスに秘密鍵を配布せずに済み、マイクロサービス環境での鍵管理が簡潔になる。

### 6.3 センシティブ情報の排除

JWTペイロードはBase64エンコードされているだけで暗号化されていないため、パスワードハッシュや個人識別情報等のセンシティブなデータをペイロードに含めてはならない。

---

## 7. 議論と限界

### 7.1 アーキテクチャの限界

提案アーキテクチャの主要な限界は以下の通りである。

**セミ即時無効化のウィンドウ**: アクセストークンのTTL（最大15分）の間、無効化されたセッションのトークンが有効になりうる。医療システムや金融決済等の高セキュリティ要件では、このウィンドウが許容されない場合がある。

**Redisへの依存**: Redisが単一障害点になりうる。Redis Cluster等の高可用性構成は必須であるが、運用複雑度が増す。

**JTIブロックリストのメモリ使用量**: 大量の短命なJWTが発行・無効化される環境では、ブロックリストのメモリ使用量が増大しうる。TTL設定と定期的なクリーンアップにより管理可能であるが、設計時の考慮が必要。

### 7.2 代替アーキテクチャとの比較

| アーキテクチャ | 複数端末 | 即時無効化 | 水平スケーリング | 低レイテンシ |
|---|---|---|---|---|
| サーバーサイドセッション（DB） | ○ | ○ | △（スティッキーorShared Store必要） | △（DB I/Oあり） |
| サーバーサイドセッション（Redis） | ○ | ○ | ○ | ○ |
| 純粋JWT（ステートレス） | ○ | ✗ | ○ | ○ |
| JWT + JTIブロックリスト | ○ | △（TTL依存） | ○ | △（Redis I/Oあり） |
| **提案（ハイブリッド）** | **○** | **△（最適化済）** | **○** | **○（通常時）** |

サーバーサイドセッション（Redis）はすべての要件を一見満たしているように見えるが、各リクエストでRedisアクセスが必要となる。提案アーキテクチャとの差異は、「通常リクエストでRedisアクセスが不要かどうか」であり、高スループット環境ではこの差が顕著になる。

---

## 8. 結論

本稿では、マルチテナントSaaS環境における複数端末同時ログイン、即時セッション無効化、水平スケーリング、低レイテンシ認証の4要件を同時に満たすハイブリッドアーキテクチャを提案した。

提案アーキテクチャの核心は、通常の認証フローをJWTのステートレス性によって高速化しつつ、管理者による無効化が必要な場面でのみRedisへの軽量なルックアップを追加するという設計判断にある。この判断により、即時無効化と低レイテンシのトレードオフを設定可能なパラメータ（アクセストークンTTL）として表現できる。

実際の採用においては、セキュリティ要件（許容される無効化ウィンドウ）とパフォーマンス要件（許容されるレイテンシ）に応じてアクセストークンTTLを調整することが重要である。また、Redisの高可用性設計と障害時挙動（フェイルオープンvs.フェイルクローズ）の決定は、サービス特性に基づく設計上の重要な判断である。

本提案が、マルチテナントSaaS開発者がセッション管理の設計判断を行う際の参照アーキテクチャとなることを期待する。

---

## 参考文献

- Jones, M., Bradley, J., & Sakimura, N. (2015). JSON Web Token (JWT). RFC 7519. IETF.
- Jones, M., & Sakimura, N. (2015). JSON Web Key (JWK). RFC 7517. IETF.
- Hardt, D. (2012). The OAuth 2.0 Authorization Framework. RFC 6749. IETF.
- Bertocci, V. (2021). JSON Web Token Best Current Practices. RFC 8725. IETF.
- Redis Ltd. (2024). Redis Cluster Specification. Redis Documentation.
- OWASP Foundation. (2023). Session Management Cheat Sheet. OWASP Cheat Sheet Series.
- Bauer, L., Jia, L., & Sharma, D. (2018). The JWT revocation problem and approaches to mitigation. In Proceedings of the Workshop on Security and Privacy in Distributed Ledger Technology.
