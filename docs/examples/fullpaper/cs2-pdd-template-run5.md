# CS2 条件C: PDD Template — マルチテナントSaaSセッション管理 (Run 5)

> **Run**: CS2-C-Run5
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c799e-9b6f-7772-ae2f-7b93bbf39395)
> **Model**: GPT-5.2 (via Codex)

---

**題目**
多テナントSaaSにおける低遅延・即時失効・水平スケール両立型セッション管理方式

§1. 問題定義
§1.1 背景
多テナントSaaSでは、認証基盤に対して「高可用性」「低遅延」「強い管理統制」が同時に求められます。特にセッション管理は、ユーザー体験（複数端末利用）と運用統制（管理者による即時失効）の両立が難しい中核機能です。

§1.2 矛盾する要求（対立するトレードオフ）
1. 低レイテンシ認証 vs 即時失効
署名検証のみのローカル判定は高速ですが、失効反映が遅れます。
2. 水平スケーリング vs 一貫した失効状態
ノードを増減すると、失効情報の同期遅延が発生しやすくなります。
3. 複数端末同時ログイン許容 vs セキュリティ統制の強化
端末ごとの独立性を保ちつつ、必要時にはユーザー単位で一括失効できる必要があります。

§1.3 本文書の範囲
本稿は、API認証層のセッション管理方式を対象とします。SSO連携仕様そのもの、UI設計、課金・監査要件の詳細は対象外とします。

§2. 現状のアーキテクチャと制約
想定構成は、`LB -> APIノード群 -> 認証/セッション基盤`です。
制約は以下です。
1. APIノードはステートレス運用（スティッキーセッション非依存）。
2. 多テナント分離（`tenant_id`を全キー空間とトークンクレームに含める）。
3. 認証は高頻度処理であり、毎リクエストの集中ストア参照は避けたい。
4. 失効は全ノードへ短時間で伝播する必要がある。

§3. 既存アプローチとその限界
§3.1 アプローチ1: 中央集約セッションストア方式
手法: セッションIDを保持し、毎回Redis等で照会。
利点: 失効が即時に反映しやすい。
限界: ネットワーク往復が必須で遅延増、集中点の負荷・障害影響が大きい。

§3.2 アプローチ2: 完全ステートレスJWT方式
手法: APIノードで署名・期限のみ検証。
利点: 非常に低遅延で水平スケールしやすい。
限界: 発行済みトークンの即時失効が困難（短TTL頼み）。

§3.3 アプローチ3: オペークトークン＋イントロスペクション方式
手法: 認証サーバへ都度問い合わせ。
利点: ポリシー集中管理が容易。
限界: 認証サーバがボトルネック化し、遅延と可用性リスクが増える。

§4. 問題の本質
本質は、「ローカル高速判定」と「グローバル失効一貫性」を同時に満たすことです。
すなわち認証判定は、`暗号学的正当性`に加えて`最新失効状態`を、許容遅延内で参照できる設計が必要です。

§5. 提案手法
§5.1 基本原理
提案は**Epochベースのハイブリッド方式**です。
1. アクセストークンは短TTL（例: 3〜5分）の署名付きトークン。
2. ユーザー単位で`revoked_after`（失効Epoch）を保持。
3. APIノードは通常、署名検証＋ローカルキャッシュのEpoch比較で判定。
4. 管理者失効時は`revoked_after`を更新し、イベント配信で全ノードへ即時反映。
5. 端末ごとに独立セッションIDを持たせ、複数端末同時ログインを自然に許容。

§5.2 実装アーキテクチャ
1. `Auth Service`: トークン発行、Refreshローテーション。
2. `Session Store (Redis + 永続DB)`: セッション・失効Epochの保存。
3. `Event Bus`: `invalidate-user(tenant_id, user_id, epoch)`を配信。
4. `API Node Local Cache`: `user_epoch`をメモリ保持し高速判定。

認証フロー:
1. トークン署名/有効期限をローカル検証。
2. `tenant_id, user_id, iat`を抽出。
3. ローカル`user_epoch`と比較し、`iat < epoch`なら拒否。
4. キャッシュミス時のみRedis参照し、結果を短TTLで再キャッシュ。

失効フロー:
1. 管理者操作で`user_epoch`更新（原子的）。
2. 更新イベントを全ノードへ配信。
3. 各ノードが即時にローカルキャッシュ更新。
4. 以降、当該ユーザーの既存トークンは即時拒否。

§6. 検証可能な性質（Given/When/Then）
1. Given 同一ユーザーが端末A/Bでログイン済み
   When A/Bから同時に認証リクエスト
   Then 両方のセッションが独立して成功する。

2. Given ユーザーUに有効セッションが複数存在
   When 管理者が`invalidate(U)`を実行
   Then 伝播完了時間Δ以内に、全ノードでUの既存トークンが拒否される。

3. Given APIノード数を3台から30台へ増加
   When スティッキーセッションなしで負荷分散
   Then 認証可否と失効判定の整合性は維持される。

4. Given ローカルキャッシュヒット率95%以上
   When 通常認証トラフィックを処理
   Then 認証処理のp99遅延は低値（例: 単一桁ms）を維持する。

5. Given `tenantA/userX`と`tenantB/userX`が存在
   When `tenantA/userX`のみ失効
   Then `tenantB/userX`のセッションには影響しない。

§7. 制約と今後の課題
1. 即時性はイベント伝播遅延と時計ずれに依存します。
2. 障害時の整合性境界（Event Bus遅延、Redis分断）を明確化する必要があります。
3. クロスリージョン運用では失効反映遅延が増えるため、リージョン間戦略が必要です。
4. 今後は、形式検証（例: 状態遷移のモデル検証）と運用SLOの定量化を進めるべきです。
