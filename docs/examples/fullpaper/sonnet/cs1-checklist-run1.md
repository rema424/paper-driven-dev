# CS1 条件D: Structured Checklist — RAG引用リナンバリング (Run 1)

> **Run**: CS1-D-Run1
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

## 1. 問題の背景と文脈

RAG（Retrieval-Augmented Generation）システムは、ユーザーの質問に対して外部知識ベースから関連文書を検索し、その検索結果をコンテキストとしてLLMに渡すことで回答を生成する。検索された文書には `source_3`, `source_7` のような内部識別子が付与されており、LLMはプロンプト内でこれらの識別子を使って参照する。

一方、エンドユーザー向けのUIでは `[1]`, `[2]`, `[3]` のような連番形式の引用表示が一般的であり、可読性と引用の追跡可能性を高める。

現代のRAGシステムでは、レイテンシを最小化するためにストリーミング（逐次トークン配信）が標準的な配信方式である。LLMはトークンを一つずつ生成・送信するため、回答全体が確定する前からUIへのデータ配信が始まる。

この状況下で「内部識別子 → ユーザー向け連番」のリナンバリング（番号付け直し）を行うことは、次のような技術的困難を生む。

- ストリーミング途中では最終的にどの `source_*` が登場するかが未確定
- 先に割り当てた番号が後から追加の引用によって意味的に不整合になる可能性がある
- リアルタイム表示とバッチ変換の要求が衝突する

---

## 2. 対立する要求やトレードオフ

### トレードオフ A: リアルタイム性 vs. 番号の安定性

ストリーミング表示ではトークンが到着するたびにUIを更新することでユーザーに即時フィードバックを提供する。しかし、引用番号をリアルタイムで割り当てると「先着順」に番号が確定してしまい、後続で同じソースが再参照される場合は同じ番号を維持できるが、もし途中で別のソースが登場した場合に番号の順序が意味的に崩れるリスクがある。

逆に全文確定後に変換する（バッチ変換）と番号の整合性は保証されるが、ストリーミングの恩恵（低知覚レイテンシ）が失われる。

**具体的な衝突**: 第1文で `source_7` が出現して `[1]` を割り当て、第3文で `source_3` が出現して `[2]` を割り当てた場合、ソース一覧では `source_3` が内部的に小さい番号を持つかもしれないが、表示上は `[2]` となる。これ自体は問題ないが、後から番号を変更しようとすると既に表示済みのテキストとの不整合が生じる。

### トレードオフ B: UX の即時性 vs. 後から変わらない保証

「一度表示した番号が後から変わらない」という要件と「ストリーム完了時にソース一覧と整合している」という要件は、実装戦略によっては両立しない。

番号を後から変更できる（ページの再レンダリングや置換）実装にすると「変わらない」という保証が破られる。一方で変更不可にすると、ストリーム完了時のソース一覧の並び順をどう決めるかという問題が生じる。

### トレードオフ C: 実装のシンプルさ vs. 柔軟性

プレフィックスバッファリング（引用番号が確定するまで出力を遅延する）はシンプルだが、引用がテキスト全体に散らばる場合に実質的なストリーミング効果が消失する。一方、引用番号の割り当てを即座に行いソース一覧の順序を「表示順」に追従させる設計はシンプルで確実だが、慣習的な「ソース番号順」の期待を裏切る可能性がある。

---

## 3. 分析の対象範囲

本分析の対象範囲は以下の通りである。

- **対象**: ストリーミングRAGシステムにおける引用リナンバリングの設計問題
- **対象レイヤー**: バックエンド（LLM推論・ストリーミング配信）、フロントエンド（UI表示・引用マーカーのレンダリング）、および両者の間のプロトコル設計
- **前提とする引用形式**: LLM出力内では `[source_N]` または `(source_N)` 形式、ユーザー表示では `[1]`, `[2]` 形式
- **対象外**: 検索（Retrieval）フェーズの設計、LLMのファインチューニングによる引用スタイル変更、マルチターン対話における引用の継続

---

## 4. 現状のアーキテクチャと制約

### 典型的なRAGストリーミングアーキテクチャ

```
[User Query]
     ↓
[Retriever] → [source_1, source_3, source_7, ...]
     ↓
[LLM Prompt] = システムプロンプト + 検索結果 + クエリ
     ↓
[LLM Inference] → トークンをストリームで配信
     ↓
[Streaming Layer] → SSE / WebSocket / HTTP Chunked
     ↓
[Frontend] → リアルタイムUI更新
```

### アーキテクチャ上の制約

1. **LLM出力の不確定性**: LLMはどのソースを引用するかを生成途中に決定するため、回答開始時点では引用パターンが未知
2. **ストリームの単方向性**: 一度クライアントに送信したトークンは訂正・置換が困難（既にレンダリング済み）
3. **引用の散在**: 引用マーカーはテキストの任意の位置に出現する可能性があり、先読みが困難
4. **同一ソースの複数参照**: 同じ `source_N` が複数回出現した場合、同一の表示番号に対応させる必要がある
5. **プロンプト内の識別子設計**: LLMに渡すプロンプト内でソースをどう識別するかがリナンバリング戦略に影響する

---

## 5. 既存の解決アプローチとその限界

### 5.1 アプローチ1: バッチ変換（ポストプロセッシング）

**手法**: LLMの出力全体をバッファリングし、ストリーム完了後に内部識別子を連番に一括置換してからUIに表示する。

**利点**:
- 実装がシンプル
- 番号の整合性が完全に保証される
- ソース一覧の順序を自由に定義できる（出現順、重要度順など）

**限界**:
- ストリーミングの恩恵を完全に失う（初回表示までの時間がLLM推論時間全体になる）
- 長い回答（数百トークン）ではUXが著しく悪化する
- 要件の「ストリーミング中にリアルタイムで表示する」と直接矛盾する

---

### 5.2 アプローチ2: 先着順リナンバリング（クライアントサイド）

**手法**: ストリームを受信しながらクライアント側で `source_N` の出現を検出し、初出現時に `[1]`, `[2]` と順番に割り当てるマッピングテーブルを構築する。

**利点**:
- ストリーミングを維持したままリアルタイムで番号を表示できる
- バックエンドの変更が不要
- 「一度表示した番号が後から変わらない」を自然に満たす

**限界**:
- 番号の割り当てが出現順に依存するため、ソース一覧の「標準的な」並び順（検索スコア順など）と一致しない場合がある
- クライアントが `source_N` トークンを確実に検出するためのパーサが必要（部分トークンへの対応）
- トークン境界の問題: `source_` と `7` が別トークンで到着する場合、識別子の完成を待つ必要がある

---

### 5.3 アプローチ3: サーバーサイドプロキシ変換（ストリーム中間処理）

**手法**: バックエンドでLLMのストリームを受信し、引用パターンを検出して変換した上でクライアントに転送する。引用識別子の完全なトークンが揃った時点で番号を割り当て、変換済みストリームを送信する。

**利点**:
- クライアントは変換済みの番号を受け取るだけでよい
- 検出ロジックを一箇所に集約できる

**限界**:
- サーバーサイドでのバッファリングが必要（識別子のトークンが揃うまで待機）
- バッファリングにより体感レイテンシが増加
- 識別子が複数のチャンクに分割された場合の処理が複雑
- 部分的なバッファリングがストリームの「滑らかさ」を損なう

---

### 5.4 アプローチ4: プレースホルダー + 事後解決（Two-Pass）

**手法**: ストリーミング中は `[source_3]` のような内部識別子をそのままUIに表示し（または `[?]` のようなプレースホルダーを使用）、ストリーム完了後にDOMを更新して最終的な番号に置き換える。

**利点**:
- ストリーミングを維持できる
- ソース一覧との整合性を完全に保証できる

**限界**:
- 「一度表示した番号が後から変わらない」という要件に直接違反する
- `[?]` の表示はUXとして違和感がある
- DOM更新によるチラツキ（FOUC的な現象）が発生する可能性がある

---

## 6. 問題の本質的な困難

この問題の本質的な困難は、**「情報の完全性」と「表示の即時性」の間に存在する根本的な非対称性**にある。

番号を確定させるためには「全体を見渡す」必要があるが、ストリーミングは「部分を逐次配信する」ことを本質とする。この非対称性は、以下の形で具体化される。

**問題の核心**: 引用番号の割り当てルールが「表示順（先着順）」である場合は情報の完全性なしに決定できるが、それ以外のルール（スコア順、アルファベット順など）では完全な情報が必要になる。

言い換えれば、「後から変わらない」という制約は「番号の決定ルールが単調増加的（先着順）であること」を事実上要求する。これを受け入れれば問題は解消し、受け入れなければバッチ処理が必要になる。

また、**トークン境界の問題**も本質的な困難の一つである。ストリーミングではLLMが生成する識別子（`source_7` など）が複数のトークンに分割される場合があり、識別子の途中までしか受信していない状態で番号割り当てを行うことはできない。これは避けがたい「最小バッファリング」の必要性を意味する。

---

## 7. 解決策

### 7.1 基本原理

上記の分析から、以下の基本原理を採用する。

**原理1: 番号割り当てルールを「初出現順（先着順）」に固定する**

これにより、ストリーミング中でも番号の決定が可能になり、「一度表示した番号が後から変わらない」が自動的に保証される。ソース一覧の表示順もこの「初出現順」に従う。

**原理2: 識別子トークンの最小バッファリングのみを行う**

テキスト全体のバッファリングは行わない。引用識別子の開始パターン（例: `[source_`）を検出した時点からバッファリングを開始し、識別子の終端（`]`）を受信した時点でマッピングを確定・変換して送信する。識別子以外のテキストはバッファなしで即座に送信する。

**原理3: ストリーム完了時のソース一覧は引用出現順で生成する**

ソース一覧の順序を引用の出現順（= 番号割り当て順）に合わせることで、「ソース一覧との整合性」を自然に満たす。

### 7.2 実装方針

#### バックエンド: ストリーム変換レイヤー

LLMのストリーム出力とクライアントの間に軽量な変換レイヤーを設ける。

```
状態機械の定義:
- 状態: PASSTHROUGH（通常テキスト）
- 状態: BUFFERING（識別子の途中）

PASSTHROUGH 状態:
  - テキストをそのままクライアントに転送
  - `[source_` パターンを検出したら BUFFERING に遷移

BUFFERING 状態:
  - 受信バイトをバッファに追加
  - `]` を受信したら:
    1. バッファから識別子を確定（例: source_7）
    2. マッピングテーブルを参照（未登録なら新しい番号を割り当て）
    3. 変換済みトークン（例: [2]）をクライアントに送信
    4. バッファをクリアして PASSTHROUGH に遷移
```

#### クライアント: 最小限の引用マッピング

バックエンドが変換を行う場合、クライアントには変換済みの `[1]`, `[2]` が届くため、クライアントサイドの複雑な処理は不要になる。

バックエンドでの変換が難しい場合（例: 直接LLM APIを使用）は、クライアントサイドで同じ状態機械を実装する。この場合、テキストノードのストリーミング挿入と引用番号の解決を分離するため、以下の戦略を使う。

```
ストリーム受信処理:
  1. 通常テキストは `<span>` に追加（即座）
  2. 識別子検出時はバッファリング（`[source_` 〜 `]` まで）
  3. 識別子確定時:
     a. 番号を割り当て（マッピングテーブル参照/更新）
     b. 引用番号 `<cite>[N]</cite>` ノードを挿入
  4. ストリーム完了時:
     a. 出現した識別子の一覧からソース一覧を生成
     b. ソース一覧は出現順（= 番号順）で表示
```

#### メタデータの配信: 構造化ストリームプロトコル

テキストトークンと引用メタデータを混在させるため、SSEのイベント型を分離する。

```
event: token
data: {"text": "RAGは"}

event: token
data: {"text": "効果的です"}

event: citation
data: {"internal_id": "source_7", "display_num": 1, "position": 42}

event: token
data: {"text": "[1]"}

event: done
data: {"sources": [{"num": 1, "id": "source_7", "title": "...", "url": "..."}]}
```

これにより、クライアントは `citation` イベントを受信した時点でソースカードの事前準備ができ、`done` イベントでソース一覧を最終確定できる。

---

## 8. 検証条件

### 検証1: 単一引用のリナンバリング

**Given**: LLMが `source_7` を唯一の引用として含む回答をストリーミング生成する

**When**: クライアントがストリームを受信して表示する

**Then**:
- ストリーム受信中に `[1]` が表示される
- ストリーム完了後、ソース一覧に `[1] source_7` の内容が表示される
- `[1]` の番号はストリーム開始から完了まで変化しない

### 検証2: 複数引用の先着順割り当て

**Given**: LLMが `source_7`, `source_3`, `source_7`（再登場）の順で引用を含む回答を生成する

**When**: クライアントがストリームを受信して表示する

**Then**:
- `source_7` の初出現時点で `[1]` が割り当てられる
- `source_3` の初出現時点で `[2]` が割り当てられる
- `source_7` の再登場時は既存の `[1]` が使われる
- ソース一覧は `[1] source_7`, `[2] source_3` の順で表示される
- ストリーム中に割り当て済みの番号は変化しない

### 検証3: トークン境界にまたがる識別子

**Given**: LLMが `source_` と `13` と `]` を別チャンクで送信する

**When**: ストリーム変換レイヤーが識別子を検出・解決する

**Then**:
- `source_` 受信時点では出力が保留される（バッファリング状態）
- `13]` 受信完了後に `[N]`（新規割り当て番号）が出力される
- クライアント側では `source_` の途中状態が表示されない

### 検証4: ストリーム完了後のソース一覧整合性

**Given**: ストリーミング中に `[1]`, `[2]`, `[3]` が表示された

**When**: ストリームが完了してソース一覧が表示される

**Then**:
- ソース一覧の項目数が引用された一意のソース数と一致する
- 各ソースの番号がテキスト内の表示番号と一致する
- ソース一覧の順序が引用の初出現順と一致する

### 検証5: 引用なし回答

**Given**: LLMが引用マーカーを含まない回答を生成する

**When**: クライアントがストリームを受信して表示する

**Then**:
- ソース一覧セクションが表示されない（または空であることが明示される）
- テキスト表示は引用ありの場合と同等のレイテンシで行われる

---

## 9. 制約、限界、今後の課題

### 現在の設計の制約

**制約1: 番号割り当てルールが先着順に固定される**

ユーザーによっては「最も重要なソースが `[1]` であってほしい」と期待する場合があるが、ストリーミング中は重要度順の割り当てが不可能である。この制約は要件（「一度表示した番号が後から変わらない」）と「任意の順序での番号割り当て」の根本的なトレードオフから来ており、ストリーミング要件を維持する限り回避できない。

**制約2: 識別子形式の固定**

提案する状態機械は `[source_N]` という特定の識別子形式を前提とする。LLMが異なる形式（例: `(ref:3)`, `<citation id="source_3"/>`）を使う場合はパーサの修正が必要になる。LLMプロンプトで引用形式を明示的に指定することでこの制約を管理する。

**制約3: ネットワーク中断時の部分状態**

ストリーミング中にネットワーク接続が切断された場合、クライアントは中途半端な状態（一部の引用のみマッピング済み）になる。再接続・再送信の戦略が別途必要である。

### 限界

**LLMの引用精度の限界**: リナンバリング設計がどれだけ優れていても、LLMが存在しないソースを引用したり、無関係なソースを参照したりする幻覚（hallucination）は防げない。引用の内容的な正確性は別の仕組み（引用検証レイヤー）で担保する必要がある。

**スケーラビリティの限界**: 多数の同時接続ユーザーがいる場合、バックエンドのストリーム変換レイヤーが各接続ごとに状態（マッピングテーブル）を保持するため、メモリ使用量が増加する。ステートレス設計への移行（クライアントサイド変換）も選択肢として検討すべきである。

### 今後の課題

1. **マルチターン対話における引用継承**: 複数回のやり取りにわたって引用番号の一貫性をどう維持するか（前のターンで `[3]` だったものが次のターンでも `[3]` であるべきか）
2. **引用の信頼度スコア表示**: `[1]` の背後にある文書の検索スコアや関連度をユーザーに提示する方法
3. **クロスリファレンスの検証**: ストリーム完了後に、テキスト内の番号とソース一覧の整合性を自動検証する軽量な仕組みの導入
4. **多言語対応**: 引用識別子の検出パターンが言語によって変わる場合（例: 全角括弧 `［source_7］`）への対応
5. **引用のインタラクティビティ**: ユーザーが `[1]` をクリックした際にソースカードをインラインで表示するUI設計と、ストリーミング中の状態管理との協調
