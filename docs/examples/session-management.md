# Example: マルチテナント SaaS におけるセッション管理方式の設計分析

> This document was generated using the `/paper-driven-dev:article` skill.
> It demonstrates PDD applied to a different domain (authentication/session management).

---

## 1. 問題定義

### 1.1 背景

マルチテナント SaaS では、セッション管理は認証機能ではなく、セキュリティ統制・運用性・性能を同時に規定する基盤機能である。特に「複数デバイス同時ログイン」と「管理者による即時無効化」は、利便性と統制の両立を要求する。さらに水平スケーリング前提では、単一ノード内状態に依存しない方式が必要である。

### 1.2 矛盾する要求（対立するトレードオフ）

1. **低レイテンシ vs 即時無効化**: ローカル検証は速いが失効反映が遅れる。中央ストア参照は整合性が高いが遅延が増える。
2. **水平スケーリング vs 強整合な失効判定**: 中央状態の参照は整合性向上と引き換えに遅延増・可用性依存を招く。
3. **複数デバイス許容 vs 細粒度無効化**: セッション粒度が増えるほど状態管理コストが増大する。

### 1.3 本文書の範囲

本分析は「API 認可時のセッション有効性判定」を対象とする。IdP 連携方式（OIDC/SAML 詳細）、MFA ポリシー、UI/運用手順の詳細は範囲外とする。

---

## 2. 現状のアーキテクチャと制約

本分析の前提は、`LB → 複数 API ノード → 共有データストア` の一般的 SaaS 構成である。制約は以下:

1. API ノードはオートスケールし、ノードローカル状態に依存できない
2. テナント境界を越える影響（誤失効）は許容不可
3. 無効化要求は運用上「即時」（実務上はサブ秒〜1秒台）である必要がある
4. 認証処理の追加遅延は API 全体 p99 を悪化させないことが必要

---

## 3. 既存アプローチとその限界

### 3.1 アプローチ A: 長寿命 JWT（完全ステートレス）

**手法**: Access Token を長寿命（例: 24時間）の JWT として発行し、各 API ノードで署名検証のみ行う。

**利点**: 各ノードで完結する署名検証のみで低遅延・高スケール。外部ストア依存なし。

**限界**: 管理者による失効がトークン期限まで反映されない。即時無効化要件を根本的に満たせない。

### 3.2 アプローチ B: Opaque Token + 中央セッションストア

**手法**: Opaque Token を発行し、毎リクエストで中央ストア（RDB/Redis）を参照してセッション有効性を確認する。

**利点**: 失効を即時反映可能。端末単位の管理が容易。

**限界**: 全リクエストでネットワーク I/O が発生し、レイテンシ・コスト・可用性がストアに依存する。ストア障害が全 API に波及する。

### 3.3 アプローチ C: スティッキーセッション（ノード内メモリ）

**手法**: ロードバランサのスティッキーセッションで特定ノードにルーティングし、ノード内メモリでセッション管理する。

**利点**: 単一ノード内では高速。外部ストア不要。

**限界**: ノード障害・再配置でセッション消失。水平スケール・ノード横断での即時全体失効に不向き。

### 3.4 アプローチ D: 短寿命 JWT + 失効リスト（Denylist）

**手法**: Access Token を短寿命（例: 5分）の JWT にし、失効リスト（Denylist）を中央ストアで管理する。

**利点**: 通常時はステートレス検証、失効時は Denylist 参照で対応。

**限界**: 失効リストの管理と配信が必要。TTL 以内の失効遅延を完全には排除できない。失効リストの肥大化対策も必要。

---

## 4. 問題の本質

上記の分析から、問題の本質が明らかになる:

> **本問題は「身元証明」ではなく、「可変なセッション有効状態を分散ノード間で低遅延に整合させる問題」である。**

最適化対象は `認可遅延の最小化` の下で `失効反映遅延を厳格に上限制約` する設計である。完全ステートレス（アプローチ A）は遅延ゼロだが失効不可、完全ステートフル（アプローチ B）は即時失効だが遅延増——この連続体の上で最適点を見つける問題に帰着する。

---

## 5. 提案手法: Versioned Session Authority

### 5.1 基本原理

**Versioned Session Authority（バージョン付きセッション権威）** を提案する:

1. アクセストークンは短寿命 JWT（例: 5分）で高速検証
2. サーバ側に可変状態を保持し、**ユーザー単位バージョン (usv)** と **セッション単位状態 (sid)** を分離
3. 管理者失効時は `usv` を単調増加させ、イベント配信で各ノードへ即時伝播
4. API ノードはローカルキャッシュ優先、ミス時のみ Redis 参照
5. 判定不確実時は fail-closed（安全側）を基本とする

### 5.2 実装アーキテクチャ

構成要素: `Auth Service`、`Redis Cluster`（ホットパス）、`RDB`（永続監査）、`Event Bus`（失効通知）、`API Node Local Cache`。

```
JWT claims: tid, uid, sid, usv, iat, exp, jti

Redis keys:
  usv:{tid}:{uid}  →  integer
  sid:{sid}         →  active|revoked (TTL 付き)
```

主要フロー:

1. **ログイン**: `sid` 発行、現在の `usv` スナップショットを JWT に埋め込み
2. **API 呼び出し**: JWT 署名検証 → `token.usv` と現在 `usv`、`sid` 状態を照合
3. **管理者失効**: 対象ユーザーの `usv` 更新（または `sid` 個別失効）→ 失効イベントを配信
4. **リフレッシュ**: `sid` が有効な場合のみ新 JWT を再発行

通常時は JWT 署名検証 + ローカルキャッシュヒットで低遅延、失効時は Event Bus による即時伝播で即時性を両立する。

---

## 6. 検証可能な性質

**性質 1: 複数デバイス独立性**
Given: 同一ユーザーが3デバイスでログイン済み。When: 同時に API を呼び出す。Then: 3つの `sid` が独立して有効で、全要求が成功する。

**性質 2: 即時無効化**
Given: 有効セッションが複数存在。When: テナント管理者がユーザー失効操作を実行。Then: p99 1秒以内に全デバイスで 401 となる。

**性質 3: 個別セッション失効**
Given: 3セッション A/B/C が有効。When: B のみ失効。Then: B は拒否、A/C は継続成功。

**性質 4: スケーラビリティ**
Given: API ノード数を 10 から 100 に増加。When: 負荷を 10 倍化。Then: 認可処理 p99 増分が許容値（例: +5ms 以内）に収まる。

**性質 5: キャッシュ効率**
Given: キャッシュヒット率 99% 以上。When: 定常負荷で連続実行。Then: Redis 参照率が低位に保たれ、スケールアウト時も線形に近い性能を示す。

**性質 6: テナント分離**
Given: tenant A/B に同一 `uid` 文字列が存在。When: tenant A で失効。Then: tenant B のセッション判定に影響しない。

**性質 7: 伝播遅延耐性**
Given: 失効イベント遅延を人為注入。When: 失効直後に API 呼び出し。Then: キャッシュ期限超過または再照会で失効が検出され、遅延上限内で拒否される。

---

## 7. 制約と今後の課題

**制約 1: Redis/Event Bus 依存**
提案手法は Redis と Event Bus の可用性に依存する。これらの障害時はフォールバック（JWT のみの署名検証 + fail-closed）で対応するが、運用複雑性が増す。

**制約 2: マルチリージョン対応**
マルチリージョン展開では、失効伝播遅延と順序保証が課題となる。リージョン間の Event Bus レイテンシが失効の即時性 SLO に影響する。

**制約 3: 監査要件**
厳格な監査要件がある場合、失効操作の不可否認ログ設計が追加で必要。RDB への永続化と Event Bus の順序保証を組み合わせる必要がある。

**今後の課題:**
- WebSocket 等の長寿命接続に対する強制切断連携
- 失効伝播 SLO の自動検証
- 形式的検証（安全性プロパティ: "失効後 T 秒以内にアクセス不可" の証明）
