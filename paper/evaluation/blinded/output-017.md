# Output #017

1. **問題の背景と文脈**
- マルチテナントSaaSでは、APIサーバーをステートレスにして水平スケールしつつ、ユーザーのログイン状態（セッション）を安全に維持・失効できる必要があります。
- 要件は「同一ユーザーの複数端末同時ログイン」と「管理者による即時セッション無効化」を両立し、さらに「認証レイテンシ最小化（毎リクエストの追加I/Oを極力避ける）」が求められています。

2. **対立する要求やトレードオフ（2つ以上）**
- **低レイテンシ（ローカル検証） vs 即時失効（中央状態の参照）**
  JWT等の自己完結トークンは署名検証だけで速い一方、失効を"即時"に反映するにはどこかの状態参照（DB/Redis/インスペクション）や配信が必要になりがちです。
- **強い整合性（即時に全ノード反映） vs 可用性/運用容易性**
  "全リクエストで中央照会"は失効の整合性は強いですが、中央ストア障害が全認証に波及しやすく、レイテンシ・コストも上がります。
- **長寿命アクセストークン（UX良） vs 短寿命（安全・失効しやすい）**
  アクセストークンを長くすると再ログイン頻度は下がりますが、漏えい時の被害と失効反映の難易度が増します。
- **細粒度失効（特定端末だけ落とす） vs 実装/データ量**
  "ユーザー全体失効"は簡単ですが、端末単位失効はセッションID管理や配信・キャッシュが増えます。

3. **分析の対象範囲**
- 対象：セッション発行（ログイン）、リクエスト認証、リフレッシュ、ログアウト、管理者による（ユーザー単位/セッション単位）失効、監査ログ、水平スケール時の整合性。
- 非対象（必要なら別途設計）：認可（RBAC/ABAC詳細）、パスワード/SSOの方式選定、MFA、デバイス証明（DPoP等）の厳密設計、リージョン間DR。

4. **現状のアーキテクチャと制約（前提）**
- 前提アーキテクチャ例：LB配下に複数APIサーバー（ステートレス）、認証/セッション管理サービス、永続DB（例：PostgreSQL）、低遅延KVS（例：Redis Cluster）、イベント配信（例：Kafka/Redis Streams）。
- 制約：
  - **Sticky session不可**（水平スケール・障害時に不利）
  - **毎リクエストDB参照は避けたい**（レイテンシとコスト）
  - **テナント境界の厳密化**（tenant_idの混線防止、管理者権限のスコープ）

5. **既存の解決アプローチとその限界**
- **5.1 アプローチ1: サーバーサイドセッション（Opaque Token + Redis/DB）**
  - 手法：クライアントはランダムなセッショントークンを持ち、毎リクエストRedis/DBでセッション有効性を確認
  - 利点：失効が確実・即時、端末別制御が容易
  - 限界：毎リクエスト外部I/Oでレイテンシ増、Redis障害が直撃、QPS増でコスト増
- **5.2 アプローチ2: Sticky session（メモリ内セッション）**
  - 手法：LBで同一クライアントを同一サーバーに固定
  - 利点：認証は高速（メモリ）
  - 限界：水平スケール/フェイルオーバーに弱い、再配置でセッション消失、要件に不適
- **5.3 アプローチ3: 完全JWT（ステートレス）**
  - 手法：アクセストークンJWTを署名検証だけで認証（DB/Redis照会なし）
  - 利点：最小レイテンシ、水平スケール容易
  - 限界：管理者の"即時失効"ができない（期限まで有効になりがち）
- **5.4 アプローチ4: JWT + トークンインスペクション（中央照会）**
  - 手法：JWTでも毎回/一部リクエストで認証サービスに照会
  - 利点：失効は即時反映可能
  - 限界：レイテンシ増、認証サービスがボトルネック/単一障害点になりやすい
- **5.5 アプローチ5: JWT + ユーザー単位バージョン（session_version / revoked_after）**
  - 手法：ユーザーごとに失効用バージョン（整数）やrevoked_after（時刻）を持ち、トークンに埋め込み。管理者失効でバージョン更新
  - 利点：ユーザー全セッションの即時失効が比較的容易（差分が小さい）
  - 限界：端末単位失効は別仕組みが必要。毎リクエストでそのバージョンを"どこで"確認するか（ローカルキャッシュ/中央照会）が難所

6. **問題の本質的な困難**
- 「**分散環境で、全ノードが"今この瞬間の失効状態"を知っている**」ことと、「**毎リクエストは極力ローカル処理で終える**」ことが本質的に衝突します。
- つまり、即時失効には"共有状態 or 状態配信"が必要で、レイテンシ最小化は"共有状態参照を避けたい"ため、**失効情報の配布・キャッシュ・フォールバック設計**が核心です。

7. **解決策**
7.1 **基本原理**
- **ホットパス（通常リクエスト）をローカル検証中心に**：JWT署名検証 + メモリ参照で完結させる。
- **失効は小さな状態で表現**：ユーザー単位の`session_version`（全セッション失効）＋必要ならセッション単位の`revoked_session_id`（端末別失効）。
- **失効情報はイベントで即時配布**：各APIノードのローカルキャッシュをイベントで更新し、中央照会を通常時ゼロ/最小にする。
- **フォールバックを用意**：イベント取りこぼしや再起動時はRedis等の共有ストアから再同期。

7.2 **実装方針（具体）**
- トークン設計（例）
  - Access Token（JWT, 5〜15分）：`tid(tenant_id)`, `sub(user_id)`, `sid(session_id)`, `ver(session_version)`, `iat`, `exp`, `aud`, `iss`
  - Refresh Token（Opaque, 長寿命）：セッションごとに発行・ローテーション。サーバー側に**ハッシュ**で保存。
- データモデル（例）
  - `user_session_version:{tenant_id}:{user_id} -> int`（Redis）
  - `session_status:{tenant_id}:{session_id} -> active|revoked`（Redis, TTL=refresh期限）
  - 監査用にDBへ`sessions`テーブル（作成/失効/端末情報/最終利用）を非同期でも可
- リクエスト認証フロー（低レイテンシ重視）
  1) APIノードでJWT署名検証・`exp/aud/iss/tid`チェック（ローカル）
  2) ローカルキャッシュから`(tid,user_id)->session_version`取得し、`token.ver`と比較（ローカル）
  3) 端末単位失効が必要なら、ローカルキャッシュの`revoked_session_ids`に`sid`が無いことを確認（ローカル）
  4) キャッシュミス時のみRedisからversion/セッション状態を取得してキャッシュ（コールド時だけ外部I/O）
- 管理者による即時無効化（2段構え）
  - ユーザー全セッション無効化：`session_version`をインクリメントし、イベント`UserRevoked(tid,user_id,new_ver)`を発行
  - 特定セッション無効化：`session_status`を`revoked`にし、イベント`SessionRevoked(tid,session_id)`を発行
- 失効イベント配信（重要）
  - Redis Pub/Subは簡単ですが取りこぼしに弱いので、**KafkaまたはRedis Streams等の"再読込可能"な仕組み**が望ましいです（ノード再起動後に追いつける）。
  - 各APIノードはイベントを購読し、ローカルキャッシュを即時更新（通常リクエストは追加I/Oなし）。
- 水平スケール対応
  - APIノードはステートレス（ローカルキャッシュは再構築可能）
  - Redisはクラスタ、イベント基盤はパーティション/コンシューマグループでスケール
- "即座"の定義（SLA化推奨）
  - 例：失効操作から**99%が1秒以内**に全APIノードへ反映。これを満たすためにイベント配信・監視・再同期（catch-up）を設計に含めます。

8. **検証条件（Given/When/Then）**
- Given 同一ユーザーが端末A/端末Bでログインし、それぞれ`sidA/sidB`のAccess Tokenを保持している
  When 管理者がユーザー全体失効（`session_version`更新）を実行する
  Then A/Bいずれのトークンでも以後のAPI呼び出しが拒否され、再認証（refreshまたは再ログイン）が必要になる
- Given 同一ユーザーが端末A/端末Bでログイン中である
  When 管理者が端末Bのセッション`sidB`のみ失効する
  Then `sidB`のトークンは拒否され、`sidA`は継続して成功する
- Given APIノードを1台追加し、追加ノードはキャッシュが空である
  When 有効なトークンで最初のリクエストを追加ノードへ送る
  Then 追加ノードは必要最小限のRedis参照でキャッシュを温め、その後はローカル検証で認証できる
- Given 管理者が失効イベントを発行した
  When 任意のAPIノードが再起動してイベントの途中から再購読する
  Then 再起動後も失効状態に追随し、古いトークンを受け入れない
- Given 通常リクエスト（キャッシュヒット）
  When 連続して認証を行う
  Then 認証はJWT検証＋メモリ参照のみで完結し、外部I/Oを発生させない（レイテンシ目標内）

9. **制約、限界、今後の課題**
- "完全な瞬間失効（0遅延）"を厳密に保証するには、最終的に中央照会が必要になりやすく、レイテンシ最小化と両立が難しいため、**SLA（例：1秒以内）を定義**してイベント配信で満たすのが現実的です。
- イベント基盤の運用品質（遅延監視、再処理、順序性、重複排除）がシステム品質を左右します。
- マルチリージョン対応の場合、Redis/イベントのレプリケーション遅延や整合性方針（アクティブ/アクティブ等）が追加論点になります。
- セキュリティ強化（Refresh Tokenローテーション、漏えい検知、端末フィンガープリント、レート制限、監査ログ保全）を段階的に拡張する余地があります。
