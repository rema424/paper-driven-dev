# CS1 条件B3: Academic-paper — RAG 引用リナンバリング

> **実験条件**: Model: GPT-5.2 (via Codex) | Date: 2026-02 | Prompt language: Japanese
> **プロンプト**: 「以下の技術的な問題について、学術論文を書いてください。」

---

# ストリーミングRAG応答におけるオンライン引用リナンバリング：Prefix安定性に基づく設計と実装指針

## 要旨
RAG（Retrieval-Augmented Generation）システムでは、LLMが本文中に検索結果由来の参照識別子（例：`[source_7]`）を埋め込みつつ、構造化JSON（`{ body, citedSourceIds }`）をストリーミング返却することがある。ユーザー提示では、実際に使用された引用のみを `[1], [2], …` の連番へ変換して描画したい。しかしストリーミング中は全文が未確定であり、最終的な連番規則によっては先行テキストの番号が将来変化し得る。本稿は「リアルタイムかつ最終結果と矛盾しない引用番号表示」を成立させる必要条件を整理し、（i）追記型レンダリングでも番号が不変となるオンライン方式（初出順付番）と、（ii）任意順序を許す代替方式（プレースホルダ＋再描画、二段階生成、構造化トークン化）を比較し、実装上の状態機械・増分パーシング・整合性検査を提示する。

**キーワード**：RAG、LLM、ストリーミング、構造化出力、引用、オンラインアルゴリズム

---

## 1. 背景と問題設定
RAGでは、検索結果集合 S={source_k} を根拠としてLLMが回答本文を生成する。LLMは本文 `body` に `[source_3]` 等を埋め込み、同時に `citedSourceIds` として参照元ID配列を返すことがある。UI要件として、ユーザーには

- 本文中の参照を **使用されたものだけ** の連番 `[1],[2],...` に変換して提示
- 連番と根拠（検索結果）を対応付けて表示

が求められる。

ここでストリーミングでは、本文が逐次到着し、UIが表示済み部分を「後から書き換えられない（追記型）」設計も多い。この場合、ある時点で `[1]` と表示した引用が、後続テキストの出現により本来は `[2]` であるべきと判明するような規則は、**リアルタイムかつ正しい表示**と両立しない。

---

## 2. リアルタイム正当性の必要条件：Prefix安定性
ストリーミングを文字列の到着列として、時刻 t までに到着した本文プレフィックスを B_≤t とする。連番付番規則 N(·) が「最終全文 B に対する付番」と一致し続けるためには、少なくとも次が必要となる。

**定義（Prefix安定性）**：任意の t について、B_≤t 内に現れる引用の番号が、最終全文 B に対する番号と一致する。

追記型レンダリング（過去を書き換えない）では、Prefix安定性を満たさない規則は実装不可能である。典型的に安定なのは次のいずれかである。

1) **初出順（order of first appearance）**：引用が初めて本文に現れた順に `[1],[2],...` を割当
2) **事前に確定した写像**：`source_k -> i` が本文生成前に決まっている（例：検索結果順位を固定的に採用、ただし「未使用は除外」と矛盾しやすい）

一方、「最終的に使用された集合を集めてID昇順で付番」等は、後からより小さいIDが現れ得るためPrefix安定性を一般に満たさない。

---

## 3. 提案方式A：初出順に基づくオンライン・リナンバリング
### 3.1 基本アイデア
本文ストリームを受け取りながら、引用マーカー（例：`[source_7]`）の出現を検出し、**初出時に** `source_7 -> 1` のような写像を確定して、以後は同じ番号を再利用する。

- 状態：`map: sourceId -> displayIndex`、`nextIndex`
- ルール：引用 `sourceId` を初めて見たら `map[sourceId]=nextIndex; nextIndex++`
- 出力：本文中の `"[source_7]"` を `"[1]"` に置換してストリーミング描画
- 付随情報：`displayIndex` 順の `orderedSourceIds` を保持し、根拠一覧を増分更新

この方式では、番号は「その引用が初めて現れた瞬間」に確定し、その後のテキストによって既存番号が変わらないため、追記型表示でも最終結果と矛盾しない。

### 3.2 正当性（概略）
初出順付番は、各 `sourceId` の番号が「それ以前に初出した異なる引用の数+1」で定義される。ストリーミングは時間順に本文が到着するため、引用の初出タイミングは未来情報を要しない。したがってオンライン割当はオフライン（全文確定後）に同一規則で付番した結果と一致する。

---

## 4. ストリーミング実装の要点：増分検出と境界跨ぎ
### 4.1 引用マーカーがチャンク境界を跨ぐ問題
ストリーミングでは `"[sou"` と `"rce_7]"` が別チャンクで到着し得る。よって「チャンクごとの正規表現置換」だけでは漏れが生じる。

**対策**：本文出力の末尾に小さなバッファ（carry）を保持し、次チャンク先頭と連結して再走査する増分処理を行う。必要なのは「引用開始シーケンスに一致し得る最大長の未確定サフィックス」を保持することである（実務上は数十文字で十分）。

### 4.2 JSONストリーミングとの関係
入力が（a）生のJSON文字列断片か、（b）`body` フィールドの増分デルタとして届くかで難度が異なる。

- **推奨**：`body` の文字列デルタとしてイベント化し、そのデルタに対して上記の増分検出・置換を適用する（JSONのエスケープ処理と引用検出を分離）
- 生JSON断片しか得られない場合は、増分JSONパーサ（SAX的）で `body` の文字列値だけを抽出してから引用処理するのが安全

---

## 5. `citedSourceIds` との整合：信頼境界と再構成
LLMが返す `citedSourceIds` は、本文中の参照と不一致（未使用ID混入、重複、順序不整合）になり得る。ユーザー表示上は本文が一次情報であるため、次が堅牢である。

- **本文（置換前）から観測した引用集合**を正とし、`orderedSourceIds` を再構成
- LLMの `citedSourceIds` は監査用（差分検知・ログ）として扱う
- 不一致時は「本文にあるが配列にない」「配列にあるが本文にない」を記録し、必要ならサーバ側で補正

---

## 6. 代替方式（Prefix安定性が満たせない要件への対応）
要件が「初出順ではなく、別の最終規則（例：重要度順・検索順位順・ID昇順）で番号を固定したい」場合、追記型の"即時確定番号"は原理的に困難である。代表的代替は以下である。

1) **プレースホルダ＋再描画**
   ストリーミング中は `[source_7]` を一旦「未確定記号」（例：`[?]` や上付きマーク）として描画し、全文確定後にDOMノード参照で一括置換する。任意の規則に対応できるが、途中表示の番号は確定ではない。

2) **二段階生成（sources先出し）**
   LLMに「先に `citedSourceIds`（最終順序）を出力→その順序に従った `[1]` 参照で本文を生成」と制約する。計画的生成が成功すれば安定するが、LLMの計画誤りや、本文生成中に新規根拠が必要になった場合に破綻し得る。

3) **本文を文字列ではなく構造化セグメント列にする**
   `[{type:"text",...},{type:"cite",sourceId:"source_7"},...]` のように引用をイベント化すれば、検出・置換・再描画が単純化する（ただしプロトコル変更が必要）。

---

## 7. 評価指標と実験計画（提案方式A）
- **正確性**：オフライン初出順付番とオンライン表示の一致率（100%が目標）
- **遅延**：引用検出のためのバッファリングによる追加レイテンシ（ミリ秒〜十数ミリ秒程度を目標）
- **頑健性**：分割境界、壊れたマーカー、コードブロック内表記等の例外入力に対する誤置換率
- **運用性**：`citedSourceIds` との差分ログの発生頻度と原因分類

---

## 8. 結論
ストリーミング中に「リアルタイムかつ最終結果と矛盾しない連番引用」を実現するには、付番規則がPrefix安定性を満たす必要がある。追記型レンダリングを前提とする場合、**初出順付番**はオンラインで確定可能かつ最終結果と一致するため、実装負荷と正当性の両面で最適解となる。初出順以外の規則を採用する場合は、（i）プレースホルダ＋再描画、（ii）二段階生成、（iii）引用の構造化イベント化といった、過去出力の更新を許容する設計へ移行することが合理的である。
