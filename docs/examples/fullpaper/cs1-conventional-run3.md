# CS1 条件A: Conventional — RAG引用リナンバリング (Run 3)

> **Run**: CS1-A-Run3
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c79ba-173f-7051-9298-6b6a36a80279)
> **Model**: GPT-5.2 (via Codex)

---

推奨は **「引用イベント駆動 + 初出固定番号」** 方式です。

**設計方針**
1. LLMには本文中で `source_7` のような内部IDではなく、機械可読タグ（例: `[[CITE:source_7]]`）を出させます。
2. サーバー側のストリーム変換器でタグを検出し、`source_id -> 表示番号` を初出時にだけ採番します。
3. 採番は不変マップで保持します（例: `source_7 -> 1` を作ったら以後変更しない）。
4. クライアントへは変換済み本文（`[1]`）と、初出時の `citation_registered` イベントを即時送信します。
5. 完了時は同じマップから番号順にソース一覧を生成して返します。

**要件との対応**
- ストリーミング中にリアルタイム表示: タグ検出直後に `[n]` を出すので可能です。
- 一度表示した番号が変わらない: 初出採番＋不変マップで保証できます。
- 完了時に一覧と整合: 本文と一覧の両方を同じ採番マップから生成するため一致します。

**実装上の重要点**
1. 採番単位を先に決める（`chunk_id`単位か`document_id`単位か）。
2. 許可済み `source_id` のみ受け付ける（未知IDはエラー扱い）。
3. 再接続時のために採番状態を `response_id` 単位で保存し、再送時も同じ番号を使う。
4. 後段で本文を再整形する場合も、再採番せず同じイベントログをソース・オブ・トゥルースにする。

最小アルゴリズムは以下です。

```text
on cite(source_id):
  if source_id not in map:
    map[source_id] = next_number
    next_number += 1
    emit citation_registered(map[source_id], source_id)
  emit text("[{map[source_id]}]")
```

必要であれば、この設計をSSE/WebSocketの具体的イベント仕様まで落として提示できます。
