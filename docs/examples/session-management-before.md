# Before: 通常プロンプトによる出力（セッション管理）

> 以下は、論文形式を指定せず、通常のプロンプトで問題を LLM に聞いた場合の出力です。
> [After（論文形式）](session-management.md) と比較してください。

## プロンプト

```
以下の技術的な問題について、設計分析と解決策を提案してください。

問題: マルチテナント SaaS アプリケーションにおけるセッション管理方式の選定。

要件:
- ユーザーは複数デバイスから同時ログインする
- テナント管理者が特定ユーザーのセッションを即時無効化できる必要がある
- 水平スケーリングが可能であること
- レイテンシを最小限に抑えること
```

## 出力

**結論**
要件を満たす最適解は、`Redis中心の状態付きセッション管理`（各デバイスを独立セッション化）です。
実装は `短命Access Token + 回転Refresh Token + Redisセッション照会` のハイブリッドを推奨します。

**方式比較（要点）**

| 方式 | 即時無効化 | 水平スケール | 低レイテンシ | コメント |
| --- | --- | --- | --- | --- |
| 純JWT（完全ステートレス） | 弱い | 強い | 強い | 失効反映が遅れやすい |
| DBセッション（RDB直参照） | 強い | 中 | 弱い | 毎リクエストで重い |
| Redisセッション（推奨） | 強い | 強い | 強い | 失効・多端末・性能のバランスが最良 |

**推奨アーキテクチャ**

1. セッションモデル
   `1デバイス = 1セッション(sid)` とし、`tenant_id` を必須キーに含めます。
   Redis キー例:
   `sess:{tenantId}:{sid}`（状態）
   `user_sess:{tenantId}:{userId}`（そのユーザーの sid 集合）

2. トークン設計
   Access Token（JWT, 3〜5分）: `tid, uid, sid, exp` を含む。
   Refresh Token（長め）: 毎回ローテーションし、サーバ側で管理（漏洩耐性）。

3. リクエスト認証フロー
   JWT 署名検証（アプリ内）→ Redis で `sid` 状態確認（`active` のみ許可）→ 通過。
   API ノードはステートレスなので水平スケールしやすいです。

4. 即時無効化（管理者操作）
   対象 `sid` を `revoked` 化、またはユーザー配下の全 `sid` を一括失効。
   同時に Pub/Sub で `session.revoked` を配信し、各 API ノードの L1 キャッシュを即時破棄。
   WebSocket 利用時は該当接続も切断。

**要件への対応**

- 複数デバイス同時ログイン: `sid` を端末ごとに発行して実現
- 管理者の即時無効化: Redis 更新 + Pub/Sub で即時反映
- 水平スケーリング: アプリ層は完全ステートレス
- 低レイテンシ: Redis（同一リージョン）で 1ms 級、L1 キャッシュ併用でさらに削減
