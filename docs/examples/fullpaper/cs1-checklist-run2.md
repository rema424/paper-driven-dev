# CS1 条件D: Checklist — RAG引用リナンバリング (Run 2)

> **Run**: CS1-D-Run2
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c79af-bf2d-7810-a0c6-5c3035843e14)
> **Model**: GPT-5.2 (via Codex)

---

1. 問題の背景と文脈
RAG では、検索結果に内部ID（`source_3` など）を付けて LLM に渡し、回答中で参照させます。
一方 UI では、内部IDではなく人間が読みやすい `[1]`, `[2]` を表示したいです。
ただしストリーミング生成は「途中時点で最終文が未確定」なので、後から参照が増減しても番号を変えない設計が必要です。

2. 対立する要求やトレードオフ
- 即時性 vs 正確性: 途中表示を早く出すほど、最終整合性チェックの余地が減ります。
- 番号不変 vs 見た目の最適化: 一度出した番号を固定すると、最終的に欠番や未使用が出る可能性があります。
- モデル自由度 vs 実装堅牢性: モデルに自由記述させるほど誤った引用形式が増え、厳密フォーマットを課すほど生成自由度は下がります。

3. 分析の対象範囲
対象は「引用IDのストリーミング変換層」と「最終整合処理」です。
具体的には、LLM 出力の引用トークン検出、`source_id -> 表示番号` 割当、UI 更新、完了時の参照リスト確定までを含みます。
検索品質改善や回答内容の真偽判定は対象外です。

4. 現状のアーキテクチャと制約
一般的な構成は、`Retriever -> LLM(ストリーミング) -> UI` です。
制約は次の通りです。
- ストリーミングはチャンク境界が不定で、`source_7` が分割到着し得ます。
- 送信済み文字列の後方修正は基本できません（追記型）。
- 最終的な参照集合は生成完了まで確定しません。
- 同一ソース再引用時は同番号再利用が必要です。

5. 既存の解決アプローチとその限界
5.1 アプローチ1: 後処理で一括採番
手法: 完了後に全文を解析して `[1..N]` を振る。
利点: 実装が簡単、最終整合が取りやすい。
限界: ストリーミング中に番号を表示できず、要件未達です。

5.2 アプローチ2: 検索結果に事前採番
手法: 取得 `top-k` に先に `[1..k]` を固定し、生成中はその番号を使う。
利点: 番号不変を満たしやすく、処理が軽い。
限界: 実際に未引用ソースが多いと UX が悪化し、引用集合との乖離が出ます。

5.3 アプローチ3: LLM に `[n]` を直接生成させる
手法: プロンプトで番号ルールを指示。
利点: 後段実装が少ない。
限界: 番号重複・飛び・誤対応が起きやすく、整合保証が弱いです。

5.4 アプローチ4: 初出時オンライン採番（推奨）
手法: `source_id` の初出順で表示番号を割り当て、再出時は再利用。
利点: リアルタイム表示・番号不変・最終整合を同時に満たしやすい。
限界: 厳密な引用パーサと状態管理（中断復旧含む）が必要です。

6. 問題の本質的な困難
「未来が未確定なストリーム」に対して「過去に表示した番号は不変」という因果制約を同時に満たす点です。
つまり、オフライン最適化ではなく、オンラインで単調増加する状態機械として解く必要があります。

7. 解決策
7.1 基本原理
- 真のキーは表示番号ではなく `source_id`。
- 表示番号は `source_id` の初出時に一度だけ割当。
- 割当マップは append-only（更新は追加のみ、再番号付けなし）。
- 文章ストリームと引用イベントを分離して処理。

7.2 実装方針
- LLM には引用を `[[source_7]]` のような正規フォーマットで出させます。
- ストリーミングパーサ（チャンク跨ぎ対応）で引用トークンを検出します。
- `CitationRegistry` を持ちます。
  - `id2num: Map<source_id, n>`
  - `num2id: Array<source_id>`
  - `next = 1`
- 検出時処理: 未登録なら `n=next` を割当、登録済みなら既存 `n` を再利用し、UI には即 `[n]` を表示します。
- 完了時: `num2id` 順で参照一覧を確定し、`id` が検索結果集合に存在するか検証します（不正IDはエラー表示/除外をポリシーで固定）。

8. 検証条件（Given/When/Then）
- Given: 空の `CitationRegistry` と `source_3, source_7` が有効
  When: `[[source_7]] ... [[source_3]] ... [[source_7]]` が到着
  Then: 表示は `[1] ... [2] ... [1]`、最終一覧は `[1]=source_7, [2]=source_3`。

- Given: 引用トークンがチャンク分割される（`[[sou` + `rce_3]]`）
  When: ストリーム処理する
  Then: `[1]` が1回だけ表示され、重複採番されない。

- Given: `source_99` は検索結果に存在しない
  When: `[[source_99]]` が到着
  Then: 既定ポリシー通りに「無効引用」として扱われ、完了時一覧と整合した状態で明示される。

- Given: 途中で接続が切れて再接続する
  When: 復旧後に新規引用が来る
  Then: 既存番号は維持され、新規のみ次番号が採番される。

9. 制約、限界、今後の課題
- モデルが正規引用フォーマットを守る前提に依存します。
- 番号不変を優先するため、後からの見た目最適化（詰め直し）はできません。
- 引用整合は保証できても、引用先が回答主張を正しく裏付けるかは別問題です。
- 今後は、構造化出力（tool call）で引用を文字列から分離し、検証をより強制するのが有効です。
