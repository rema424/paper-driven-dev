# CS2 条件C: PDD Template — マルチテナントSaaSセッション管理 (Run 2)

> **Run**: CS2-C-Run2
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

# マルチテナントSaaSにおけるセッション管理システムの設計

## §1. 問題定義

### §1.1 背景

現代のSoftware-as-a-Service（SaaS）プラットフォームは、複数の企業テナントにサービスを提供しながら、各テナント内の多数のエンドユーザーのセッションライフサイクルを管理する必要がある。セッション管理はアプリケーションセキュリティの中核的なコンポーネントであり、認証・認可の基盤を形成する。

マルチテナント環境では、セッション管理の複雑性が単一テナント環境に比べて指数的に増大する。各テナントは独立したセキュリティポリシー、セッションタイムアウト設定、並行セッション数制限を持ちうる。さらに、クラウドネイティブアーキテクチャへの移行に伴い、アプリケーションサーバーはステートレス化が求められ、水平スケーリングが前提条件となっている。

近年のリモートワーク普及とモバイルデバイスの多様化により、単一ユーザーが複数の端末から同時にサービスにアクセスするシナリオが標準的なユースケースとなった。同時に、情報漏洩やアカウント侵害インシデントへの対応として、管理者がユーザーセッションをリアルタイムで制御する機能の重要性が高まっている。

### §1.2 矛盾する要求（対立するトレードオフ）

本システムは、本質的に相反する複数の要求を同時に満たすことを求められる。

**トレードオフ1: 低レイテンシ認証とリアルタイム無効化の両立**

リクエスト認証のレイテンシを最小化するためには、認証情報をアプリケーションサーバーのローカルキャッシュまたはクライアントサイドトークンに保持することが有効である。JWT（JSON Web Token）のような自己完結型トークンは、外部ストレージへのアクセスなしに検証できるため、サブミリ秒での認証が可能である。しかしこのアプローチは、トークンの有効期限が到来するまでサーバー側からセッションを強制終了できないという根本的な制約を持つ。管理者によるセッション即時無効化を実現するためには、すべての認証リクエストで集中型ストレージを参照する必要があり、これはレイテンシと可用性のボトルネックを生む。

**トレードオフ2: 水平スケーラビリティとセッション一貫性の両立**

水平スケーリングに対応するためには、サーバー間でセッション状態を共有する仕組みが必要である。集中型セッションストレージ（例: Redis クラスター）を用いると一貫性は確保できるが、そのストレージ自体がスケーリングのボトルネックとなり、単一障害点のリスクを抱える。一方、分散ストレージを採用すると、セッション無効化イベントの伝播に遅延が生じ、無効化の即時性要件と矛盾する。

**トレードオフ3: 複数端末同時ログインのサポートとセキュリティ制御の粒度**

複数端末からの同時ログインをサポートするためには、ユーザーに対して複数のアクティブセッションを許可する必要がある。しかし、管理者が「特定ユーザーのセッション」を無効化する際に、そのユーザーの全セッションを一括無効化するのか、特定端末のセッションのみを無効化するのかという粒度の問題が生じる。全一括無効化は実装が単純だが正当な業務端末も巻き込む可能性があり、粒度の細かい制御は管理インターフェースの複雑性を高める。

### §1.3 本文書の範囲

本文書は、上記のトレードオフを認識したうえで、マルチテナントSaaSにおけるセッション管理システムの設計指針と実装アーキテクチャを提示する。対象範囲は以下の通りである。

- 複数端末からの同時ログインセッションのライフサイクル管理
- 管理者によるセッション強制無効化メカニズム
- 水平スケーラブルなセッションストレージ設計
- リクエスト認証パスにおけるレイテンシ最適化

認証プロトコル（OAuth 2.0, SAML等）の詳細、テナント間のデータ隔離方式、および権限管理（RBAC/ABAC）の設計は本文書の範囲外とする。

---

## §2. 現状のアーキテクチャと制約

典型的なマルチテナントSaaSのセッション管理は、以下のコンポーネントで構成される。

**認証サーバー**: ユーザー資格情報を検証し、セッショントークンを発行する。多くの場合、単一または少数の専用サーバーとして運用される。

**アプリケーションサーバー群**: ビジネスロジックを処理するステートレスサーバー群。ロードバランサー経由でリクエストを受信する。水平スケーリングの対象となる。

**セッションストレージ**: 発行済みセッションのメタデータを保持するデータストア。代表的な実装はRedis（インメモリKVS）またはリレーショナルデータベースである。

**現状の主要な制約**:

- **単一テナント設計の流用**: 多くの既存システムはシングルテナント向けに設計されたセッション管理をマルチテナントに拡張した経緯を持つ。テナントIDをセッションキーのプレフィックスに付与するといった表面的な改修に留まり、テナント固有のポリシー適用が困難である。

- **スティッキーセッションへの依存**: セッション状態をアプリケーションサーバーのメモリに持つ実装では、特定のセッションが特定サーバーにルーティングされる「スティッキーセッション」に依存する。サーバー障害時にセッションが失われ、水平スケーリングの柔軟性を損なう。

- **無効化の遅延**: JWTを採用したシステムでは、トークンの有効期限（通常15〜60分）が到来するまでサーバー側からセッションを終了できない。緊急のセキュリティ対応として管理者が無効化操作を行っても、実際の効果は数十分後となる。

---

## §3. 既存アプローチとその限界

### §3.1 アプローチ1: サーバーサイドセッション（完全集中管理）

**手法**: セッションIDをクッキーに保存し、セッションの実体（ユーザー情報、権限、有効期限等）を集中型データストア（RDBMSまたはRedis）に格納する。各リクエスト時にセッションIDでストレージを参照し、セッションの有効性を確認する。

**利点**:
- セッションの即時無効化が容易（ストレージからレコードを削除するだけ）
- セッション状態のサーバー側制御が完全
- クライアントに機密情報を渡さない

**限界**:
- すべての認証リクエストがストレージへのI/Oを要求するため、高トラフィック時のレイテンシが増大する
- 集中型ストレージが単一障害点かつスケーリングのボトルネックになる
- ストレージの冗長化・クラスタリングにより運用複雑性が増大する

### §3.2 アプローチ2: JWT（JSON Web Token）による自己完結型トークン

**手法**: ユーザー情報・有効期限・テナントIDを含むペイロードをサーバー秘密鍵で署名したJWTを発行する。アプリケーションサーバーは署名検証と有効期限確認のみでトークンの正当性を判断でき、外部ストレージへのアクセスを必要としない。

**利点**:
- 外部I/O不要のため認証レイテンシが最小化される（マイクロ秒オーダー）
- ステートレス設計により水平スケーリングが容易
- マイクロサービス間での認証情報伝播が単純

**限界**:
- トークン有効期限到来前の即時無効化が不可能（根本的な設計上の制約）
- 漏洩したトークンを失効させる手段がない
- トークン失効リスト（Blacklist）を導入すると結局外部ストレージへのアクセスが必要になり、利点が失われる

### §3.3 アプローチ3: リフレッシュトークン + 短命アクセストークン

**手法**: 長期間有効なリフレッシュトークンと短命（例: 5〜15分）のアクセストークンを組み合わせる。アクセストークンはJWT形式で自己完結型とし、リフレッシュトークンはサーバーサイドで管理する。セッション無効化時はリフレッシュトークンを失効させることで、次回リフレッシュ時以降の認証を拒否する。

**利点**:
- 無効化の実効時間をアクセストークンの有効期限（数分）に限定できる
- 通常のリクエスト認証はアクセストークンのみで完結する
- リフレッシュトークンの管理により長期セッションの制御が可能

**限界**:
- 無効化してから実際に効果が出るまでの遅延（アクセストークンの残存有効期間）が依然として存在する
- リフレッシュトークンストレージは集中管理が必要で、スケーリング課題が残る
- クライアント実装の複雑性が増す（トークン更新ロジックの実装）
- アクセストークンの有効期限を短くするほどリフレッシュ頻度が増し、サーバー負荷が上昇する

### §3.4 アプローチ4: イベント駆動型セッション無効化（Pub/Sub）

**手法**: セッション管理サービスが無効化イベントをPub/Subメッセージブローカー（例: Redis Pub/Sub, Apache Kafka）に発行する。各アプリケーションサーバーはチャネルを購読し、無効化イベントを受信すると自身のローカルキャッシュからセッションを削除する。

**利点**:
- 無効化の伝播が準リアルタイム（ミリ秒〜秒オーダー）
- アプリケーションサーバーのローカルキャッシュ活用によりホットパスのレイテンシを低減できる

**限界**:
- メッセージブローカーの可用性がシステム全体に影響する
- サーバーが無効化イベントを受信できなかった場合（ネットワーク分断等）、一貫性が損なわれる
- At-most-once配信では無効化の保証ができない。At-least-once配信では冪等性の実装が必要

---

## §4. 問題の本質

上述のトレードオフを分析すると、本問題の本質は**「強い一貫性（Consistency）と可用性・性能（Availability/Performance）のトレードオフを、セキュリティ要件が支配する文脈で解決する」**という点に集約される。

CAP定理の観点では、分散セッションストレージは「ネットワーク分断耐性（P）は必須」という前提のもと、一貫性（C）と可用性（A）のどちらを優先するかという選択を迫られる。しかし実際には、セッション管理はオール・オア・ナッシングの二者択一ではなく、**操作の種類によってトレードオフの許容範囲が異なる**という点が重要である。

- **セッション無効化**: 強い一貫性が要求される（漏洩したセッションを確実に無効化する必要がある）
- **セッション検証（通常のリクエスト認証）**: 最終的一貫性で許容できる（わずかな遅延で無効化が伝播すれば実用的）

この非対称性を活用することで、「無効化の即時性」と「検証の低レイテンシ」を同時に実現するアーキテクチャが設計可能となる。

さらにマルチテナント文脈では、以下の構造的な複雑性が加わる。

- テナントごとにセッションポリシー（最大同時セッション数、タイムアウト値）が異なる
- テナントの規模差が大きく、一部の大規模テナントが全体のストレージ容量を支配しうる
- テナント分離の原則から、あるテナントのセッション管理の障害が他テナントに波及してはならない

---

## §5. 提案手法

### §5.1 基本原理

提案するアーキテクチャは、以下の3つの基本原理に基づく。

**原理1: 操作セマンティクスによる一貫性モデルの分離**

セッション検証（高頻度・レイテンシ重視）とセッション無効化（低頻度・一貫性重視）を異なる一貫性モデルで処理する。検証はローカルキャッシュを活用した楽観的な処理を行い、無効化は強一貫性を保証するストレージを経由する。

**原理2: 短命トークン + 無効化バージョンカウンターの組み合わせ**

JWTのメリット（ステートレス検証）とサーバーサイドセッションのメリット（即時無効化）を組み合わせる。ユーザーごと・テナントごとに「セッションバージョン（generation）」カウンターを管理し、JWTにそのバージョン番号を埋め込む。無効化時はバージョンカウンターをインクリメントするだけでよく、古いバージョンのJWTは自動的に無効となる。

**原理3: テナント分離された論理パーティション**

セッションストレージをテナントIDで論理パーティション化する。これによりテナント固有のポリシー適用、障害隔離、および容量管理が可能となる。

### §5.2 実装アーキテクチャ

**コンポーネント構成**

```
クライアント（各端末）
    ↓ HTTPS
ロードバランサー（L7）
    ↓
アプリケーションサーバー群（ステートレス、水平スケール可能）
    ├── ローカルセッションキャッシュ（プロセス内、TTL=30秒）
    ↓
セッション検証レイヤー
    ├── Redis Cluster（プライマリ）    ← セッションバージョン管理
    └── Redis Replica（リードレプリカ）← セッション検証の読み取りスケール
    ↓
管理API
    └── 管理者によるセッション無効化エンドポイント
```

**セッションデータモデル**

各ユーザーに対して以下のエントリをRedisに保持する。

```
Key: session:v1:{tenant_id}:{user_id}:meta
Value: {
  generation: <integer>,       // セッションバージョンカウンター
  active_sessions: [           // アクティブセッションの一覧
    {
      session_id: <uuid>,      // 個別セッション識別子
      device_info: <string>,   // 端末識別情報
      created_at: <timestamp>,
      last_active: <timestamp>
    },
    ...
  ],
  policy: {                    // テナント固有ポリシー
    max_concurrent_sessions: <int>,
    session_timeout_minutes: <int>
  }
}
TTL: テナントポリシーに依存
```

JWTペイロードに含める追加クレーム:

```
{
  "sub": "<user_id>",
  "tid": "<tenant_id>",        // tenant_id
  "sid": "<session_id>",       // 個別セッション識別子
  "gen": <generation>,         // セッションバージョン
  "iat": <issued_at>,
  "exp": <expires_at>          // アクセストークン有効期限（5分）
}
```

**セッション検証フロー**

1. クライアントからリクエスト受信（JWTアクセストークン付き）
2. アプリケーションサーバーがJWT署名検証・有効期限確認（ローカル処理、外部I/O不要）
3. ローカルキャッシュに `{tenant_id}:{user_id}` のバージョン情報が存在するか確認
   - キャッシュヒット: キャッシュのgenerationとJWTのgenクレームを比較
   - キャッシュミス: RedisからRedis Replicaを参照してgenerationを取得、ローカルキャッシュに保存（TTL=30秒）
4. `JWT.gen == Redis.generation` であれば認証成功。異なれば401を返す

このフローにより、通常のリクエスト（キャッシュヒット時）の認証レイテンシはJWT検証のみの時間（< 1ms）となる。キャッシュミス時もRedis読み取り（通常 < 5ms）で完結する。

**セッション無効化フロー**

管理者が「ユーザーXの全セッションを無効化」を実行する場合:

1. 管理APIが `session:v1:{tenant_id}:{user_id}:meta` のgenerationをアトミックにインクリメント（Redisの `HINCRBY` コマンド）
2. 応答を管理者に返す（操作完了）
3. アプリケーションサーバー群の各ローカルキャッシュは、次回該当ユーザーのリクエストを受けた際にRedisを参照し、generationの不一致を検出して認証を拒否する

無効化の最大遅延は、ローカルキャッシュのTTL（30秒）となる。これは「即座」の定義をどの程度に置くかによって許容範囲が変わるが、セキュリティインシデント対応の文脈では30秒以内を「実質的に即時」と捉えることができる。より厳密な要件がある場合は、TTLをテナントポリシーで設定可能とする（例: 5〜60秒）。

**特定セッション（特定端末）の無効化**:

1. 無効化対象の `session_id` をgenerationとともに無効化リストに追加
   - Key: `session:v1:{tenant_id}:{user_id}:revoked`
   - Value: Set of `{session_id}:{generation}` （TTL=アクセストークン最大有効期限）
2. JWTの `sid` クレームと無効化リストを照合する検証ステップを追加

**テナント分離**:

- すべてのRedisキーにテナントIDをプレフィックスとして含める
- テナントごとにRedisのメモリ割り当て上限を設定（大規模テナントによる枯渇防止）
- テナント固有のポリシー（最大同時セッション数、タイムアウト）はメタデータに保持し、セッション作成・更新時に適用する

**複数端末サポート**:

ユーザーの `active_sessions` リストに各端末のセッションを記録する。新規セッション作成時に最大同時セッション数（テナントポリシー）を確認し、超過する場合は最古のセッションを自動失効させる（LRU方式）かエラーを返す（ポリシー依存）。

---

## §6. 検証可能な性質

提案手法の正確性と実用性は、以下のGiven/When/Then形式のシナリオによって検証できる。

**P1: セッション無効化の実効性**

- Given: テナントT1のユーザーU1がアクセストークン（gen=5）を保持している
- When: 管理者がU1の全セッションを無効化する（generationが6にインクリメントされる）
- Then: U1のアクセストークンを用いた次のリクエストは、ローカルキャッシュのTTL（最大30秒）経過後に401 Unauthorizedを返す

**P2: 複数端末ログインの独立性**

- Given: ユーザーU1がデバイスD1（session_id=S1）とデバイスD2（session_id=S2）でログインしている
- When: 管理者がS1（D1のセッション）のみを無効化する
- Then: D2からのリクエスト（session_id=S2）は引き続き認証に成功し、D1からのリクエスト（session_id=S1）は無効化後のTTL経過以降で拒否される

**P3: 水平スケーラビリティ**

- Given: アプリケーションサーバーが3台稼働している
- When: 4台目のサーバーが追加される
- Then: 既存のすべてのアクティブセッションは引き続き有効であり、新サーバーはセッション状態を引き継ぐための特別な初期化を必要としない

**P4: 低レイテンシ認証（キャッシュヒット時）**

- Given: アプリケーションサーバーのローカルキャッシュにユーザーU1のgenerationが存在する（TTL内）
- When: U1からリクエストが到着する
- Then: Redis等の外部ストレージへのアクセスなしに認証処理が完了する（認証レイテンシ < 2ms）

**P5: テナント分離**

- Given: テナントT1のRedisメモリ割り当てが上限に達している
- When: テナントT1のユーザーが新規セッションを作成しようとする
- Then: テナントT2のユーザーのセッション操作には影響を与えず、T1のみがエラー（セッション作成失敗）を受け取る

**P6: 認証一貫性（ゴースト認証の防止）**

- Given: ユーザーU1のセッションが無効化された（generation=6）
- When: generation=5のアクセストークンが複数のアプリケーションサーバーに並行してリクエストを送信する
- Then: いずれのサーバーも、ローカルキャッシュのTTL経過後は一貫してリクエストを拒否する（最終的一貫性の保証）

---

## §7. 制約と今後の課題

**制約1: 無効化の最大遅延**

本設計における無効化の最大遅延はローカルキャッシュのTTLに依存する。デフォルト値30秒は、通常のアカウント管理（退職者のアクセス無効化等）においては実用的である。しかし、アカウント侵害が確認されたような緊急セキュリティインシデントでは30秒の遅延が許容されない場面もありうる。この場合、TTLを短縮するかPub/Sub型の即時通知メカニズムを補完的に導入する必要がある。後者はシステム複雑性を増大させるという別のトレードオフを生む。

**制約2: ローカルキャッシュの整合性**

アプリケーションサーバーのプロセスクラッシュや再起動時にローカルキャッシュが消失する。この場合は次回リクエスト時にRedisを参照するため、機能上の問題はないが、キャッシュウォームアップ期間中はRedisへのアクセス頻度が増加する。大規模なローリングデプロイ時には一時的なRedis負荷スパイクが発生しうる。

**制約3: generationカウンターのオーバーフロー**

generationカウンターは整数であり、理論上はオーバーフローが発生しうる。実用上、64ビット整数であれば実質的に問題とならないが、カウンターのリセット時に旧バージョンのトークンとの衝突を防ぐ機構（リセット時刻のタイムスタンプをgenerationの一部として組み込む等）を考慮する必要がある。

**制約4: テナントポリシーの動的変更**

テナントのセッションポリシー（最大同時セッション数、タイムアウト値）が変更された場合、既存の進行中セッションに対する適用タイミングが定義される必要がある。即時適用は管理者の予期しないユーザーへの影響を引き起こす可能性があり、次回セッション更新時の適用では変更の遅延が生じる。

**今後の課題**

- **適応型TTL**: ユーザーのアクセスパターン（リクエスト頻度、セキュリティリスクスコア）に基づいてローカルキャッシュのTTLを動的に調整する機構の研究
- **ゼロダウンタイムのgenerationリセット**: マルチテナント環境での安全なgenerationカウンターリセット手順の形式化
- **地理分散デプロイへの対応**: マルチリージョン展開においてRedis Clusterのgeo-replicationと本提案手法のgenerationモデルを組み合わせた場合の一貫性保証の分析
- **監査ログの統合**: セッション作成・無効化・検証失敗の各イベントを不変な監査ログとして記録するアーキテクチャとの統合設計（コンプライアンス要件対応）
- **量子コンピューティング耐性**: JWT署名アルゴリズムの耐量子暗号化への移行計画とgenerationモデルへの影響評価
