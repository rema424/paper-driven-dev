# Calibration #003

## 結論（推奨方式）
**「短命 JWT アクセストークン + 共有セッション状態（Redis 等）による失効判定」のハイブリッド**が、要件（同時ログイン／即時無効化／水平スケール／低レイテンシ）を最もバランス良く満たします。

---

## 方式比較（要点）
- **JWT（完全ステートレス）**
  - 長所: 各APIで署名検証のみ＝低レイテンシ、水平スケール容易
  - 短所: **即時無効化が困難**（失効リスト参照や極短TTLが必要→結局ストア参照が増える）
- **不透明トークン（セッションID）+ セッションストア参照（毎リクエスト）**
  - 長所: 即時無効化が簡単（ストアで無効化/削除）
  - 短所: 毎回ストア参照＝レイテンシ・依存点が増える
- **ハイブリッド（推奨）**
  - JWTでローカル検証しつつ、**「失効に必要な最小状態」だけ共有ストアで判定**し、キャッシュ/通知で高速化

---

## 推奨アーキテクチャ（要件への当てはめ）
### 1) トークン設計（複数デバイス同時ログイン）
- デバイス（またはブラウザ）ごとに **session_id** を発行し、同一ユーザーでも複数セッションを保持
- クライアントには
  - **Access JWT（短命: 5〜15分）**：`tenant_id, user_id, session_id, iat, exp` 等
  - **Refresh token（長命: 数日〜、ローテーション）**：サーバ側でハッシュ保存（漏えい耐性）

### 2) 即時無効化（テナント管理者要件）
「特定ユーザーのセッションを即時無効化」は、実装上2種類あるため両対応を推奨します。
- **ユーザー全セッション無効化（強い要件）**
  - 共有ストアに `user_revoked_at` もしくは `user_session_epoch(version)` を保持
  - JWTの `iat`（または埋め込みversion）と比較し、古ければ拒否
  - admin操作は **1キー更新**で済む（Nセッション削除が不要）
- **特定セッションのみ無効化（運用上便利）**
  - `session_id` を `revoked=true` にする／削除する

### 3) 水平スケーリング
- APIサーバは **完全ステートレス**（JWT検証 + 共有ストア参照のみ）
- セッション状態は **Redis Cluster 等**に集約（キーは `tenant_id` で名前空間分離）

### 4) レイテンシ最小化（重要）
「即時無効化」=「毎回どこかで状態を見る」になりがちなので、以下で最小化します。
- リクエスト処理はまず **JWT署名検証（ローカル）**
- 次に失効判定は **(a) ローカルキャッシュ → (b) Redis** の順
  - キャッシュTTLは短め（例: 5〜30秒）でも効果が大きい
- adminが失効操作したら **pub/sub（またはイベントバス）でキャッシュを即時削除**
  - `tenant_id:user_id` / `tenant_id:session_id` をキーに全APIノードへ配信
  - これで「キャッシュしても即時無効化」を両立

---

## 代表的フロー
- **ログイン**: session作成（Redis + 必要ならDBに監査記録）→ Access JWT/Refresh発行
- **APIアクセス**: JWT検証 →（キャッシュ/Redisで）`session有効` かつ `user_revoked_at/epoch整合` を確認
- **管理者が失効**:
  - 全セッション失効: `user_revoked_at` 更新（またはepoch++）→ 失効イベント配信
  - 単一セッション失効: `session_id` をrevoke→ イベント配信

---

## 運用・設計上の注意（最低限）
- **マルチテナント分離**: `tenant_id` をトークン・セッションキー・認可判定の全てに含める
- **Refresh tokenは必ずローテーション**（再利用検知でセキュリティ強化）
- **障害時の挙動**: Redis不可時は原則 **fail-closed（拒否）**が安全（要件により一部例外設計は可）
- **監査/可視化**: 「どのデバイスのセッションが生きているか」をDBに非同期保存すると管理UIが作りやすい

この方針で、同時ログインを許容しつつ、管理者による"即時"失効と水平スケール、低レイテンシを現実的に両立できます。必要なら「即時」の許容遅延（完全リアルタイムか、数秒以内でよいか）に合わせてキャッシュTTLと通知方式を詰めるのが次の設計ポイントです。
