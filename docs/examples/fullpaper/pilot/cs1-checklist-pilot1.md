# CS1 条件D (Pilot): Structured Checklist — RAG 引用リナンバリング

> **Run**: CS1-D-Pilot1
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP)
> **Model**: GPT-5.2 (via Codex)
> **Purpose**: D条件プロンプトの妥当性確認（本解析には含めない）

---

**1. 問題の背景と文脈**
RAGでは、取得済みソース（`source_3`, `source_7` など）を根拠にLLMが回答します。
一方、UXとしては内部IDではなく `[1] [2] [3]` の連番表示が望まれます。
ただしストリーミングでは「将来どの引用が出るか」が未確定なので、表示の即時性・不変性・最終整合性を同時に満たす設計が必要です。

**2. 対立する要求やトレードオフ**
1. 即時表示 vs 最終最適化
ストリーミング中に番号を確定すると、全文確定後の"最適な並び"にはできません。
2. 番号不変 vs 自己修正容易性
一度出した番号を変えない要件は、後続でモデルが引用を言い換えた際の修正自由度を下げます。
3. 厳密整合性チェック vs 低遅延
都度検証を強めるほど、表示遅延が増えます。
4. 自由文生成 vs 機械可読性
自然文中の曖昧な引用表記は読みやすい反面、ストリーム中の安全なパースが難しくなります。

**3. 分析の対象範囲**
対象: 引用番号の割当アルゴリズム、ストリーム中のパーサ、UI表示、完了時整合性検証。
対象外: 検索品質改善、要約品質、引用自体の真偽判定（事実性保証）。

**4. 現状のアーキテクチャと制約**
前提として一般的な構成を想定します。
`Retriever -> Prompt Composer -> LLM (stream) -> Stream Processor -> UI`。
制約は以下です。
- チャンク境界が任意なので、引用トークンが分断される。
- UIは通常、過去トークンの大規模書き換えが苦手。
- 「一度表示した番号を変えない」ため後方再番号付け不可。
- 最終的に番号とソース一覧を1対1で一致させる必要がある。

**5. 既存の解決アプローチとその限界**
5.1 アプローチ1: 後処理で一括再番号付け
手法: 完了後に全文を解析して `[1..N]` を付与。
利点: 実装が単純、全体最適しやすい。
限界: ストリーミング中のリアルタイム表示要件を満たせない。

5.2 アプローチ2: 検索順位をそのまま番号化
手法: `source_1=>[1]` のように事前固定。
利点: 番号不変、実装容易。
限界: 実際に未使用のソースが混じりやすく、最終表示の可読性が低い。

5.3 アプローチ3: LLMに `[1]` を直接出させる
手法: モデル任せで番号を生成。
利点: 変換層が薄い。
限界: 重複・欠番・誤対応が起きやすく、整合性保証が難しい。

5.4 アプローチ4: プレースホルダを後で置換
手法: 一時記号を表示し完了時に差し替え。
利点: 途中表示は可能。
限界: 差し替えで既表示番号が変わる可能性があり要件違反。

**6. 問題の本質的な困難**
「未来が未確定なオンライン生成」に対して、「過去表示の不変」と「最終整合」を同時に課している点です。
つまり、不可逆な意思決定（番号割当）を逐次で正しく行う必要があります。

**7. 解決策**
**7.1 基本原理**
- 内部参照ID（`source_7`）と表示番号（`[2]`）を分離する。
- 初出時にのみ番号を単調増加で割り当て、以後不変にする。
- 番号の真実源を `CitationRegistry`（回答単位）1つに集約する。

**7.2 実装方針**
1. LLM出力の引用形式を機械可読に固定（例: `[[source_7]]`）。
2. ストリーム処理で引用タグをインクリメンタルにパース（分断チャンク対応バッファ付き）。
3. `source_id -> display_no` マップを保持し、未登録なら `next_no` を採番。
4. UIには即時に `[display_no]` を流す。既存番号は再計算しない。
5. 完了時に `display_no` 順でソース一覧を確定し、本文と突合する。
6. 不正ID（未検索ソース）は `invalid` 扱いで監査ログに残す（表示は `[?]` など方針選択）。

**8. 検証条件（Given/When/Then）**
1. Given `[[source_7]] ... [[source_3]] ... [[source_7]]`
When ストリーム処理する
Then 本文表示は `[1] ... [2] ... [1]`、一覧は `1=source_7, 2=source_3`。

2. Given `[[sou` と `rce_7]]` が別チャンクで到着
When インクリメンタルパースする
Then 1つの引用として解釈され、重複採番しない。

3. Given 途中で新規 `[[source_9]]` が初出
When 既に `[1][2]` を表示済み
Then `[3]` を追加し、既存 `[1][2]` は不変。

4. Given `[[source_999]]` が許可集合外
When 検証する
Then ユーザー表示は定義済みフォールバック、最終一覧には通常ソースとして載せない。

5. Given ストリームが異常終了
When 最終化処理を実行
Then その時点までの番号と一覧は整合し、未閉鎖タグは破棄またはエラー表示する。

**9. 制約・限界・今後の課題**
- 早い段階で誤引用されても、番号不変要件上は差し替えづらい。
- 構文固定（`[[source_x]]`）へのモデル追従率が低いと、回復ロジックが必要。
- 本設計は「参照整合」を保証するが、「引用の妥当性（内容一致）」は別問題。
- 今後は、関数呼び出し型の引用出力、チャンク分断ファジング試験、監査メトリクス（不正ID率・再現率）の整備が有効です。
