# CS2 条件D: Structured Checklist — マルチテナントSaaSセッション管理 (Run 3)

> **Run**: CS2-D-Run3
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

## 1. 問題の背景と文脈

マルチテナントSaaSにおけるセッション管理は、単一テナント向けシステムとは根本的に異なる複雑性を持つ。複数の企業・組織（テナント）が同一のインフラを共有しながら、それぞれのユーザー認証・認可状態を独立して管理する必要がある。

現代のSaaSプロダクトは以下の運用上の現実に直面している。ユーザーはデスクトップ、モバイル、タブレット等の複数端末を日常的に使用する。セキュリティインシデントや人事異動が発生した際に管理者はリアルタイムでアクセスを遮断する必要がある。サービスの成長に伴ってサーバーを動的に増減させるオートスケーリングが前提となる。そして認証処理のレイテンシはユーザーエクスペリエンスに直結するため最小化が求められる。

これらの要件が単純に共存できないのは、それぞれが互いに相反する方向の設計圧力をかけるからである。本問題はその相反を意識的に解決する設計を求めている。

## 2. 対立する要求やトレードオフ

### トレードオフ1: 認証レイテンシとセッション即時無効化の矛盾

JWT（JSON Web Token）のようなステートレストークンは、検証時にDBアクセスを必要とせずインメモリ処理で完結するため低レイテンシを実現する。しかし有効期限（exp）が埋め込まれているため、無効化するにはトークンが自然に失効するまで待つか、ブラックリストをどこかに保持する必要がある。ブラックリストの参照はDB/Cacheアクセスを意味し、レイテンシが増加する。

逆に、セッション情報を中央のデータストアで管理するステートフルなアプローチは、無効化が即座に反映される一方、全リクエストがDB参照を必要とする。これはレイテンシを増大させるだけでなく、データストアがSPOF（単一障害点）になるリスクを持つ。

### トレードオフ2: 水平スケーラビリティとセッション一貫性の矛盾

ステートフルなセッション管理をAPPサーバー上で行うと、スティッキーセッション（同一ユーザーのリクエストを同一サーバーに振り向ける）が必要となり、水平スケーリングの柔軟性が大幅に低下する。スティッキーセッションなしで各サーバーがローカルにセッションをキャッシュすると、管理者による無効化操作が全サーバーに即座に伝播しない問題が生じる。

Redis等の分散キャッシュを使えばこの矛盾は緩和されるが、今度はキャッシュクラスター自体の可用性・一貫性設計が問題になる。

### トレードオフ3: マルチテナント分離とリソース効率の矛盾

テナントごとにセッションストアを分離（専用Redisインスタンス等）すると、テナント間の影響が遮断されセキュリティ境界が明確になる。しかし小規模テナントが多い場合、リソースの大半がアイドル状態となり非効率である。逆に共有ストアを使うと効率的だが、バグや設定ミスによるテナント間データリーク（クロステナント汚染）のリスクが高まる。

## 3. 分析の対象範囲

本分析は以下の範囲を対象とする。

- セッション発行（ログイン時のトークン生成・保存）
- セッション検証（各APIリクエストにおける認証処理）
- セッション無効化（管理者操作・ユーザー自身によるログアウト）
- マルチデバイス対応（同一ユーザーの複数アクティブセッション管理）
- 水平スケーリング下での一貫性保証

対象外とするのは、初期認証（パスワード検証、OAuth、SAML連携）の詳細実装、認可（Authorization）ポリシーの管理、テナントプロビジョニングのライフサイクルである。

## 4. 現状のアーキテクチャと制約

典型的なマルチテナントSaaSが直面する既存の制約を以下に整理する。

**インフラ制約**
- APPサーバーは複数台（2〜N台）で構成され、ロードバランサー経由でリクエストを受け付ける
- データストアはRDBMS（PostgreSQL等）がテナントデータを保持する
- キャッシュレイヤー（Redis等）は存在するが、セッション管理専用の設計はされていない場合がある

**運用制約**
- テナントごとにユーザー数・アクセスパターンが大きく異なる（数十人〜数万人規模の差異）
- SLAとしてAPIレスポンスp99が200ms以内を要求されることが多い
- セキュリティポリシーとして、管理者の無効化操作は5秒以内に全サーバーへ反映されることが期待される

**開発制約**
- 既存のセッション管理ロジック（単純なJWTベース）を段階的に移行する必要がある場合が多い
- 運用チームの規模が限られているため、複雑すぎる構成は保守コストを高める

## 5. 既存の解決アプローチとその限界

### 5.1 アプローチ1: 純粋なJWT（ステートレス）

**手法**: ログイン時にJWT（アクセストークン）を発行し、サーバー側でセッション状態を保持しない。JWTの署名検証のみで認証を完結させる。

**利点**: DBアクセスが不要なため認証レイテンシが極めて低い。APPサーバーに状態がないため、水平スケーリングが容易である。

**限界**: セッションの即時無効化が本質的に不可能である。トークンを失った（紛失・漏洩）場合でも、有効期限まで使用可能な状態が続く。マルチデバイス管理のために発行したトークンの一覧を管理する仕組みが別途必要になる。有効期限を短くすれば無効化の問題は緩和されるが、リフレッシュトークンの管理が複雑になる。

### 5.2 アプローチ2: サーバーサイドセッション（DB直接参照）

**手法**: セッションIDをDBに保存し、全リクエストでセッションテーブルを参照して有効性を検証する。

**利点**: セッションの即時無効化が可能である。セッション情報（最終アクセス時刻、デバイス情報等）を柔軟に管理できる。マルチデバイス対応が自然に実現できる。

**限界**: 全リクエストがDBクエリを必要とするため、高トラフィック時にDBがボトルネックになる。DBが単一障害点となるリスクがある。水平スケーリング時もDBへのアクセスは増加し続ける。

### 5.3 アプローチ3: Redisを用いたセッションキャッシュ

**手法**: セッション情報をRedisに保存し、JWTではなくランダムなセッションIDをクライアントに渡す。Redis参照で認証を完結させる。

**利点**: DBより大幅に低レイテンシ（マイクロ秒オーダー）でセッション参照が可能。セッション無効化はRedisからのDELETEで即座に反映される。水平スケーリング時も共有Redisを参照するため一貫性が保たれる。

**限界**: Redisクラスターの可用性がセッション管理の可用性に直結する（RedisがSPOFになり得る）。Redis自体の水平スケーリングとデータ分散の設計が必要。全リクエストがネットワーク越しのRedis参照を必要とするため、純粋なJWTより高レイテンシ。テナント分離のための設計（キーのプレフィックス管理等）を慎重に行わないとクロステナント問題が発生する。

### 5.4 アプローチ4: ショートライフJWT + トークンブラックリスト

**手法**: JWTの有効期限を短く設定（例: 15分）し、無効化時のみブラックリストにトークンIDを登録する。通常リクエストではブラックリストを参照せず、問題が発生した場合のみ参照する。

**利点**: 通常時は低レイテンシを維持できる。完全なリアルタイム無効化は困難だが、無効化後の最大継続使用時間を制御できる（有効期限=15分なら最大15分後には確実に無効化される）。

**限界**: 「即座の無効化」という要件を厳密には満たさない。ブラックリストが増大するため、定期的なクリーンアップが必要。緊急のセキュリティインシデント時に最大15分間の露出窓が生じることが許容できないケースがある。

## 6. 問題の本質的な困難

本問題の本質的な困難は、**CAP定理的なトレードオフが認証レイテンシと無効化即時性の間に存在する**ことである。

セッションの「有効状態」はネットワークを介した分散状態である。APPサーバーA、B、Cが存在するとき、管理者がAPPサーバーAを通じてセッションSを無効化する操作を行っても、次の瞬間にAPPサーバーBに到達したリクエストがセッションSを有効と判断する可能性がある。この問題を解決するには、全サーバーが無効化の事実を知る必要がある。

全サーバーへの伝播には2つのモデルがある。

**プッシュモデル**: 無効化イベントを全サーバーにブロードキャストする。Pub/Subパターン（Redis Pub/Sub、メッセージキュー等）が典型。伝播レイテンシは数ミリ秒〜数十ミリ秒程度で実現可能だが、インフラの複雑性が増す。

**プルモデル**: 各サーバーが定期的にセッション状態をポーリングする。実装が単純だが、ポーリング間隔が実質的な「無効化遅延」となる。

さらに、マルチテナントという文脈では、テナントAのセッション管理上の問題（大量のセッション作成等）がテナントBのセッション検証レイテンシに影響してはならない。これはノイジーネイバー問題であり、共有インフラを使う限り完全な分離は困難である。

## 7. 解決策

### 7.1 基本原理

**ハイブリッドアーキテクチャ: 短命JWTアクセストークン + ステートフルセッション台帳**を採用する。

基本的な考え方は以下の通りである。

- **アクセストークン**: 有効期限を極めて短く（5分）設定したJWT。APPサーバーのローカルで署名検証のみで認証完結。レイテンシ最小化のための主要手段。
- **セッション台帳（Session Registry）**: Redisに保存する。セッションID→セッションメタデータのマッピングを保持。管理者の無効化操作はここへのDELETEで即座に反映。
- **リフレッシュフロー**: アクセストークン有効期限切れ時、クライアントはリフレッシュトークンとセッションIDでセッション台帳を参照して新しいアクセストークンを取得する。このタイミングでのみセッション台帳への参照が発生する。

**セッションの無効化伝播**: Redis Pub/Subを使い、無効化イベントを全APPサーバーにブロードキャストする。各APPサーバーはローカルに短命のブラックリストキャッシュを保持し、受信したセッションIDを5分間（アクセストークンの最大有効期限）だけキャッシュする。これにより、無効化後に既発行のアクセストークンが到着した場合でも、ローカルキャッシュで即座に拒否できる。

**テナント分離**: Redisのキープレフィックスを `tenant:{tenantId}:session:{sessionId}` の形式で統一する。将来的にテナントごとのRedis分離が必要になった場合も、このキー設計を維持したままデータを移行できる。

### 7.2 実装方針

**セッション発行（ログイン）**

```
1. ユーザー認証成功後:
   a. sessionId = UUID v4 を生成
   b. deviceId = デバイスフィンガープリントまたはクライアント提供のID
   c. Redisに以下を保存:
      Key: tenant:{tenantId}:session:{sessionId}
      Value: {
        userId, tenantId, deviceId,
        createdAt, lastActivityAt,
        expiresAt (例: 30日後),
        isActive: true
      }
      TTL: 30日
   d. accessToken (JWT) を生成:
      Claims: {sub: userId, tenantId, sessionId, exp: now+5min}
      署名: RS256 (テナントごとの秘密鍵は不要、サービス共通鍵で可)
   e. refreshToken = sessionId (または sessionId を含む署名付きトークン)
   f. accessToken と refreshToken をクライアントに返す

2. マルチデバイス管理:
   - tenant:{tenantId}:user:{userId}:sessions にsessionIdをSET型で追加
   - これにより特定ユーザーの全セッション一覧が取得可能
```

**セッション検証（APIリクエスト）**

```
1. AuthorizationヘッダーからアクセストークンJWTを取得
2. ローカルでJWT署名検証（DB/Redis参照不要）
3. ローカルブラックリストキャッシュを参照:
   - sessionId がブラックリストに存在すれば 401 を返す
4. 問題なければリクエストを処理
→ 通常リクエストは Redis参照ゼロで完結
```

**トークンリフレッシュ（アクセストークン期限切れ時）**

```
1. クライアントがrefreshToken(=sessionId)でリフレッシュエンドポイントを呼ぶ
2. Redisから tenant:{tenantId}:session:{sessionId} を取得
3. isActive=false または 存在しない場合は 401 を返す
4. expiresAt を確認し期限切れなら 401 を返す
5. lastActivityAt を更新
6. 新しいアクセストークンJWTを発行して返す
```

**セッション無効化（管理者操作）**

```
1. 管理者が特定ユーザーのセッション一覧を取得:
   Redis SMEMBERS tenant:{tenantId}:user:{userId}:sessions
2. 無効化対象のsessionIdを選択（全デバイス、または特定デバイス）
3. Redisから当該セッションをDELETE:
   DEL tenant:{tenantId}:session:{sessionId}
   SREM tenant:{tenantId}:user:{userId}:sessions {sessionId}
4. Redis Pub/SubでAPPサーバー全台にブロードキャスト:
   Channel: session-invalidation
   Message: {sessionId, tenantId, invalidatedAt}
5. 各APPサーバーはメッセージ受信時、ローカルブラックリストにsessionIdを追加
   （TTL: アクセストークンの最大有効期限=5分）
```

**水平スケーリング対応**

- APPサーバーは完全にステートレス（ローカルブラックリストは揮発性キャッシュとして扱う）
- APPサーバーの起動時にRedis Pub/SubのChannelをサブスクライブする
- APPサーバーの終了時にサブスクリプションを解除する
- オートスケーリングで新規サーバーが追加された場合、既存の無効化状態はリフレッシュ時のRedis参照で自動的に反映される（最悪ケースでも5分後には反映）

**Redis高可用性**

- Redis Sentinelまたはクラスターモードを使用する
- セッション台帳とPub/Subを同一クラスターで運用するか、分離するかはトラフィック規模に応じて判断する
- Redis障害時のフォールバック: アクセストークンのJWT検証のみで認証を継続する（無効化機能は一時的に利用不能になるが、認証自体は継続できる。これをサービス運用ポリシーとして明示する）

## 8. 検証条件

### 検証1: マルチデバイスログインのサポート

**Given**: テナントT1のユーザーU1が存在し、デバイスA（スマートフォン）でログイン済みである

**When**: 同じユーザーU1がデバイスB（PC）でログインを実行する

**Then**:
- デバイスBに対して新しいセッションID（sessionId-B）と新しいアクセストークンが発行される
- Redis上で `tenant:T1:user:U1:sessions` には sessionId-A と sessionId-B の両方が存在する
- デバイスAのアクセストークンは引き続き有効であり、APIリクエストが認証される
- デバイスBのアクセストークンも有効であり、APIリクエストが認証される

### 検証2: 管理者によるセッション即時無効化

**Given**: テナントT1のユーザーU1がデバイスAとデバイスBでそれぞれログイン済みであり、両デバイスのアクセストークンが有効期限内である

**When**: テナントT1の管理者がユーザーU1のデバイスAのセッションを無効化する操作を実行する

**Then**:
- Redis上の `tenant:T1:session:{sessionId-A}` が削除される
- 5秒以内に全APPサーバーのローカルブラックリストにsessionId-Aが追加される
- デバイスAからの次のAPIリクエストは、アクセストークンがまだ有効期限内であっても 401 を返す
- デバイスBからのAPIリクエストは引き続き 200 を返し、通常通り動作する
- デバイスAがリフレッシュを試みても 401 を返し、新しいアクセストークンが発行されない

### 検証3: 水平スケーリング下での認証一貫性

**Given**: APPサーバーが2台（Server1, Server2）で稼働しており、ユーザーU1がログイン済みである。管理者がU1のセッションを無効化した直後に、Server3が新たにオートスケーリングにより追加される

**When**: U1のデバイスからのリクエストがServer3に到達する（Server3はブラックリストキャッシュを持っていない）

**Then**:
- Server3はJWT署名検証に成功するが、アクセストークン内のsessionIdでRedisのセッション台帳を参照しない（通常フローではRedis参照しない設計のため）
- 最悪ケースでアクセストークンの残余有効期限（最大5分）が経過した後、U1がリフレッシュを試みた際にRedisで401が返される
- アクセストークンの有効期限（5分）内に発行された無効化イベントはServer3がサブスクライブを開始した後のものは受信されるため、段階的にブラックリストが構築される
- この最大5分の窓をポリシーとして許容しない場合は、Server3起動時にRedis上の有効な無効化済みセッションIDのスナップショットを取得するブートストラップ処理を実装する

### 検証4: 認証レイテンシの要件達成

**Given**: APPサーバーが正常稼働しており、有効なアクセストークンを持つクライアントからAPIリクエストが来る

**When**: クライアントがAPIエンドポイントにリクエストを送信する（セッション無効化は発生していない通常状態）

**Then**:
- APPサーバーはJWT署名検証のみでリクエストを認証する（Redis参照なし）
- ローカルブラックリストキャッシュの参照はオンメモリ操作で完結する
- 認証処理そのものに要するレイテンシは1ms以下である
- エンドツーエンドのAPIレスポンスタイムへの認証オーバーヘッドは最小限（p99で5ms以内）に抑えられる

### 検証5: テナント間のセッション分離

**Given**: テナントT1のユーザーU1と、テナントT2のユーザーU2がそれぞれログイン済みである

**When**: テナントT2の管理者がT2内の全セッションを無効化する操作を実行する

**Then**:
- Redis上の `tenant:T2:*` プレフィックスに対するキーが削除される
- T1のユーザーU1のセッションは一切影響を受けない
- U1のAPIリクエストは引き続き 200 を返す
- Redis上の `tenant:T1:session:{sessionId-U1}` は変更されていない

## 9. 制約、限界、今後の課題

### 現在の制約

**無効化の確実性窓**: 提案するアーキテクチャでは、サーバー追加直後の最大5分間、そのサーバーが過去に発行された無効化を認識しない可能性がある。セキュリティ上の重大なインシデント（漏洩したクレデンシャルによる不正アクセス等）においてこの5分が許容できないケースでは、ブートストラップ処理またはアクセストークン有効期限のさらなる短縮（1分等）が必要になる。

**Redisへの依存**: セッションリフレッシュとマルチデバイス管理はRedisに依存する。Redis障害時のフォールバックとして認証継続を選択した場合、その間に発行された無効化要求は機能しない。これをサービス利用規約として明示する必要がある。

**クロスリージョンの考慮外**: 本設計はシングルリージョンを前提としている。マルチリージョン展開時は、Redisのクロスリージョンレプリケーションと、リージョン間での無効化イベント伝播の遅延（数十〜数百ms）に対する追加設計が必要である。

### 現在の限界

**Pub/Sub信頼性**: Redis Pub/Subは「at-most-once」配信モデルである。メッセージ消失時、無効化イベントが全サーバーに届かない可能性がある。これを補うために、各APPサーバーはリフレッシュリクエスト処理時には必ずRedisのセッション台帳を参照する（つまり、ローカルキャッシュヒットなしの場合）設計としており、最終的な一貫性は保証される。より厳格なat-least-once保証が必要な場合は、Kafka等のメッセージキューへの置き換えを検討する。

**大規模テナントのホットスポット**: 単一テナントに数万人のアクティブユーザーがいる場合、そのテナントの無効化操作（例: 全社員のセッション一括無効化）が大量のPub/Subメッセージを生成し、他テナントへの処理に影響を及ぼす可能性がある。テナント別のPub/Subチャンネル分離と、テナントごとのリソースクォータ設定が対策となる。

### 今後の課題

**デバイスフィンガープリントの精度向上**: 同一デバイスの識別精度を高めることで、「新しいデバイスからのログイン検知」や「不審なデバイスのセッション自動失効」などのセキュリティ機能を追加できる。

**セッション異常検知**: 同一セッションが地理的に離れた場所から短時間内に使われた場合（Impossible Travel検知）等の異常パターン検出をセッション管理レイヤーに組み込む。これにはアクセスログとセッションメタデータの相関分析が必要となる。

**ゼロダウンタイムキーローテーション**: JWTの署名検証に使う公開鍵のローテーションを無停止で行う仕組みが必要である。JWK（JSON Web Key Set）エンドポイントをAPPサーバーがキャッシュし、旧キーと新キーの両方を一定期間有効とする移行期間設計を検討する。

**セッション管理のサービス化**: 成長に伴い、セッション管理機能をAPPサーバーのロジックに埋め込んでおくと変更が困難になる。独立したSession Serviceとして切り出し、APPサーバーはgRPC/REST経由でセッション検証を委譲する設計（サービスメッシュパターン）への移行を将来的に検討する。ただし、これはレイテンシのトレードオフを再び生むため、採用タイミングと設計を慎重に評価する必要がある。
