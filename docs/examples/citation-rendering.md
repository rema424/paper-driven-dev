# Example: LLM ストリーミング出力における引用参照のリアルタイム描画問題

> This document was generated using the `/paper-driven-dev:article` skill.
> It demonstrates how academic paper format elicits systematic design analysis from LLMs.

---

## 1. 問題定義

### 1.1 背景

Retrieval-Augmented Generation (RAG) システムでは、LLM が検索結果を引用しながら回答を生成する。生成された回答中の引用参照（例: `[1]`, `[2]`）はクリッカブルなリンクとしてレンダリングされ、ユーザーは引用元の判例・法令等を即座に確認できる。

近年の対話型 AI サービス（Perplexity, ChatGPT with Search, Claude with Citations 等）では、LLM の出力をトークン単位でストリーミングし、ユーザーに対してリアルタイムに回答を表示する UX が標準となっている。この UX では、引用参照もストリーミング中からリアルタイムに正しい番号で表示される。

### 1.2 二つの矛盾する要求

RAG ストリーミングにおける引用描画には、本質的に矛盾する2つの要求がある:

**要求 A: リアルタイム表示**
ユーザーはストリーミング中に本文テキストと引用参照をリアルタイムで見たい。生成完了まで待つスピナー表示は、応答性の観点で劣る。

**要求 B: 正しい連番**
引用参照は `[1]`, `[2]`, `[3]` と連番であるべきで、ギャップ（`[1]`, `[5]`, `[12]`）があってはならない。ユーザーが「引用 [2] はどこ？」と混乱するためである。

矛盾は以下の点に生じる。LLM は検索結果の**元番号**（例: 10件中の3番目と7番目）を使って引用するが、最終的な表示番号は**使用した引用のみの連番**（3→[1], 7→[2]）であるべきである。このリナンバリングは全文が確定するまで完了できない——しかしストリーミング中はまだ全文が確定していない。

### 1.3 本文書の範囲

本文書は、構造化 JSON 出力（`{ body: "...[source_N]...", citedSourceIds: [...] }`）を返す LLM ストリーミングにおいて、引用参照をリアルタイムかつ正しい連番で描画する手法を検討する。

---

## 2. 典型的なアーキテクチャと制約

### 2.1 データフロー

```
検索エンジン → 検索結果 [source_1]...[source_N]
  ↓
コンテキスト構築 → LLM プロンプト（検索結果を [source_1]...[source_N] として埋め込み）
  ↓
LLM ストリーミング → トークン単位で JSON を出力（[source_N] 形式で引用）
  ↓
サーバー蓄積 → 完全な JSON 文字列
  ↓
パース + ポストプロセス → [source_N] を [M] にリナンバリング
  ↓
クライアント表示 → [1], [2], [3] としてレンダリング
```

### 2.2 リナンバリングの定義

- **元番号 (source ID)**: 検索結果のインデックス。10件の検索結果があれば 1〜10。
- **表示番号 (display ID)**: ユーザーに表示する連番。引用された検索結果のみに 1 から順に割り当てる。
- **リナンバリング**: 元番号から表示番号への写像 `f: source_ID → display_ID`。

例: 検索結果10件中、LLM が source_3, source_7, source_1 を（この順で）引用した場合:

- `f(3) = 1, f(7) = 2, f(1) = 3`（出現順採番の場合）

### 2.3 ストリーミングの制約

LLM のトークンストリームは以下の性質を持つ:

1. **逐次的**: トークンは先頭から順に生成される。後戻りしない。
2. **不可分**: 生成途中でトークンを変更できない（すでに送信済み）。
3. **非決定的完了**: いつストリームが終わるか事前にわからない。
4. **構造化出力の漸進性**: JSON は先頭の `{` から末尾の `}` まで順に構築される。`body` フィールドの値も文字列として漸進的に構築される。

---

## 3. 既存アプローチとその限界

### 3.1 アプローチ A: 完了待ちスピナー表示

**手法**: ストリーミング中は「回答を生成中...」とスピナーを表示し、`complete` イベント受信後にリナンバリング済みの最終結果を一括表示する。

**利点**: 実装が単純。リナンバリングの整合性問題が発生しない。

**限界**: ストリーミングの意味がない。LLM の生成は数秒〜十数秒かかり、その間ユーザーは何も見えない。対話型 AI の UX 標準から大きく劣後する。

### 3.2 アプローチ B: クライアント側の手動 JSON パーサー

**手法**: ストリーミング中の不完全 JSON から正規表現や文字単位のパーサーで `body` フィールドを抽出し、リアルタイム表示する。

```javascript
// 実装例（手動パーサー）
const bodyMatch = text.match(/"body"\s*:\s*"/);
const start = bodyMatch.index + bodyMatch[0].length;
// 文字を1つずつ読み、エスケープシーケンスを手動処理...
```

**利点**: 外部依存なし。ストリーミング中に本文を表示できる。

**限界**:

- **エスケープシーケンスの処理バグ**: JSON 文字列中の `\n`, `\"`, `\\`, `\uXXXX` を手動で処理する必要があり、不完全な実装は生のエスケープ文字がユーザーに表示される。
- **引用のリナンバリングが未解決**: `body` を抽出できても、中の `[source_N]` をどう変換するかの問題が残る。

### 3.3 アプローチ C: LLM に連番を直接出力させる

**手法**: LLM プロンプトで「引用は初出順に `[1]`, `[2]`, `[3]` と連番で出力せよ」と指示する。LLM 自身がリナンバリングを行うため、ストリーミング中の出力がそのまま最終表示となる。

**利点**: リナンバリングが不要。ストリーミングと最終表示が完全一致。

**限界**:

- **LLM の採番エラー**: LLM は番号の一貫性を保証しない。同じソースに異なる番号を割り当てたり、番号を飛ばしたり重複させることがある。特に長い回答で顕著になる。
- **検証の困難**: LLM の出力した番号が正しいかを検証するには、結局サーバー側で全文を解析する必要がある。エラーを検出しても、すでにストリーミング済みのテキストは修正できない。
- **プロンプトの複雑化**: 採番ルールの記述がプロンプトの認知負荷を増し、本来の回答品質に影響する可能性がある。

### 3.4 アプローチ D: ギャップを許容する

**手法**: 検索結果の元番号をそのまま表示番号として使う。LLM が source_3 と source_7 を引用したら、`[3]` と `[7]` を表示する。

**利点**: リナンバリング不要。ストリーミング中から正しい番号が出る。

**限界**: ユーザーに不自然な UX を強いる。「[1] と [2] はどこ？」「なぜ [3] から始まる？」という混乱が予想される。Perplexity 等の先行サービスでもこのアプローチは採用されていない。

### 3.5 アプローチ E: ストリーミング中は仮番号を使い、完了時に差し替え

**手法**: ストリーミング中は出現順に仮の連番を振り、`complete` イベント受信時にサーバーの最終結果で一括差し替える。

**利点**: ストリーミング中は常に連番が表示される。

**限界**: **番号ジャンプ**が発生する。サーバーの採番順がクライアントの出現順と異なる場合、`complete` 受信時に `[1]` が `[3]` に変わるなどの視覚的混乱が起きる。ユーザーがストリーミング中に `[1]` をクリックしようとした瞬間に番号が変わる最悪のケースも想定される。

---

## 4. 問題の本質: 採番順序の非決定性

上記の分析から、問題の本質が明らかになる:

> **ストリーミング中のクライアント側採番と、完了後のサーバー側採番が異なる順序を使う限り、番号ジャンプは原理的に排除できない。**

サーバー側の `buildEffectiveCitedIds` が以下の優先順で採番していた:

1. `citedSourceIds` 配列の順序（LLM が申告した引用リスト）
2. body テキスト中の出現順
3. summary テキスト中の出現順

一方、クライアント側がストリーミング中にアクセスできるのは body テキストのみであり、`citedSourceIds` は JSON の別フィールドとしてストリームの後半に出現する。したがって、クライアントは body 出現順でしか採番できず、サーバーが `citedSourceIds` 順序を優先する限り不一致が発生する。

**具体例**:

- `citedSourceIds = [1, 3]`（LLM は source_1 を先に「宣言」）
- body = `"判例[source_3]は…[source_1]と比較すると…"`（本文では source_3 が先に出現）

| 採番方式                        | source_3 の表示番号 | source_1 の表示番号 |
| ------------------------------- | ------------------- | ------------------- |
| citedSourceIds 優先（サーバー） | [2]                 | [1]                 |
| body 出現順（クライアント）     | [1]                 | [2]                 |

→ `complete` 受信時に全番号が入れ替わる。

---

## 5. 提案手法: Body 出現順統一と Append-Only 不変条件

### 5.1 基本原理

**採番の唯一のソースを body テキストの出現順とする。** これにより、ストリーミング中にクライアントが行う採番と、完了後にサーバーが行う採番が原理的に一致する。

### 5.2 採番規則

```
renumber(text) の採番順:
  1. body テキスト中の [source_N] の出現順（初出のみ）
  2. summary テキスト中の [source_N] の出現順（body に未出現のもののみ）
```

`citedSourceIds` は採番の順序ソースとしては使用せず、以下の役割に限定する:

- **Phantom citation フィルタ**: `citedSourceIds` にも body/summary にも出現しないソースは除外
- **監査ログ**: LLM がどのソースを「意図的に」引用したかの記録

### 5.3 Append-Only 不変条件

> **一度割り当てた表示番号は、その後のストリーム進行によって変更されない。**

これは body 出現順採番から自然に導かれる。ストリームは先頭から末尾へ進行し、新しい引用は常に既存の引用の**後**に出現する。したがって `f(source_N) = M` が確定した後に、`M` が別の値に変わることはない。

形式的に:

```
任意の時刻 t1 < t2 について:
  body(t1) が body(t2) の prefix であるとき、
  renumber(body(t1)) で割り当てた全ての (source_ID, display_ID) ペアは
  renumber(body(t2)) においても同一である。
```

この不変条件により、ストリーミング中に表示した引用番号が `complete` 後に変わらないことが保証される。

### 5.4 実装アーキテクチャ

```
                    ┌──────────────────────────────┐
                    │ renumberCitations(text)       │
                    │  純関数・副作用なし            │
                    │  入力: テキスト                │
                    │  出力: リナンバリング済みテキスト │
                    └──────────┬───────────────────┘
                               │
              ┌────────────────┼────────────────┐
              ▼                                 ▼
     サーバー (post-processor)          クライアント (streaming UI)
     完全な body を渡す                partial-json で抽出した
                                      不完全な body を渡す
              │                                 │
              ▼                                 ▼
     [source_3]→[1], [source_1]→[2]    [source_3]→[1], [source_1]→[2]
     （一致が保証される）                 （同一関数なので一致）
```

**同一の純関数をサーバーとクライアントで共有する**ことで、実装の乖離による不一致を構造的に排除する。

### 5.5 不完全 JSON のパース

ストリーミング中の `body` 抽出には `partial-json` ライブラリを使用する。

```javascript
import { parse, STR, OBJ, ARR, NUM } from "partial-json";

// ストリーミング中の不完全 JSON
const streaming = '{"summary": "要約", "body": "民法709条[source_3]によると';
const parsed = parse(streaming, STR | OBJ | ARR | NUM);
// → { summary: "要約", body: "民法709条[source_3]によると" }
```

手動パーサー（アプローチ B）と異なり、`partial-json` は正規の JSON パース規則に従うため、エスケープシーケンスの処理バグが発生しない。

### 5.6 ストリーミング中の引用リンク化

body 出現順採番と append-only 不変条件により、ストリーミング中に出現した `[source_N]` をリアルタイムにリンク化することが安全になる。

ただし、**引用カード**（引用元の詳細情報）はストリーミング中には構築できない。カードに必要な情報（裁判所名、判決日、法令名等）は `complete` イベントに含まれる。したがって:

- ストリーミング中: `[1]` はクリック不可のバッジとして表示
- `complete` 後: `[1]` はクリッカブルなリンクに昇格し、引用カードへのスクロールを発火する

この段階的な UX 向上は、ユーザーにとって自然である。テキストが生成されている最中にリンクをクリックしようとする行動は稀であり、引用の詳細は回答全体を読んだ後に確認するのが一般的なフローだからである。

---

## 6. 検証可能な性質

提案手法は以下のテスト可能な性質を持つ:

**性質 1: 整合性**
任意の body テキスト T について、`renumberCitations(T)` の結果はサーバー・クライアントで同一である。（同一関数を共有するため自明）

**性質 2: Append-Only**
任意のプレフィックス P と完全テキスト T（P が T のプレフィックス）について、`renumberCitations(P)` で割り当てられた全ての表示番号は `renumberCitations(T)` でも同一である。

**性質 3: 連番**
任意のテキスト T について、`renumberCitations(T)` が割り当てる表示番号は 1 から始まる連番であり、ギャップがない。

**性質 4: 安全な劣化**
`partial-json` による body 抽出が失敗した場合（例: JSON 構造がまだ `body` フィールドに到達していない）、フォールバックとしてスピナー表示に切り替わる。最終表示は常にサーバーの `complete` イベントに基づくため、ストリーミング中の表示障害が最終結果に影響しない。

---

## 7. 制約と今後の課題

**制約 1: summary 内引用の採番タイミング**
summary は JSON 構造上 body より前に出現する。summary 内に引用がある場合、body の出現順と summary の出現順が異なると、ストリーミング中（body のみ表示）と最終結果（summary + body）で採番が異なる可能性がある。実運用上、summary に引用を含めないプロンプト設計で回避可能。

**制約 2: JSON フィールド出力順の依存**
提案手法は LLM が `body` フィールドを `citedSourceIds` より前に出力することを前提とする。現状の JSON スキーマ順序（`summary` → `body` → `citedSourceIds`）ではこの前提が成立するが、LLM がフィールド順序を変えた場合に崩れる。構造化出力（structured output）機能を使えばフィールド順を強制できる。

**制約 3: 引用の途中出現**
ストリーミング中に `[source_` まで出力され `3]` がまだ出ていない状態では、引用番号が未確定である。`partial-json` は不完全な文字列を途中まで返すため、`[source_` がユーザーに一瞬見える可能性がある。リナンバリングの正規表現を適用した後の出力を表示することで、マッチしない不完全な参照は変換されず残るが、これは次のトークンで即座に解決される。
