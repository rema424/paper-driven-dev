# CS1 条件A: Conventional — RAG 引用リナンバリング

> **実験条件**: Model: GPT-5.2 (via Codex) | Date: 2026-02 | Prompt language: Japanese
> **プロンプト**: 「以下の技術的な問題について、設計分析と解決策を提案してください。」

---

## 設計上のポイント（「正しい連番」の定義）
ストリーミング中に"最終的な連番"が未確定になるのは、**連番規則が「全文確定後にしか決められない」**前提だからです。
一方、UIで一般的な引用番号規則は **「本文中の初出順で [1],[2],…」** なので、これはストリームの左→右処理で**オンライン（逐次）に確定**できます。

以降はこの規則（初出順）を前提に、リアルタイムに確定番号で描画する方法を提案します。

---

## 推奨解：オンライン・リナンバリング（初出順で確定）
### 1) データ構造
- `displayNoBySourceId: Map<source_7, 1>`（内部ソースID → 表示番号）
- `sourceIdByDisplayNo: Array`（表示番号 → 内部ソースID、= 初出順リスト）

### 2) ストリーム処理（本文 body のみ見ればよい）
- `body` のストリーム断片（chunk）を受け取るたびに、`[source_N]` パターンを検出
- 検出した `sourceId` について：
  - 初出なら `displayNo = (現在の件数 + 1)` を割り当てて Map/Array に登録
  - 出力側には `[source_N]` を **`[displayNo]` に置換**して即時描画
- 同一 `sourceId` の再登場は同じ番号を再利用（番号は変わらない）

> 重要：ストリーミングが"最終本文の順"で流れてくる限り、**初出順は将来ひっくり返らない**ため、番号は確定値として扱えます。

### 3) citedSourceIds の扱い（LLM出力に依存しないのが堅い）
- UI表示用の引用一覧は `sourceIdByDisplayNo` から生成（=「本文で実際に使われた引用のみ」）
- LLMが返す `citedSourceIds` は **検証用**（差分があればログ/監視）に回すのが安全です
  （モデルが重複・漏れ・未使用IDを混ぜるケースがあるため）

---

## 実装上の要所：ストリーム断片で引用トークンが分割される問題
chunk境界で `"[sou"` + `"rce_7]"` のように割れるので、**状態機械（小さなバッファ）**が必要です。
- `[` を見たら一旦バッファリング開始
- `]` まで貯めてから `source_\d+` にマッチした時だけ citation として確定
- マッチしなければ通常テキストとして吐き出す

（さらに堅くするなら、モデルに `[source_7]` ではなく `{{cite:source_7}}` のような衝突しにくい記法を強制します）

---

## 例外ケースと設計選択肢
### A) 後段で「引用の無効化/削除」をするなら（番号が変わり得る）
リアルタイム確定番号と相性が悪いので、どちらかに寄せます。
- **方針1（推奨）**：削除せず「無効」表示にする（番号は不変でUXが安定）
- **方針2**：UIをプレーンテキストにせず、`<cite data-source-id="source_7">[1]</cite>` のような**DOMノード**で保持し、確定後に番号を再計算して一括更新（差し替え可能なレンダラ前提）

### B) 連番規則を「ソート順」等にしたい場合
そのまでは全文確定が必要なので、ストリーミング中は
- いったん `[source_7]` のまま表示 or 仮番号表示
- 完了イベントで全置換して確定番号に更新
が現実的です。

---

## まとめ
- **「本文中の初出順で採番」と仕様化**すれば、ストリーミング中でも番号はオンラインに確定でき、後から崩れません。
- 実装は「引用パターン検出 + `sourceId→表示番号` のMap」だけで成立します。
- 後段で引用を削る/並べ替える要件があるなら、**DOMマーカー方式**（後から差し替え可能）にして"確定後リナンバリング"に寄せるのが安全です。
