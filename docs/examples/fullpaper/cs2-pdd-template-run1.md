# CS2 条件C: PDD Template — セッション管理 (Run 1)

> **Run**: CS2-C-Run1
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c76c8-f1b7-7a33-bcb0-c2d4be70a63e)
> **Model**: GPT-5.2 (via Codex)

---

§1. 問題定義

§1.1 背景
マルチテナントSaaSでは、ユーザー体験（複数端末利用・低遅延）と運用要件（管理者による強制ログアウト・水平スケール）を同時に満たすセッション管理が必要である。特にAPIリクエスト毎の認証は全トラフィックに乗るため、設計上のボトルネックになりやすい。

§1.2 矛盾する要求（対立するトレードオフ）
- 低レイテンシ（ローカルで完結する署名検証） vs 即時無効化（全ノードでの失効状態の同期・参照）
- 水平スケール（ステートレス） vs 強制ログアウト（共有状態＝セッション真理値の集中管理）
- 細粒度（特定セッション失効） vs 運用コスト（失効リスト肥大・配布負荷）
- テナント分離（鍵・データの隔離） vs 実装複雑性（鍵管理・名前空間管理）

§1.3 本文書の範囲
HTTP Bearer認証を前提に、(i) 同一ユーザー複数端末の同時ログイン、(ii) 管理者による即時無効化、(iii) 水平スケーリング、(iv) 認証レイテンシ最小化、を両立するセッション管理（発行・検証・失効伝播）を設計対象とする。

§2. 現状のアーキテクチャと制約
- APIサーバーは複数台で水平スケールし、リクエストは任意ノードに到達する（スティッキー前提不可）。
- 認証は毎リクエストで実行され、p99遅延を支配し得る（分散ストアへの都度照会は避けたい）。
- マルチテナントのため、`tenant_id` による厳密な分離（鍵・セッション状態・監査ログ）が必要。
- 「即時無効化」は実務上、全ノード反映のSLO（例: 数百ms〜数秒）として定義されるべきで、分散環境では伝播遅延・イベント欠損・再起動を考慮する必要がある。

§3. 既存アプローチとその限界

§3.1 アプローチ1: サーバーサイドセッション（共有ストア参照）— 手法 / 利点 / 限界
- 手法: セッションIDをクッキー/ヘッダで送り、各リクエストで共有ストア（DB/Redis）から状態参照。
- 利点: 失効が強整合に近く、管理者操作が即時反映しやすい。
- 限界: 毎リクエストの外部I/Oがレイテンシ・コスト・スループットを悪化させる。

§3.2 アプローチ2: 完全ステートレスJWT（長寿命）— 手法 / 利点 / 限界
- 手法: JWTを署名し、各ノードがローカル検証のみで許可。
- 利点: 認証レイテンシ最小、水平スケール容易。
- 限界: 即時失効が困難（漏洩時・強制ログアウト時のリスクがトークンTTLに依存）。

§3.3 アプローチ3: JWT + 失効リスト（ブラックリスト）— 手法 / 利点 / 限界
- 手法: 失効した`jti`等を共有ストアに記録し、検証時に照会。
- 利点: 即時失効を実現可能。
- 限界: 照会がホットパス化しやすく、リスト肥大とガベージ回収が課題。

§3.4 アプローチ4: OAuth2 Token Introspection — 手法 / 利点 / 限界
- 手法: APIが認可サーバーへ都度問い合わせて有効性確認。
- 利点: 中央で強制失効・監査が可能。
- 限界: ネットワーク往復が増え、低遅延要件と衝突する。

§4. 問題の本質
本質は「失効という"共有状態"を、水平スケールした多数ノードへ低遅延に伝播し、かつ各リクエストでの外部参照を最小化する」点にある。すなわち、(a) 失効の真理値は集中管理しつつ、(b) 認証ホットパスは可能な限りローカルで完結させる二律背反の緩和が中心課題である。

§5. 提案手法

§5.1 基本原理
提案は「短寿命アクセストークン + セッション世代（epoch）+ ローカルキャッシュ + 失効イベント配布」の組合せである。
- アクセストークン: 署名付きJWT（短TTL）。クレームに`tenant_id, user_id, session_id, user_epoch, iat, exp`を含める。
- 真理値ストア: 共有ストア（例: Redis Cluster）に `tenant:user_epoch[user_id]` と `tenant:session_status[session_id]` を保持。
- 即時無効化:
  - ユーザー全セッション無効化＝`user_epoch`をインクリメント（世代更新）。
  - 特定セッション無効化＝`session_status`を`revoked`へ。
- 低レイテンシ化: 各APIノードは`user_epoch`と「失効済みsession_id集合」をローカルメモリにキャッシュし、イベント（Pub/Subやストリーム）で即時更新する。通常リクエストはローカル検証＋ローカル参照のみで完結させ、キャッシュミス時のみ共有ストアへ単発参照する。

§5.2 実装アーキテクチャ
- コンポーネント
  - Auth Service: ログイン時に`session_id`を発行し、JWTアクセストークン（短TTL）とリフレッシュトークン（不透明・回転・サーバー保管）を発行。
  - Session Store: `tenant_id`名前空間で `user_epoch` と `session_status` を保持（TTLはトークン寿命に整合）。
  - Event Bus: `UserInvalidated(tenant_id,user_id,new_epoch)`、`SessionRevoked(tenant_id,session_id)`を配布。
  - API Nodes:
    1) JWT署名検証（ローカル）
    2) `user_epoch_cache[(tenant_id,user_id)] >= token.user_epoch` を確認（キャッシュミス時のみストア参照）
    3) `revoked_session_cache` に`(tenant_id,session_id)`が存在すれば拒否（イベントで追加、TTLは最大トークン残存時間）
- 管理者操作
  - 「特定ユーザーを即時無効化」: ストアの`user_epoch`更新 → イベント配布 → 全ノードが該当ユーザーのキャッシュを更新し旧epochを拒否。
  - 「特定セッションを即時無効化」: `session_status=revoked` → イベント配布 → 全ノードが`revoked_session_cache`に追加。
- スケール・フォールトトレランス
  - 新規ノードは起動時にイベント購読を開始し、キャッシュミス時にストア参照で補完（ウォームアップ不要）。
  - イベント欠損に備え、キャッシュは短TTLで再取得し整合を回復（"即時性"はSLOで管理）。

§6. 検証可能な性質（Given/When/Then）

1) 同時ログイン
- Given: 同一`(tenant_id,user_id)`で異なる`session_id`が2つ発行済み
- When: 2端末から有効期限内のアクセストークンで同時にAPIを呼ぶ
- Then: 両方のリクエストが許可される

2) 管理者によるユーザー即時無効化
- Given: ユーザーの`user_epoch = e`で発行されたトークンが稼働中ノード群に存在する
- When: 管理者が当該ユーザーを無効化し`user_epoch`が`e+1`になる
- Then: 伝播SLO（例: 1秒）以内に、全ノードで`user_epoch < e+1`のトークンが拒否される

3) 管理者による特定セッション即時無効化
- Given: `session_id = s`のトークンが有効期限内
- When: 管理者が`session_id = s`をrevokeする
- Then: 伝播SLO以内に、`session_id = s`を含むリクエストが拒否される（同一ユーザーの他セッションは影響しない）

4) 水平スケーリング適合
- Given: APIノード数がNからN+kに増加し、リクエストが新ノードにも到達する
- When: 新ノードがトークン検証を行う
- Then: スティッキーセッション無しで認証が成立し、キャッシュミス時のみストア参照で補完される

5) 認証レイテンシ最小化（ホットパス）
- Given: `user_epoch_cache`がヒットし、失効イベントも反映済み
- When: APIが認証処理を実行する
- Then: 外部ストア参照なし（ローカル署名検証＋ローカル参照のみ）で完了する

§7. 制約と今後の課題
- 即時性は分散伝播に依存するため、厳密な「瞬時」ではなくSLOとして定義・監視（イベント遅延、欠損、再購読）する必要がある。
- マルチリージョン化では、イベント配布とストアの整合（遅延・分断）により失効の収束時間が伸び得る。
- 鍵管理（テナント別署名鍵、ローテーション、JWK配布）と監査（誰が誰を失効したか）の運用設計が不可欠。
- DoS耐性として、キャッシュミス誘発（ランダムuser_id連打）に対するレート制限・負荷分散・ストア保護が必要。
- 将来的には、失効イベントの厳密配送（少なくとも1回＋冪等適用）と、起動時の追いつき（ストリームのリプレイ）を標準化することで、即時性SLOの上限を引き上げられる。
