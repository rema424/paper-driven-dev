# CS1 条件C: PDD Template — RAG引用リナンバリング (Run 1)

> **Run**: CS1-C-Run1
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

# RAGストリーミング応答における引用リナンバリング問題: アーキテクチャ設計と検証可能性の分析

## §1. 問題定義

### §1.1 背景

Retrieval-Augmented Generation (RAG) システムは、大規模言語モデル (LLM) の知識を外部文書コーパスで補完する手法として広く採用されている。RAGの基本的な動作原理は、ユーザーのクエリに対して検索エンジンが関連文書を取得し、それらをコンテキストとしてLLMに提供することで、より根拠のある回答を生成させることにある。

このアーキテクチャにおいて、LLMは内部的に `source_3`、`source_7` のような識別子で検索結果を参照しながら回答を構築する。一方、ユーザー体験の観点からは、学術論文や報道記事における引用慣行に従い、`[1]`、`[2]`、`[3]` のような連番表記が望ましい。この連番は読者が出典一覧と対応付けるための索引として機能し、情報の信頼性検証を可能にする。

加えて、現代のRAGシステムはストリーミング配信を採用するケースが増加している。ストリーミングとは、LLMの生成トークンをバッファリングせずに逐次クライアントへ送信する方式であり、Time-To-First-Token (TTFT) の短縮によるユーザー体験の向上が主な動機である。ChatGPTをはじめとする主要なLLMサービスがストリーミングをデフォルト動作として採用したことで、ユーザーの期待値として定着しつつある。

このストリーミング要件と引用の連番表示要件が交差するとき、従来の処理パイプラインでは解決困難な矛盾が生じる。本問題はその矛盾の構造を分析し、設計上の解法を提示するものである。

### §1.2 矛盾する要求（対立するトレードオフ）

本問題には少なくとも3つの根本的なトレードオフが存在する。

**トレードオフ1: ストリーミング即時性 vs. 全体整合性**

ストリーミング配信は「生成されたトークンを即座にユーザーへ届ける」ことを本質とする。しかし引用の連番付けは、回答全体においてどの source が使用されるかを把握してはじめて確定できる。回答の冒頭で `source_7` が言及された時点では、その後の文章で `source_1`、`source_3`、`source_7` がすべて使用されるか、あるいは `source_7` のみが使用されるかが未確定であり、適切な番号を割り当てることができない。ストリーミングの即時性を優先すれば整合性が犠牲になり、整合性を優先すればストリーミングの本質的な価値が失われる。

**トレードオフ2: 表示安定性 vs. 最適な番号体系**

ユーザーが既に画面上で `[3]` という番号を読んだ後に、その番号が異なる出典を指すよう変更されることは、認知的な混乱を招き、誤った情報の印象を与えるリスクがある。したがって「一度表示した番号は変えない」という安定性制約が生じる。しかしこの制約は、出現順に番号を付けるという最も直感的な番号体系（`[1]` が最初に言及した出典、`[2]` が次の出典、という順序）と必ずしも矛盾しない一方で、「使用頻度順」「重要度順」「アルファベット順」など代替的な番号付け方針を事後的に適用する可能性を完全に閉じてしまう。つまり「後から番号を再構成する柔軟性」と「既表示の安定性」は原理的に両立しない。

**トレードオフ3: 前方割り当てのコスト vs. ストリーム効率**

未来の出現を予測して番号を事前に確保する（前方割り当て）戦略は、検索結果全体を事前に走査するコストを必要とする。検索結果が多数存在する場合、このプリプロセスはレイテンシを増加させる。また前方割り当てでは「実際には本文中で使用されなかった source」にも番号が予約されてしまう可能性があり、最終的なソース一覧が不必要に長くなる問題が生じる。

### §1.3 本文書の範囲

本文書は以下を対象とする。RAGシステムにおけるストリーミング応答中の引用番号表示方式を設計すること、その設計が満たすべき性質を形式的に定義すること、既存アプローチとの比較を通じて提案手法の位置づけを明確にすること。LLMの内部実装、検索エンジンの詳細、フロントエンドのレンダリング最適化は本文書のスコープ外とする。

---

## §2. 現状のアーキテクチャと制約

典型的なRAGストリーミングパイプラインは以下のコンポーネントから構成される。

```
[User Query]
    ↓
[Retriever]  →  { source_1, source_3, source_7, ... } (検索結果セット R)
    ↓
[Context Builder]  →  プロンプトに検索結果を埋め込む
    ↓
[LLM]  →  トークン列をストリーム出力
    ↓
[Stream Processor]  →  引用識別子を検出・変換
    ↓
[Client]  →  ユーザーへ表示
```

このパイプラインにおける制約を整理する。

**制約C1: 検索結果セットの事前確定**
Retrieverは質問応答前にクエリを実行し、検索結果セット R = {source_i₁, source_i₂, ..., source_iₙ} を確定する。この集合はLLMへのプロンプト構築時点で既知である。

**制約C2: LLM出力の一方向性**
ストリーミング中のLLM出力は逐次的であり、生成済みトークンを遡って修正することはできない。クライアントへ送信済みのトークンも同様に取り消し不可能である（HTTP Server-Sent Events や WebSocket における送信済みフレームの性質）。

**制約C3: 引用識別子の形式非保証**
LLMが出力する引用識別子の形式は完全には制御できない。プロンプトエンジニアリングにより `[source_3]` のような形式を誘導できるが、`(source 3)` や `source #3` のような変形が生じる可能性がある。ロバストな処理には正規表現による柔軟なマッチングが必要である。

**制約C4: ソース一覧の後置き**
多くのRAGシステムでは、回答本文の末尾または別ペインにソース一覧を表示する。ストリーミング完了後にソース一覧を構築する場合、本文中の引用番号とソース一覧の対応関係が整合していなければならない。

---

## §3. 既存アプローチとその限界

### §3.1 アプローチ1: 後処理リナンバリング (Post-processing Renumbering)

**手法**: LLMの生成が完了するまでストリームを内部バッファに蓄積し、完成した応答全体を一括処理して引用識別子を連番に変換する。変換済みの最終テキストをクライアントへ一括送信する。

**利点**: 実装が単純であり、引用番号の整合性が完全に保証される。全文を把握した上で番号付けを行うため、使用頻度順や出現順など任意の番号体系を適用できる。LLM出力の引用識別子形式が多少揺れても許容できる。

**限界**: ストリーミングの本質的な利点であるTTFTの短縮が失われる。ユーザーは全文生成完了まで待機する必要があり、長い応答の場合は体験が著しく低下する。この手法はストリーミングを「見た目だけの機能」に形骸化させる。ユーザーの期待するリアルタイム感が得られない。

### §3.2 アプローチ2: インライン仮番号 + 末尾置換 (Placeholder + Replacement)

**手法**: ストリーミング中はプレースホルダー（例: `[REF:source_3]`）をそのまま出力し、ストリーム完了後にクライアントサイドのJavaScriptで番号を一括置換する。

**利点**: サーバーサイドの処理を単純に保てる。クライアントサイドでの置換は低コストで実行できる。

**限界**: ストリーミング中にユーザーが見る文字列は `[REF:source_3]` という非標準的な形式であり、読みにくい。完了前の状態が中間状態として露出するため、未完了感を与える。さらに根本的に、「一度表示した番号が変わらない」という要件を満たさない。ユーザーが `[REF:source_3]` という表現を読んだ直後に数字への置換が行われれば、意味的な変化は生じていないものの、視覚的な変化は発生している。

### §3.3 アプローチ3: 出現順即時割り当て (First-Occurrence Assignment)

**手法**: ストリーム処理中に引用識別子を検出した時点で、まだ番号が割り当てられていなければ次の番号を割り当てる。割り当てテーブルを維持し、以降の同一識別子には同じ番号を使用する。

**利点**: リアルタイムで連番を表示でき、ストリーミング体験を維持できる。実装が比較的単純で、追加のレイテンシが最小限である。

**限界**: 「ストリーム完了時にソース一覧と整合している」という要件を満たすには、本文中で使用された識別子のみを最終ソース一覧に含めれば十分であり、その点では整合可能である。しかし一つ重大な問題がある: ストリーミング中に `source_7` が最初に言及されれば `[1]` という番号が割り当てられるが、後処理段階で「重要度順に並べ直す」ことが不可能になる。また、LLMが同一 source を複数の異なる形式で言及した場合（例: `source_7` と `source7`）、重複割り当てが発生するリスクがある。

### §3.4 アプローチ4: 事前ソートによる前方割り当て (Pre-sorted Forward Assignment)

**手法**: 検索結果セット R が確定した時点で、アルファベット順・関連度順などの基準で全 source に番号を割り当てたマッピングテーブルを生成する。ストリーミング中はこのテーブルを参照して変換するのみとする。

**利点**: ストリーミング体験が損なわれない。番号付け方針（関連度順など）を事前に適用できる。一貫したマッピングテーブルが存在するため、ストリーム完了時の整合性が自動的に保証される。

**限界**: 本文中で実際に使用されない source にも番号が割り当てられ、ソース一覧に不要なエントリが含まれる可能性がある。例えば R = {source_1, source_3, source_7} の場合、LLMが source_7 のみを言及した場合でも、最終ソース一覧には `[1] source_1`、`[2] source_3`、`[3] source_7` の全てが表示される（あるいは未使用分を除外すると番号体系が崩れる）。

---

## §4. 問題の本質

前章の分析を通じて、問題の本質が明確になる。

ストリーミング引用番号問題の本質は「決定時点の非対称性」にある。

引用番号の最適な割り当てには **全体情報**（回答全文でどの source が使用されるか）が必要である。しかしストリーミングの価値は **逐次性**（部分情報が確定した時点で即座にユーザーへ届けること）にある。

この非対称性を解消する方針は論理的に2種類しかない。

**方針A: 全体情報の事前確定** — 何らかの手段で全体情報を事前に把握し、ストリーミング中は確定済みの情報を参照するだけにする。前方割り当て（§3.4）がこれにあたる。

**方針B: 局所情報での確定的割り当て** — 全体情報がなくとも、局所的な情報（現時点までに出現した source）のみで確定的な割り当てを行い、以降の変更を禁止する。出現順即時割り当て（§3.3）がこれにあたる。

後処理リナンバリング（§3.1）は方針Aの特殊形（全体情報確定後にストリーミングを開始する）であり、ストリーミングの価値を完全に放棄したものと解釈できる。

真に要件を満たす設計は方針Aか方針Bの洗練版でなければならない。ただし方針Aは「事前に全体情報を得る仕組み」の実現可能性に依存し、方針Bは「最終ソース一覧との整合性」をどう保証するかが課題となる。

---

## §5. 提案手法

本文書では、方針Aと方針Bのハイブリッドとして **「確定的マッピング + 使用追跡 (Deterministic Mapping with Usage Tracking)」** を提案する。

### §5.1 基本原理

以下の3つの原理に基づく。

**原理1: 確定的な事前マッピング**
検索結果セット R が確定した時点（LLMへのプロンプト送信前）で、R の全要素に対して一意かつ確定的なマッピング M: source_id → display_number を生成する。この時点でのマッピング生成に使用できる情報は「検索順位」「関連度スコア」「source_id の辞書順」など任意でよい。重要なのは、LLMの生成内容に依存せず事前に確定させることである。

**原理2: 不変性の保証**
一度生成されたマッピング M はストリーミング完了まで変更されない。Stream Processor はこのマッピングを参照するだけであり、動的な番号割り当てを行わない。これにより「一度表示した番号は変わらない」という安定性が保証される。

**原理3: 使用追跡による整合ソース一覧の生成**
Stream Processor はストリーミング中に使用された source_id の集合 U ⊆ R を追跡する。ストリーム完了後、ソース一覧には U に含まれる source のみを、M が定義する番号順に表示する。U に含まれない source は番号を持っていても一覧には表示しない。

この原理3の適用により、前方割り当て（§3.4）が持つ「未使用 source が一覧に表示される」という限界を克服できる。ただし、ソース一覧の番号列が連番にならない可能性がある（例: `[1]`、`[3]`、`[5]` が使用されたが `[2]`、`[4]` は未使用）。この「歯抜け番号」がユーザーに違和感を与えるかどうかは文脈依存であり、§7 で論じる。

### §5.2 実装アーキテクチャ

**コンポーネント構成**

```
[Retriever] → R = {source_1, source_3, source_7, ...}
    ↓
[Mapping Generator]
    M = {source_1: 1, source_3: 2, source_7: 3}   ← 事前確定
    ↓
[LLM] → ストリーム出力 (source_3 や source_7 を含む)
    ↓
[Stream Processor]
    - 正規表現で引用識別子を検出
    - M を参照して display_number に変換
    - 使用集合 U に source_id を追加
    - 変換済みトークンをクライアントへ送信
    ↓
[Client] → ユーザーへリアルタイム表示
    ↓
[Completion Handler] (ストリーム完了時)
    - U から最終ソース一覧を構築
    - M の番号順でソートして表示
```

**Mapping Generator の実装**

```python
def generate_mapping(retrieved_sources: list[str],
                     strategy: str = "rank") -> dict[str, int]:
    """
    検索結果に対して確定的なマッピングを生成する。
    strategy:
      "rank"       - 検索ランク順 (default)
      "lexical"    - source_id の辞書順
      "score"      - 関連度スコア降順
    """
    if strategy == "rank":
        ordered = retrieved_sources  # 検索結果の返却順を保持
    elif strategy == "lexical":
        ordered = sorted(retrieved_sources)
    # score策略は省略

    return {source_id: idx + 1
            for idx, source_id in enumerate(ordered)}
```

**Stream Processor の実装**

```python
import re
from dataclasses import dataclass, field

CITATION_PATTERN = re.compile(
    r'\[source[_\s]?(\w+)\]'   # [source_3], [source 3]
    r'|\(source[_\s]?(\w+)\)'  # (source_3)
    r'|source[_\s]?#?(\w+)',   # source_3, source #3
    re.IGNORECASE
)

@dataclass
class StreamProcessor:
    mapping: dict[str, int]
    used_sources: set[str] = field(default_factory=set)

    def process_chunk(self, chunk: str) -> str:
        """チャンク内の引用識別子を変換する"""
        def replace_citation(match: re.Match) -> str:
            # いずれかのグループがマッチした source_id を取得
            raw_id = next(g for g in match.groups() if g is not None)
            source_key = f"source_{raw_id}"

            if source_key in self.mapping:
                self.used_sources.add(source_key)
                display_num = self.mapping[source_key]
                return f"[{display_num}]"
            else:
                # マッピングにない識別子はそのまま返す
                return match.group(0)

        return CITATION_PATTERN.sub(replace_citation, chunk)

    def build_source_list(self,
                          source_metadata: dict[str, dict]) -> list[dict]:
        """ストリーム完了後にソース一覧を構築する"""
        used_with_numbers = [
            (self.mapping[sid], sid, source_metadata.get(sid, {}))
            for sid in self.used_sources
            if sid in self.mapping
        ]
        return [
            {"number": num, "id": sid, **meta}
            for num, sid, meta in sorted(used_with_numbers)
        ]
```

**ストリーミングループの統合**

```python
async def rag_stream(query: str,
                     retriever,
                     llm,
                     source_metadata: dict):
    # Phase 1: 検索
    sources = await retriever.search(query)
    mapping = generate_mapping([s.id for s in sources])

    # Phase 2: LLM ストリーミング
    processor = StreamProcessor(mapping=mapping)
    prompt = build_prompt(query, sources)

    async for chunk in llm.stream(prompt):
        transformed = processor.process_chunk(chunk.text)
        yield {"type": "token", "content": transformed}

    # Phase 3: 完了後にソース一覧を送信
    source_list = processor.build_source_list(source_metadata)
    yield {"type": "sources", "content": source_list}
```

---

## §6. 検証可能な性質

提案手法が満たすべき性質を Given/When/Then 形式で定義する。

---

**P1: 番号不変性 (Number Immutability)**

- **Given**: 検索結果セット R に対してマッピング M が生成されており、ストリーミングが開始されている
- **When**: ストリーム中のチャンク cᵢ に引用 source_k が含まれており、M(source_k) = n が割り当てられている
- **Then**: 同一ストリーム内の後続チャンク cⱼ (j > i) において source_k が再度出現した場合も、M(source_k) = n が維持される。ストリーム完了時のソース一覧においても source_k は [n] として表示される

---

**P2: 出現時即時変換 (Immediate Conversion on Occurrence)**

- **Given**: Stream Processor がマッピング M を保持している
- **When**: LLM からのチャンクに引用識別子 source_k が含まれている
- **Then**: そのチャンクが Stream Processor を通過した出力では、source_k は [M(source_k)] に変換されている。変換のための追加バッファリング（複数チャンクの蓄積）は行われない

---

**P3: ソース一覧整合性 (Source List Consistency)**

- **Given**: ストリーミングが完了し、使用済み source 集合 U が確定している
- **When**: Completion Handler がソース一覧を構築する
- **Then**: ソース一覧に含まれる各エントリ (number, source_id) は、本文中で実際に `[number]` として出現した source_id と一対一に対応する。本文中に出現しなかった source_id はソース一覧に含まれない。本文中に出現したすべての source_id はソース一覧に含まれる

---

**P4: マッピング事前確定性 (Pre-stream Mapping Completeness)**

- **Given**: RAGパイプラインが検索フェーズを完了し、Retriever から検索結果セット R を受け取っている
- **When**: Mapping Generator が M を生成する
- **Then**: M の生成はLLMの生成開始前に完了しており、M は R のすべての要素を定義域に含む。ストリーミング中に M は変更されない

---

**P5: 未知識別子の透過 (Unknown Identifier Passthrough)**

- **Given**: LLM が R に含まれない識別子 source_x を出力した（プロンプト制御の失敗またはLLMの幻覚）
- **When**: Stream Processor がそのチャンクを処理する
- **Then**: source_x は変換されず元の文字列のままクライアントへ送信される。StreamProcessor はエラーを発生させずに処理を継続する。source_x は U に追加されない

---

**P6: マッピング戦略の交換可能性 (Strategy Replaceability)**

- **Given**: Mapping Generator が strategy パラメータを受け付ける
- **When**: strategy を "rank"、"lexical"、"score" のいずれかに切り替えてパイプラインを実行する
- **Then**: P1、P2、P3、P4、P5 はいずれの strategy においても成立する。strategy の変更はマッピングの具体的な番号付け結果に影響するが、システムの正確性・安定性には影響しない

---

## §7. 制約と今後の課題

**制約D1: 歯抜け番号問題**

提案手法では、マッピング M が事前に全 source に番号を割り当てるため、使用された source のみをソース一覧に表示した場合、番号列に空白が生じる可能性がある（例: `[1]`、`[3]` は本文中に出現したが `[2]` は未使用）。ユーザーに `[2]` が存在するはずだという印象を与えかねず、混乱を招く可能性がある。

この問題の対処として「使用された source のみを対象に、出現順または事前順序を保ちながら 1 から連番を振り直す」という後処理が考えられるが、それは即時変換（P2）に表示された番号を事後に変更することになり、P1（番号不変性）と矛盾する。したがって歯抜け番号はこのアーキテクチャにおける固有の限界として受け入れるか、代替として出現順即時割り当て（§3.3）と組み合わせた変形を採用する必要がある。

**制約D2: 正規表現マッチングの完全性**

LLMが出力する引用識別子の形式は多様であり、設計したパターンで完全に捕捉できる保証はない。特に多言語環境や、LLMのモデルバージョン変更によりプロンプト遵守度が変化した場合、マッチングが失敗する可能性がある。定期的なパターンの見直しとモニタリングが必要である。

**制約D3: チャンク境界での引用識別子分断**

ストリーミングではLLMの出力がトークン単位でチャンク化される。引用識別子（例: `[source_7]`）が複数チャンクにまたがって分断される場合（例: `[source_` と `7]` が別チャンク）、チャンク単位での処理では識別子を検出できない。この問題の解決には部分マッチ状態を保持するステートフルなバッファリングが必要であり、実装の複雑度が増す。

**今後の課題**

チャンク境界問題は実装上の重要課題であり、有限オートマトンに基づくストリームパーサーの設計が有効なアプローチである。また、提案手法の性能評価として、変換処理によるレイテンシ増加の実測値、および歯抜け番号がユーザー満足度に与える影響のユーザースタディが必要である。さらに、LLMが複数の異なる識別子形式で同一 source を参照するケース（`source_7` と `src-7` が同一文書を指す場合）の正規化戦略も未解決問題として残る。
