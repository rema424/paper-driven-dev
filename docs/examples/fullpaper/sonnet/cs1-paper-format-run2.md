# CS1 条件B: Paper Format — RAG引用リナンバリング (Run 2)

> **Run**: CS1-B-Run2
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

# RAGストリーミングシステムにおける引用番号割り当て問題の設計分析

## Abstract

Retrieval-Augmented Generation（RAG）システムにおいて、LLMがストリーミング生成する回答の引用番号をリアルタイムに表示しつつ、番号の一貫性を保証する問題は非自明な設計課題である。本稿では、この問題を「ストリーミング制約下でのオンライン引用マッピング問題」として定式化し、要件を満たす設計アーキテクチャを分析する。提案する設計は、初出順ハッシュマップ（First-Occurrence HashMap）を中核とし、ストリーミングテキストを逐次スキャンして引用識別子を検出した瞬間に確定的な番号を割り当てる。この手法により、番号の不変性と最終的なソース一覧との整合性を同時に達成できることを示す。

---

## 1. Introduction

RAGシステムは、外部知識ベースから検索した文書をLLMへのコンテキストとして注入することで、ハルシネーションを抑制しつつ回答の根拠を明示的にする技術である。LLMが生成するテキスト中には `(source_3)` や `[source_7]` といった識別子で引用が埋め込まれるが、ユーザーインターフェース上では `[1]`, `[2]`, `[3]` のような人間に読みやすい連番表記が求められる。

この変換を行うにあたり、ストリーミング配信という制約が設計を困難にする。ストリーミングでは、テキストが逐次的にチャンクとして到着し、全体が確定するのは配信完了時である。したがって以下の三つの要件が同時に成立することが求められる。

1. **リアルタイム表示**: ストリーミング中、ユーザーには引用番号が即時表示される
2. **番号の不変性**: 一度表示された番号は後から変更されない
3. **ソース一覧との整合性**: ストリーム完了時に表示されたすべての番号がソース一覧と対応している

本稿はこの三要件を同時に満たす設計を分析し、その正当性と実装上の考慮点を論じる。

---

## 2. 問題の定式化

### 2.1 入力と出力の定義

ストリーミングテキストを文字列のシーケンスとして定義する。

```
S = (c_1, c_2, ..., c_n)
```

ここで各 `c_i` はLLMが生成した文字チャンクである。テキスト中には引用識別子 `r_j`（例: `source_3`, `source_7`）がゼロ個以上含まれる。

出力は変換後のテキストストリームであり、識別子 `r_j` が連番 `[k]` に置換されていることが求められる。連番 `k` は初出順（first-occurrence order）で割り当てられる。

### 2.2 制約条件の形式化

**不変性制約**: テキスト位置 `t_1 < t_2` において識別子 `r_j` が初めて出現し番号 `k` が割り当てられたなら、それ以降のすべての位置での `r_j` の番号も `k` でなければならない。

**整合性制約**: ストリーム完了時のソース一覧 `L = {(r_j, k_j)}` は、テキスト中に出現したすべての識別子とその割り当て番号を含み、過不足がない。

**リアルタイム制約**: チャンク `c_i` を受信した時点で、`c_i` 以前に完成した識別子はすべて表示可能な状態でなければならない。

### 2.3 問題の本質

この問題の核心は、ストリームの将来を参照できないという「オンライン制約」の下で確定的な番号割り当てを行うことである。バッチ処理であれば全文解析後に番号割り当てが可能だが、リアルタイム表示要件がそれを排除する。

---

## 3. 設計アーキテクチャ

### 3.1 基本戦略: 初出順ハッシュマップ

問題の核心に対する解は単純である。引用番号は「全引用の中での重要度順」ではなく「テキスト中での初出順」で割り当てるという方針を採用する。これにより、識別子が初めて検出された瞬間に確定的な番号を付与でき、番号の不変性が自明に保証される。

```
citation_map: HashMap<SourceId, CitationNumber>
next_number: Integer = 1
```

識別子 `r` の処理：

```
function assign_citation(r):
    if r not in citation_map:
        citation_map[r] = next_number
        next_number += 1
    return citation_map[r]
```

この手続きは冪等かつ単調増加であり、同一識別子に対して常に同じ番号を返す。

### 3.2 ストリーミングパイプラインの構成

システム全体は以下の三層で構成される。

```
[LLM Stream] → [Citation Scanner] → [Renumbering Transformer] → [Client]
```

**Citation Scanner**: ストリーミングテキストを逐次スキャンし、引用識別子パターンを検出する。識別子は複数チャンクにまたがって到着する可能性があるため、不完全な識別子を一時バッファに保持する。

**Renumbering Transformer**: 完成した識別子を受け取り、`assign_citation` を呼び出して連番に置換したテキストを下流に流す。

**Citation Registry**: ストリーム完了時に `citation_map` の内容を整理し、番号順にソートしたソース一覧を生成する。

### 3.3 チャンク境界問題への対応

実装上の最大の難点は、識別子がチャンク境界で分断される問題である。例えば `source_7` が `sou` と `rce_7` の二チャンクで到着する場合、スキャナーはすぐに識別子を確定できない。

この問題への対応として、**先読みバッファ**を導入する。

```python
buffer: String = ""
PATTERN: Regex = /\[source_\d+\]/

function process_chunk(chunk):
    buffer += chunk
    loop:
        match = PATTERN.find_partial(buffer)
        if match is complete:
            emit(buffer[0:match.start])
            emit("[" + assign_citation(match.group) + "]")
            buffer = buffer[match.end:]
        elif match is prefix (potential start):
            emit(buffer[0:match.start])
            buffer = buffer[match.start:]  # 保留
            break
        else:
            emit(buffer)
            buffer = ""
            break

function on_stream_end():
    emit(buffer)  # 残余をそのまま流す（未完成識別子は変換しない）
    emit_source_list()
```

このアルゴリズムでは、識別子が完成した瞬間に変換して下流に流し、識別子の先頭部分が検出された場合はバッファに留保する。

### 3.4 ソース一覧の生成と整合性保証

ストリーム完了時、`citation_map` から以下の処理でソース一覧を生成する。

```
function emit_source_list():
    entries = citation_map.items()
    sorted_entries = sort_by_value(entries)  # 番号順ソート
    for (source_id, number) in sorted_entries:
        metadata = source_registry.lookup(source_id)
        emit_source_entry(number, metadata)
```

整合性は構造的に保証される。`citation_map` はテキスト中に実際に出現した識別子のみを含み（未使用ソースは含まれない）、かつテキスト中のすべての識別子が `assign_citation` を経由するため、ソース一覧とテキスト内の番号は必ず対応する。

---

## 4. 要件の充足性の分析

### 4.1 リアルタイム表示要件の充足

各チャンク受信時にバッファが更新され、完成した識別子は即座に変換・送出される。識別子の先頭部分のみが届いている場合の遅延は、その識別子が完成するまでに限定される。識別子の典型的な長さが数十文字以内であることを考慮すると、実用上の遅延は無視できる。

完全な識別子を含まないテキスト部分（地の文）はバッファリングなく即時送出されるため、ユーザーが体感するストリームの滑らかさは維持される。

### 4.2 番号の不変性の充足

`assign_citation` の実装において、既存エントリへの再割り当ては行われない。HashMap への挿入は初出時の一度のみであり、それ以降の同一識別子への呼び出しは既存値を返す。したがって、数学的帰納法により全識別子の番号が不変であることが示される。

**基底**: 最初の識別子 `r_1` は番号 `1` を割り当てられ、以降変更されない。

**帰納**: 識別子 `r_1, ..., r_k` すべてが不変番号を持つと仮定する。新規識別子 `r_{k+1}` が初出時に番号 `k+1` を割り当てられ、以降の出現では既存値 `k+1` が返される。既存識別子 `r_i (i ≤ k)` の番号も帰納仮定より変更されない。

### 4.3 整合性要件の充足

整合性は以下の二方向で保証される。

**テキスト → ソース一覧**: テキスト中で変換された番号 `[k]` は `assign_citation` の戻り値であり、`citation_map[r] = k` というエントリが必ず存在する。`emit_source_list` はこのエントリを漏れなく出力する。

**ソース一覧 → テキスト**: `citation_map` にエントリが作成されるのは `assign_citation` の実行時のみであり、`assign_citation` が呼ばれるのはテキスト中で識別子が検出された時のみである。したがってソース一覧に未出現の識別子が含まれることはない。

---

## 5. 実装上の考慮事項

### 5.1 正規表現パターンの設計

識別子パターンは、部分一致（prefix match）を検出できる必要がある。標準的な正規表現エンジンは通常のマッチのみをサポートするため、実装ではパターンの接頭辞集合を明示的に列挙するか、状態機械ベースのスキャナを使用することが望ましい。

```python
import re

FULL_PATTERN = re.compile(r'\[source_\d+\]')
PREFIX_PATTERN = re.compile(r'\[source_\d*$|\[source_$|\[sourc$|\[sour$|\[sou$|\[so$|\[s$|\[$')
```

### 5.2 並行性と順序保証

LLMストリームが複数のチャンクを並行配信する実装では、チャンクの到着順序を保証するキューが必要である。`Citation Scanner` はシングルスレッドで動作させ、チャンクを受信順に処理することで識別子の初出順序を正確に判定できる。

### 5.3 エラー処理

識別子パターンに一致するが実際にはソース一覧に存在しない識別子（例: `source_99`）への対応を設計しておく必要がある。選択肢として、(a) そのまま変換して無効ソースとしてマークする、(b) 変換をスキップしてエラーログに記録する、(c) プレースホルダーを表示する、の三方針が考えられる。ユーザー体験の観点からは (a) が推奨される。

### 5.4 フロントエンドとのプロトコル

バックエンドがクライアントに送信するデータには、変換済みテキストとともにソース一覧の差分情報をインクリメンタルに含めることを推奨する。

```json
{
  "delta": "これは [1] によると重要な発見です。",
  "new_citations": [{"number": 1, "source_id": "source_3", "title": "..."}]
}
```

これにより、フロントエンドはソース一覧をストリーム中に逐次表示でき、完了時の一括更新によるUI上のジャンプを回避できる。

---

## 6. 関連設計との比較

### 6.1 事後変換方式との比較

最も単純な代替案は、ストリーム完了後に全文を解析して番号を割り当てる事後変換方式である。この方式はリアルタイム表示要件を満たさず、ユーザーはストリーム完了まで引用情報を得られない。提案方式はこの欠点を解消する。

### 6.2 プレースホルダー方式との比較

ストリーミング中はプレースホルダー（例: `[?]`）を表示し、完了後に確定番号で置換する方式も考えられる。しかしこの方式は番号の不変性要件に違反する。プレースホルダーから確定番号への「変更」は、ユーザーが既読した文脈の意味を遡及的に変化させるため、UX上も好ましくない。

### 6.3 LLMへの番号指定との比較

LLMに対して「1番、2番と番号を使って引用せよ」と指示し、LLM自身に番号付きで出力させる方式は、番号の整合性をLLMの出力品質に依存させる。LLMは番号を誤る可能性があり、信頼性の面で提案方式より劣る。また、RAGシステムの検索結果が動的に変化する場合、LLMへのプロンプト設計が複雑化する。

---

## 7. Conclusion

本稿では、RAGシステムのストリーミング配信における引用番号割り当て問題を定式化し、初出順ハッシュマップを中核とした設計を分析した。提案設計は以下を達成する。

- リアルタイム表示: 先読みバッファにより識別子完成の瞬間に変換・送出
- 番号の不変性: HashMap の冪等な挿入操作により数学的に保証
- 整合性: 変換経路と一覧生成経路が同一のデータ構造を共有

設計の本質的な洞察は、「番号の確定性」を「全体の完了」ではなく「初出」に結びつけるという方針にある。この方針採用により、ストリーミングとバッチ処理の間に存在していた見かけ上のトレードオフが消滅する。実装においては、チャンク境界での識別子分断への対応と、フロントエンドへのインクリメンタルなソース差分配信が主要な工学的課題となる。

---

## References

1. Lewis, P., et al. (2020). Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks. *Advances in Neural Information Processing Systems*, 33, 9459-9474.
2. Shi, W., et al. (2023). REPLUG: Retrieval-Augmented Black-Box Language Models. *arXiv preprint arXiv:2301.12652*.
3. Gao, Y., et al. (2023). Retrieval-Augmented Generation for Large Language Models: A Survey. *arXiv preprint arXiv:2312.10997*.
4. Knuth, D. E. (1997). *The Art of Computer Programming, Volume 3: Sorting and Searching* (2nd ed.). Addison-Wesley.
5. Cormen, T. H., et al. (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.
