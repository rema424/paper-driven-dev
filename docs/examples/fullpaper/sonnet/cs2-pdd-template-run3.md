# CS2 条件C: PDD Template — マルチテナントSaaSセッション管理 (Run 3)

> **Run**: CS2-C-Run3
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

# マルチテナントSaaSにおけるセッション管理システムの設計

## §1. 問題定義

### §1.1 背景

現代のSaaS（Software as a Service）プラットフォームは、複数の組織（テナント）が同一のインフラストラクチャを共有するマルチテナントアーキテクチャを採用することが多い。このアーキテクチャにおけるセッション管理は、単一テナント環境とは質的に異なる複雑性を持つ。

セッション管理の責務は大きく三つに分類される。第一に、ユーザーの認証状態を継続的に維持すること。第二に、不正アクセスや異常なセッション動作を検出・排除すること。第三に、テナント間のセッション情報の完全な分離を保証すること。

従来のWebアプリケーションにおけるセッション管理は、スティッキーセッション（特定のサーバーにリクエストをルーティングする手法）または集中型セッションストア（全サーバーが参照する共有データベース）のいずれかで実現されてきた。しかし、クラウドネイティブなSaaS環境では、オートスケーリングや地理分散配置が標準的になり、これらの従来手法は機能的・性能的な限界に直面している。

さらに、コンプライアンス要件（GDPR、SOC 2、ISO 27001等）やゼロトラストセキュリティモデルの普及により、セッションの即時無効化能力（リアルタイムの強制ログアウト）が法的・規制的要件として求められるケースが増加している。例えば、従業員が退職した瞬間に管理者がそのアカウントの全セッションを無効化できることは、情報セキュリティポリシーの核心となっている。

### §1.2 矛盾する要求（対立するトレードオフ）

本問題には、構造的に対立する複数のトレードオフが存在する。

**トレードオフ1: 認証レイテンシの最小化 vs. セッション即時無効化の保証**

認証レイテンシを最小化する最も効果的な手法は、JWTのようなステートレストークンを用いることである。JWTは発行時にすべての認証情報をトークン内に自己完結させ、各リクエストの認証時にデータストアへの問い合わせを不要にする。しかしこの手法は、トークンの失効管理を本質的に困難にする。JWTは有効期限まで暗号学的に有効であり、サーバー側のデータを変更してもトークン自体の有効性は失われない。管理者がセッションを即時無効化したくとも、発行済みJWTはその有効期限まで機能し続ける。

逆に、セッション即時無効化を保証するためにサーバー側でセッション状態を管理し、各リクエストでその状態を参照する手法は、リクエストごとのデータベース問い合わせを必須とし、認証レイテンシを増大させる。

この二つの要件は、アーキテクチャレベルで根本的に対立する。

**トレードオフ2: 水平スケーラビリティ vs. セッション状態の一貫性**

水平スケーリングは、サーバー群が共有状態を持たないステートレスな設計を前提とする。各サーバーインスタンスがリクエストを独立して処理できることで、サーバー台数の増減が可能になる。しかし、セッション管理は本質的に状態（どのセッションが有効か、いつ無効化されたか）を必要とする。

複数サーバー間でセッション状態を共有するためには集中型ストレージが必要になるが、これは水平スケーリングのボトルネックとなり得る。また、分散環境における一貫性の保証（CAP定理における整合性）は、可用性やパーティション耐性とのトレードオフを生む。ネットワーク分断が発生した際に、セッション無効化の情報が全サーバーに伝播しない可能性がある。

**トレードオフ3: 複数端末の同時ログインサポート vs. セキュリティ管理の複雑性**

複数端末からの同時ログインを許可することは、ユーザビリティの観点から重要である。しかし、これはセッションを1対1（ユーザー対セッション）ではなく1対多（ユーザー対セッション群）の関係として管理することを意味する。この複雑性は、不正アクセスの検出、セッション管理のデータ構造、無効化操作の伝播範囲など、セキュリティ管理のあらゆる側面を複雑にする。特定のデバイスのセッションのみを無効化する操作と、ユーザーの全セッションを無効化する操作を区別して実装する必要があり、その操作の即時性の保証が求められる。

### §1.3 本文書の範囲

本文書は、上記の対立する要求を同時に満足するマルチテナントSaaSセッション管理システムの設計を対象とする。具体的には以下を扱う。

- 同一ユーザーの複数端末からの同時セッション管理
- 管理者による特定ユーザーセッションの即時無効化機構
- 水平スケーリングに対応するステートレス認証基盤
- リクエスト認証レイテンシの最小化手法

本文書の範囲外とするものを以下に列挙する。OAuth2/OIDCなどの外部認証プロバイダとの統合詳細、テナントのプロビジョニングと削除ライフサイクル、セッション管理以外の認可（Authorization）機構、および具体的なインフラストラクチャの選定（特定のクラウドプロバイダや製品の推奨）は本文書では扱わない。

---

## §2. 現状のアーキテクチャと制約

多くのSaaSプラットフォームが採用する典型的なセッション管理アーキテクチャを以下に示す。

**典型的な現状構成**

大多数の既存SaaSシステムは、以下のいずれかまたはその組み合わせを採用している。

第一の構成は「スティッキーセッション + サーバー内メモリ」である。ロードバランサーがCookieまたはIPアドレスに基づき、特定ユーザーのリクエストを常に同一サーバーへルーティングする。セッション情報はサーバーのメモリ内に保持される。この構成は実装が単純であるが、サーバーの追加・削除時にセッションが失われる問題がある。また、特定サーバーへの負荷集中が発生しやすく、真の水平スケーリングが困難である。

第二の構成は「集中型セッションストア（RedisやMemcached）」である。全サーバーが共有のインメモリデータストアにセッション情報を格納・参照する。スティッキーセッションの問題は解消されるが、セッションストアが単一障害点となる。またセッションストアへのネットワーク往復が各リクエストの認証に加算される。

第三の構成は「ステートレスJWT」である。セッション情報をトークンに埋め込み、サーバー側での状態管理を排除する。スケーラビリティは高いが、前述の通りセッション即時無効化が困難である。

**現状の制約の整理**

既存システムが抱える制約を整理すると以下のようになる。セッション無効化のレイテンシ（管理者操作からユーザーのリクエスト拒否まで）は、多くのシステムでトークン有効期限（5分〜60分）と一致しており、即時性が保証されない。また、水平スケーリング時のセッション一貫性維持コストが認証レイテンシを増大させ、SLAとの競合が生じる。マルチテナント環境では、テナントをまたいだセッション分離の保証が実装レベルで複雑になり、バグの温床となっている。

---

## §3. 既存アプローチとその限界

### §3.1 アプローチ1: ブラックリスト型JWTトークン管理

**手法**

ステートレスJWTを基本とし、無効化が必要なトークンのIDをブラックリストとして集中ストア（Redis等）に保持する。各リクエスト認証時に、トークンの署名検証に加えてブラックリストの照合を行う。無効化対象のトークンIDをブラックリストに追加することで、即時無効化を実現する。

**利点**

通常時（ブラックリストに該当しない場合）のオーバーヘッドは、Redisへの単純なキー照合のみである。Redisのインメモリ操作は1ミリ秒未満で完了するため、認証レイテンシへの影響は最小限に抑えられる。JWTの自己完結性を活かしつつ、即時無効化能力を付加できる。

**限界**

ブラックリストのサイズ管理が課題となる。有効期限切れのトークンIDを定期的に削除する必要があり、この管理コストが増大する。また、ユーザー全セッションの無効化操作では、そのユーザーの全アクティブトークンIDをブラックリストに追加する必要があり、端末数が多い場合に操作の複雑性が増す。さらに、Redisへの依存によりRedisが単一障害点となる。Redisがダウンするとブラックリストへのアクセスが不可能となり、フェイルクローズ（全認証を拒否）かフェイルオープン（ブラックリストを無視して認証を通過）かの設計判断が必要になる。フェイルオープン設計は、無効化されたはずのセッションが有効と見なされるセキュリティリスクを生む。

### §3.2 アプローチ2: 短命JWTとリフレッシュトークンの組み合わせ

**手法**

アクセストークン（JWT）の有効期限を極めて短く設定（例：5分）し、長命のリフレッシュトークンと組み合わせる。リフレッシュトークンはサーバー側で管理され、新しいアクセストークンの発行に使用される。セッション無効化時はリフレッシュトークンをサーバー側で削除し、以降の新規アクセストークン発行を阻止する。

**利点**

アクセストークンがステートレスであるため、通常の認証リクエストはデータストアへの問い合わせ不要で完了する。リフレッシュトークンの管理はトークンリフレッシュ時（5分ごと）のみに限定されるため、データストアへのアクセス頻度を大幅に削減できる。OAuth2仕様に沿った実装であり、標準的なライブラリやフレームワークのサポートが充実している。

**限界**

セッション無効化後も最大でアクセストークンの有効期限（5分等）の間、無効化されたセッションでのアクセスが継続可能である。コンプライアンス要件として「即時無効化」が求められる環境では、この猶予時間が許容されない可能性がある。有効期限を1分以下に短縮するとリフレッシュ頻度が増加し、リフレッシュエンドポイントへの負荷とユーザー体験（リフレッシュ失敗時のログアウト）が問題となる。

### §3.3 アプローチ3: サーバーサイドセッション + 分散キャッシュ

**手法**

セッション情報をすべてサーバーサイドのキャッシュ層（RedisクラスターやMemcached等）に格納する。クライアントにはセッションIDのみをCookieで渡し、各リクエストでキャッシュからセッション情報を取得して認証を行う。セッション無効化はキャッシュエントリの削除で即座に実現される。

**利点**

セッション無効化の即時性が保証される。キャッシュエントリの削除後、次のリクエストからセッションIDに対応するセッション情報が取得できなくなるため、事実上の即時無効化が実現する。複数端末のセッション管理も、ユーザーIDと複数のセッションIDのマッピングをキャッシュに持つことで自然に実現できる。

**限界**

すべてのリクエスト認証でキャッシュ層への問い合わせが発生するため、認証レイテンシがキャッシュのネットワーク往復時間（典型的に1〜5ミリ秒）に依存する。キャッシュ層の可用性がシステム全体の可用性を規定する。また、キャッシュクラスターの水平スケーリング時のデータ再分散（リシャーディング）が複雑であり、その間のセッション一貫性が保証されない場合がある。

### §3.4 アプローチ4: トークン世代管理（Token Generation Versioning）

**手法**

ユーザーごとにトークン世代番号（generation number）をサーバー側で管理する。JWTにこの世代番号を埋め込んで発行し、認証時にサーバー側の世代番号と照合する。セッション無効化時はサーバー側の世代番号をインクリメントするのみでよく、すべての旧世代トークンが即座に無効となる。

**利点**

ブラックリスト型と異なり、無効化情報のサイズが一定（ユーザーあたり1つの数値）であるため、ブラックリストの肥大化問題が存在しない。全端末の一括無効化が単一の書き込み操作で完了する。

**限界**

各リクエストでユーザーの世代番号をデータストアから取得する必要があり、データストアへのアクセスが必須となる。この点でサーバーサイドセッションと同様のレイテンシ問題を抱える。また、特定端末のセッションのみを無効化する（他の端末は継続）という細粒度の無効化が困難である。世代番号をインクリメントすると、そのユーザーの全セッションが無効になるため、デバイス選択的な無効化には追加の仕組みが必要となる。

---

## §4. 問題の本質

上記の分析から、問題の本質は「状態の在り処」と「状態参照のタイミング」のトレードオフであることが明確になる。

**状態のジレンマ**

認証の速度はセッション状態をサーバー側で参照しないことで最大化される（JWTによるステートレス認証）。セッションの即時無効化はサーバー側でセッション状態を権威ある情報源として管理することで実現される。この二つは同時に最大化できない。どちらか一方を優先すれば、もう一方が劣化する。

既存アプローチのいずれも、この本質的なトレードオフを完全に解消していない。ブラックリスト型とサーバーサイドセッションはアーキテクチャ的には異なるが、「リクエストごとにデータストアへ問い合わせる」という点で本質的に同じ問題（レイテンシの増加と可用性への依存）を抱える。短命JWTは「問い合わせ頻度を下げることでレイテンシとデータストア依存を軽減する」という妥協策であるが、即時性の保証を諦めている。

**マルチテナント固有の複雑性**

マルチテナント環境では、この基本的なトレードオフに加えて、テナント間の完全な分離保証という制約が加わる。セッション無効化の伝播や世代管理においてテナント境界を越えた操作が発生しないことを、アーキテクチャレベルで保証する必要がある。

**問題の再定式化**

問題を「すべての要件を同時に最大化する」という形で設定すると解が存在しない。問題を「即時無効化の保証と許容可能なレイテンシ（ミリ秒オーダー）の両立」と再定式化することで、工学的に実現可能な解の空間が開ける。キャッシュの戦略的配置と更新プロトコルの設計により、この再定式化された問題に対処できる。

---

## §5. 提案手法

### §5.1 基本原理

提案手法は「**ハイブリッドトークン + 階層型キャッシュ + 世代管理**」の組み合わせを基本原理とする。

**原理1: トークンの責務の分離**

クライアントに発行するトークンを二層に分離する。「認証アサーション層」（JWTによるステートレスな署名検証）と「無効化可能性層」（サーバー側で管理される世代番号と端末固有のセッションID）である。認証アサーション層はサーバー側状態への問い合わせなしに有効性を検証できる。無効化可能性層はサーバー側の状態変更を権威ある情報源として参照する。

**原理2: 段階的一貫性モデル**

リクエストの分類に基づき、セッション状態の参照戦略を切り替える。読み取り専用の参照系リクエストはローカルキャッシュ（各サーバーのプロセス内メモリ）を参照し、データストアへの問い合わせを回避する。書き込みや権限昇格を伴うリクエストは分散キャッシュを必ず参照し、最新の無効化状態を確認する。この分類により、大多数のリクエストの認証レイテンシを最小化しつつ、セキュリティ上重要な操作については即時性を保証する。

**原理3: プッシュ型無効化伝播**

管理者がセッション無効化を実行した時点で、その情報をすべての関連サーバーへ能動的にプッシュする。ポーリング型（各サーバーが定期的にデータストアを確認）やキャッシュTTL依存型（TTL切れるまで古い情報を使用）ではなく、無効化イベントが発生した時点で即座に全サーバーの状態を更新する。

### §5.2 実装アーキテクチャ

**コンポーネント構成**

提案アーキテクチャは以下のコンポーネントで構成される。

*セッショントークン*

クライアントに発行するトークンは以下の情報を含むJWTとする。

```
{
  "sub": "<user_id>",
  "tid": "<tenant_id>",
  "sid": "<session_id>",        // 端末固有のセッションID（UUID）
  "gen": <generation_number>,   // 発行時のユーザー世代番号
  "iat": <issued_at>,
  "exp": <expiry>,              // 短命: 5分
  "jti": "<jwt_id>"             // JWTの一意識別子
}
```

セッションIDは端末ごとに一意であり、特定端末のセッション無効化を可能にする。世代番号は全端末一括無効化に使用する。

*セッション状態ストア（Redis クラスター）*

以下のデータ構造をRedisに格納する。

```
# ユーザーの現在の世代番号
key: "session:gen:{tenant_id}:{user_id}"
value: <integer>
ttl: (ユーザーが非アクティブになるまでの期間)

# アクティブなセッションの一覧（ユーザーの全端末）
key: "session:active:{tenant_id}:{user_id}"
value: Set of <session_id>
ttl: (ユーザーが非アクティブになるまでの期間)

# セッション固有のメタデータ
key: "session:meta:{tenant_id}:{session_id}"
value: {device_info, created_at, last_seen, ...}
ttl: セッションの最大有効期間
```

テナントIDをすべてのキーに含めることで、テナント間のデータ混在をキー構造レベルで防止する。

*プロセス内キャッシュ（各APIサーバー）*

各APIサーバーは、直近に認証したセッションの無効化状態をプロセス内メモリにキャッシュする。このキャッシュのTTLはアクセストークンの有効期限（5分）より短く設定する（例：30秒）。

*無効化イベントバス*

管理者によるセッション無効化操作は、Redis Pub/Subまたはメッセージキュー（Apache Kafka等）を経由して全APIサーバーへプッシュ配信される。各APIサーバーはサブスクライバーとして無効化イベントを受信し、プロセス内キャッシュを即座に更新する。

**認証フロー**

リクエスト受信時の認証処理を以下に示す。

```
1. JWTの署名検証（公開鍵による暗号学的検証）
   → 失敗: 401 Unauthorized

2. プロセス内キャッシュを確認
   2a. セッションIDまたは世代番号の無効化情報がキャッシュにある
       → 即座に 401 Unauthorized
   2b. キャッシュに情報なし（キャッシュミス）
       → ステップ3へ

3. リクエスト種別の判定
   3a. 書き込み/権限昇格リクエスト
       → Redisから最新の世代番号とセッション有効性を取得
       → JWTの世代番号とRedisの世代番号を比較
       → セッションIDがactiveセットに存在するか確認
       → 検証結果をプロセス内キャッシュに格納（TTL: 30秒）
   3b. 読み取り専用リクエスト
       → Redisへの問い合わせをスキップ
       → アクセストークンの有効期限（5分以内）を信頼

4. 認証成功: リクエスト処理を継続
```

このフローにより、読み取り専用リクエストの大多数は追加のネットワーク往復なしに認証が完了する。書き込みリクエストは1回のRedis問い合わせを必要とするが、その結果を30秒間キャッシュすることで後続のリクエストへの影響を抑制する。

**無効化フロー**

管理者による無効化操作の処理を以下に示す。

```
特定セッションの無効化（特定端末のログアウト）:
1. Redisのactiveセットから対象セッションIDを削除
2. セッションメタデータを削除
3. 無効化イベントをPub/Subで全サーバーへブロードキャスト
   イベント形式: { "type": "session_invalidated",
                   "tenant_id": ..., "session_id": ... }

ユーザー全セッションの無効化（全端末のログアウト）:
1. Redisの世代番号をインクリメント（atomic INCREMENT操作）
2. activeセットをクリア
3. 無効化イベントをPub/Subで全サーバーへブロードキャスト
   イベント形式: { "type": "generation_invalidated",
                   "tenant_id": ..., "user_id": ..., "new_gen": ... }
```

各APIサーバーはイベントを受信し、プロセス内キャッシュに無効化情報を即座に追記する。以降、そのセッションIDまたは旧世代のトークンを持つリクエストはステップ2aで拒否される。

**水平スケーリングの考慮**

新規サーバーインスタンスの起動時、そのサーバーのプロセス内キャッシュは空である。初期状態では全リクエストがキャッシュミスとなり、書き込みリクエストと同等の処理（Redis問い合わせ）が行われる。時間の経過とともにキャッシュがウォームアップし、読み取り専用リクエストのRedis問い合わせが減少する。この「コールドスタート」期間はキャッシュTTL（30秒）以内に収束する。

---

## §6. 検証可能な性質

提案手法の正確性と性能を検証するための具体的なシナリオをGiven/When/Then形式で定義する。

**性質1: 単一セッションの即時無効化**

```
Given: ユーザーUがデバイスDでログイン済みのアクティブなセッションSを持つ
       かつ セッションSのアクセストークンTが有効期限内である
When:  管理者がセッションSを無効化する操作を実行する
       かつ その後1秒以内に デバイスDがトークンTを使って書き込みリクエストを送信する
Then:  サーバーはHTTP 401 Unauthorizedを返す
       かつ 無効化イベントがすべてのAPIサーバーに伝播している
```

**性質2: 世代番号による全セッション一括無効化**

```
Given: ユーザーUがデバイスD1、D2、D3からそれぞれ異なるセッションでログイン中である
When:  管理者がユーザーUの全セッションを無効化する操作を実行する
       かつ その後1秒以内に D1、D2、D3がそれぞれリクエストを送信する
Then:  3つのリクエストがすべてHTTP 401 Unauthorizedで拒否される
       かつ 世代番号が無効化前より1以上大きい値になっている
```

**性質3: 読み取り専用リクエストの低レイテンシ認証**

```
Given: アクティブなセッションSがウォームな状態のAPIサーバーAで処理された実績がある
When:  そのセッションSで読み取り専用リクエストがサーバーAに届く
Then:  サーバーAはRedisへのネットワーク往復なしにリクエストを認証する
       かつ 認証レイテンシが5ミリ秒未満である（P99）
```

**性質4: テナント分離の保証**

```
Given: テナントT1のユーザーU1がアクティブなセッションS1を持つ
       かつ テナントT2の管理者が全ユーザーの無効化操作を実行する
When:  ユーザーU1がセッションS1でリクエストを送信する
Then:  サーバーはリクエストを正常に処理する（200 OK）
       かつ テナントT2の無効化操作がテナントT1のセッションに影響しない
```

**性質5: 新規サーバー追加時のセッション継続性**

```
Given: ユーザーUがセッションSを持ち、既存サーバー群で正常に認証されている
When:  新規APIサーバーインスタンスNが追加され、ユーザーUのリクエストがNに到達する
Then:  Nはセッションをプロセス内キャッシュなしで正常に認証する（Redisを参照）
       かつ セッションSが有効であることが確認される
       かつ 以降のリクエストはNのプロセス内キャッシュを活用して低レイテンシで処理される
```

**性質6: Redisダウン時のフェイルセーフ動作**

```
Given: Redisクラスターが一時的に利用不能な状態になる
When:  APIサーバーがセッション認証リクエストを受信する
Then:  書き込みリクエストはHTTP 503 Service Unavailableを返す（フェイルクローズ）
       かつ 読み取り専用リクエストはプロセス内キャッシュのTTL内であれば処理を継続する
       かつ エラーログにRedis接続失敗が記録される
```

---

## §7. 制約と今後の課題

**実装上の制約**

提案手法はRedis Pub/Subに依存しており、Pub/Subメッセージの配信保証は「at-most-once」である。ネットワーク瞬断等によりイベントが一部のサーバーに届かなかった場合、そのサーバーのプロセス内キャッシュが無効化情報を受け取れない可能性がある。この場合、最大でプロセス内キャッシュのTTL（30秒）の間、無効化されたセッションが有効と見なされるリスクがある。信頼性要件が高い環境では、Pub/SubをKafkaのような「at-least-once」配信保証を持つシステムに置き換えることが望ましいが、インフラコストと運用複雑性が増大する。

プロセス内キャッシュはJVMやNode.jsのヒープメモリを消費する。アクティブセッション数が大きいシステムでは、キャッシュエントリ数の上限管理（LRU等のエビクションポリシー）が必要になる。上限を超えてエビクションが発生した場合、エビクトされたエントリへのアクセスはRedisへの問い合わせにフォールバックするため、性能の予測可能性が低下する。

**スケーリングの制約**

テナント数とユーザー数が増大した場合、RedisのPub/Subチャネル数とメッセージレートが限界に達する可能性がある。テナントごとに分離したRedisクラスターを割り当てるシャーディング戦略が必要になるが、これは運用管理コストを大幅に増加させる。

**今後の課題**

第一の課題は、プロセス内キャッシュの一貫性検証機構の構築である。定期的にプロセス内キャッシュの状態とRedisの状態を照合し、乖離が生じていないかを監視する仕組みが必要である。特に無効化イベントの配信漏れを検出する機構は未解決のままである。

第二の課題は、地理分散配置への対応である。複数のリージョン（例：US-EastとEU-West）にAPIサーバーが分散配置される場合、リージョン間のRedis Pub/Subイベント伝播にネットワーク遅延（数十〜数百ミリ秒）が加わる。この遅延の間に別リージョンのサーバーが旧状態でリクエストを処理する可能性があり、地理分散を考慮した一貫性モデルの再設計が求められる。

第三の課題は、セッション管理とゼロトラストアーキテクチャの統合である。提案手法はネットワーク境界を信頼する前提（APIサーバーからRedisへの内部通信の安全性）に立脚している。ゼロトラスト環境では、サービス間通信の認証・暗号化の追加要件が発生し、レイテンシへの影響を再評価する必要がある。

第四の課題は、監査ログとコンプライアンスへの対応である。GDPR等の規制では、セッション無効化操作の監査証跡（いつ、誰が、どのセッションを無効化したか）の記録が求められる。この監査ログの信頼性と改ざん耐性を保証する仕組みは、提案アーキテクチャに付加的に設計する必要がある。

---

*本文書は Paper-Driven Development (PDD) 手法に基づき生成された技術設計提案書である。提案内容は実装前に性能測定と負荷試験によって検証されるべき仮説を含んでいる。*
