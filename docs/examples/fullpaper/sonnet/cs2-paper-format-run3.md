# CS2 条件B: Paper Format — マルチテナントSaaSセッション管理 (Run 3)

> **Run**: CS2-B-Run3
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

# マルチテナントSaaSにおける分散セッション管理アーキテクチャの設計と評価

## Abstract

マルチテナントSaaS環境において、セッション管理システムは複数の相反する要件を同時に満たす必要がある。本稿では、同一ユーザーの複数端末からの同時ログイン、管理者による即時セッション無効化、水平スケーラビリティ、および低レイテンシ認証という四つの主要要件を全て充足するアーキテクチャを提案する。具体的には、JWT（JSON Web Token）とRedisベースの集中型セッションストアを組み合わせたハイブリッドアプローチを採用し、短命トークンと即時無効化機構を両立させる設計を提示する。提案手法は、各要件間のトレードオフを明示的に管理しながら、実運用に耐えうる一貫したセッション管理体系を実現する。

**キーワード**: セッション管理、マルチテナント、JWT、分散システム、水平スケーリング、セキュリティ

---

## 1. 序論

現代のSaaS（Software as a Service）プラットフォームは、複数の企業テナントに対してサービスを提供する構造上、セッション管理に固有の複雑性を伴う。単一テナント環境では局所的に解決可能であった課題が、マルチテナント環境では全テナントに影響を及ぼすシステム設計上の問題となる。

特に以下の四要件は、それぞれ単独では比較的容易に実現できるが、同時に充足しようとすると設計上の根本的なトレードオフが生じる。

1. **多端末同時ログイン**: 同一ユーザーが複数のデバイスから独立したセッションを持てること
2. **管理者による即時無効化**: 特定ユーザーのセッションを遅延なく失効させられること
3. **水平スケーラビリティ**: サーバーインスタンスの増減に対してシステムが線形にスケールすること
4. **低レイテンシ認証**: 各リクエストの認証処理がシステム全体のパフォーマンスボトルネックとならないこと

本稿の構成は以下の通りである。第2節で関連研究および既存アプローチの整理を行い、第3節で設計上のトレードオフを分析する。第4節で提案アーキテクチャの詳細を述べ、第5節で実装上の考慮事項を議論する。第6節でセキュリティ上の留意点を検討し、第7節で結論を述べる。

---

## 2. 関連研究および既存アプローチ

### 2.1 ステートフルセッション管理

従来のWebアプリケーションにおけるセッション管理は、サーバー側にセッション状態を保持するステートフルモデルが主流であった。この手法では、クライアントはセッションIDのみを保持し、セッションデータはサーバー側のメモリまたはデータベースに格納される。

ステートフルモデルの利点は、セッションの即時無効化が容易な点にある。サーバー側のセッションエントリを削除または無効化フラグを設定するだけで、以降のリクエストは全て拒否される。しかし水平スケーリングの観点では、スティッキーセッション（特定サーバーへのリクエスト固定）またはセッションレプリケーションが必要となり、スケーラビリティを制限する要因となる。

### 2.2 ステートレスセッション管理とJWT

JWT（RFC 7519）に代表されるステートレスアプローチは、セッション情報全体をトークンに埋め込み、サーバー側の状態を排除する手法である。サーバーはトークンの署名を検証するだけで認証が完了するため、水平スケーリングと低レイテンシ認証の観点で優れた特性を示す。

しかしJWTの根本的な問題は、発行済みトークンの即時無効化が困難な点にある。トークンは有効期限（exp クレーム）まで有効であるため、管理者がユーザーのアクセスを遮断しようとしても、既発行トークンが失効するまで待たなければならない。短い有効期限を設定することでこの問題を緩和できるが、頻繁なトークン更新によってシステム負荷が増加し、ユーザー体験も低下する。

### 2.3 ハイブリッドアプローチ

近年では、JWTの利点（ステートレス性）を維持しつつ、補助的なストレージ機構を用いて即時無効化を実現するハイブリッドアプローチが注目されている。Auth0、Okta等の主要なIdentity Providerも類似のアーキテクチャを採用している。

---

## 3. 設計上のトレードオフ分析

### 3.1 要件間の相互依存関係

四要件の間には以下の構造的なトレードオフが存在する。

**表1: 要件間のトレードオフマトリクス**

| | 多端末同時ログイン | 即時無効化 | 水平スケーリング | 低レイテンシ |
|---|---|---|---|---|
| 多端末同時ログイン | — | 複雑化（セッション粒度の管理） | 中立 | 中立 |
| 即時無効化 | 複雑化 | — | 集中ストアが必要 | I/Oオーバーヘッド |
| 水平スケーリング | 中立 | 集中ストアが必要 | — | キャッシュが有効 |
| 低レイテンシ | 中立 | I/Oオーバーヘッド | キャッシュが有効 | — |

最も根本的なトレードオフは「即時無効化」と「低レイテンシ」の間に存在する。即時無効化を実現するには各リクエスト時に集中ストアを照会する必要があるが、これはレイテンシを増加させる。逆に純粋なJWTによる低レイテンシ認証は即時無効化と両立しない。

### 3.2 トレードオフの解決方針

このトレードオフを解決する基本方針として、**短命なJWT + 高速キャッシュによる無効化チェック**という組み合わせを採用する。具体的には、JWTの有効期限を短く（例: 15分）設定し、その期間内であっても無効化リストとのチェックをキャッシュを介して行うことで、セキュリティとパフォーマンスを両立させる。

---

## 4. 提案アーキテクチャ

### 4.1 全体構成

提案するアーキテクチャは以下のコンポーネントから構成される。

```
┌─────────────────────────────────────────────────────────────┐
│                        クライアント層                         │
│  ブラウザ/モバイルアプリ（各デバイスにAccess Token + Refresh Token） │
└─────────────────────────┬───────────────────────────────────┘
                          │ HTTPS
┌─────────────────────────▼───────────────────────────────────┐
│                      APIゲートウェイ層                        │
│        認証ミドルウェア（JWT検証 + 無効化チェック）              │
└────────┬───────────────────────────────────┬────────────────┘
         │                                   │
┌────────▼────────┐               ┌──────────▼──────────┐
│   Redisクラスタ  │               │  アプリケーションサーバ  │
│（セッションストア）│               │ （水平スケール可能）     │
└─────────────────┘               └──────────────────────┘
         │                                   │
┌────────▼───────────────────────────────────▼────────────────┐
│                   永続化データベース                           │
│              （ユーザー、テナント、監査ログ）                   │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 トークン設計

#### 4.2.1 アクセストークン（Access Token）

アクセストークンはJWT形式を採用し、以下のクレームを含む。

```json
{
  "iss": "https://auth.example.com",
  "sub": "user_id_12345",
  "tid": "tenant_id_abc",
  "sid": "session_id_xyz",
  "did": "device_id_def",
  "exp": 1708000000,
  "iat": 1707999100,
  "jti": "unique_token_id"
}
```

| クレーム | 意味 | 用途 |
|---|---|---|
| `sub` | ユーザーID | ユーザー識別 |
| `tid` | テナントID | マルチテナント分離 |
| `sid` | セッションID | セッション単位の無効化 |
| `did` | デバイスID | 端末単位の管理 |
| `jti` | JWT固有ID | 個別トークンの追跡 |

有効期限（`exp`）は15分に設定する。この値は、セキュリティリスク（流出時の被害窓口）とシステム負荷（更新頻度）のバランスを考慮した実用的な選択である。

#### 4.2.2 リフレッシュトークン（Refresh Token）

リフレッシュトークンはJWT形式ではなく、不透明な（opaque）ランダム文字列とする。この選択の理由は以下の通りである。

- リフレッシュトークンはサーバー側で必ず検証するため、ステートレス性の利点が不要
- JWTにすると有効期限情報がクライアントに露出し、攻撃者に情報を与える
- 不透明な文字列であれば、サーバー側で完全な制御が可能

リフレッシュトークンの有効期限は14日間とし、Redisに以下の形式で格納する。

```
Key:   refresh:{tenant_id}:{user_id}:{session_id}:{device_id}
Value: {
         "token_hash": "sha256_of_refresh_token",
         "issued_at": "2026-02-22T10:00:00Z",
         "expires_at": "2026-03-08T10:00:00Z",
         "last_used":  "2026-02-22T10:00:00Z"
       }
TTL:   14日
```

### 4.3 セッション管理構造

#### 4.3.1 多端末同時ログインの実現

各デバイスのセッションを独立して管理するため、以下のキー構造を採用する。

```
# ユーザーのアクティブセッション一覧
Key: sessions:{tenant_id}:{user_id}
Type: Redis Set
Members: session_id_1, session_id_2, session_id_3, ...

# 個別セッションの詳細
Key: session:{tenant_id}:{session_id}
Type: Redis Hash
Fields:
  user_id:     "user_id_12345"
  device_id:   "device_id_def"
  device_name: "MacBook Pro (Chrome)"
  created_at:  "2026-02-22T10:00:00Z"
  last_seen:   "2026-02-22T10:05:00Z"
  status:      "active" | "revoked"
TTL: 14日（リフレッシュトークンと同期）
```

この構造により、「ユーザーのセッション一覧取得」「特定セッションの詳細確認」「セッションの追加・削除」が独立して効率的に実行できる。

#### 4.3.2 即時セッション無効化の実現

管理者がセッションを無効化する操作は以下のフローで実行される。

```
管理者操作:
  1. Admin API: DELETE /admin/sessions/{tenant_id}/{user_id}
     （ユーザーの全セッション無効化）
  または
     DELETE /admin/sessions/{tenant_id}/{session_id}
     （特定セッションの無効化）

サーバー側処理:
  2. Redisの対象セッションの status を "revoked" に変更
  3. 対象のリフレッシュトークンエントリを削除
  4. 無効化リストに session_id を追加（アクセストークンの残余期間だけ保持）
  5. 監査ログに記録

クライアントへの伝達:
  6. 次のリクエスト時にアクセストークンの無効化チェックで検出
  7. 最大15分後（アクセストークン有効期限）に確実に排除
```

**無効化リスト（Revocation List）の設計**:

```
Key:   revoked:{tenant_id}:{session_id}
Value: "revoked_at" タイムスタンプ
TTL:   アクセストークンの最大有効期限（15分）
```

このTTL設定が重要である。アクセストークンが失効した後は、そのsession_idのトークンは自動的に認証に失敗する（expクレームによって）。よって無効化リストの保持期間もアクセストークンの有効期限に合わせることで、ストレージの肥大化を防ぐ。

### 4.4 認証フロー

#### 4.4.1 通常リクエストの認証（低レイテンシ設計）

```
クライアント → APIゲートウェイ（Bearerトークン付き）

ゲートウェイの処理:
  Step 1: JWT署名検証（インメモリ、公開鍵キャッシュ）
          所要時間: ~1ms

  Step 2: JWTクレームの検証（exp, iss, tid等）
          所要時間: ~0.1ms

  Step 3: 無効化チェック（Redis EXIST）
          Key: revoked:{tid}:{sid}
          所要時間: ~1-2ms（ローカルRedis）

  Step 4: 認証成功 → リクエストをアプリケーションへ転送
```

Step 3のRedis照会が追加のI/Oを発生させるが、Redisのインメモリ処理と単純なキー存在チェック（O(1)）により、実用上は1〜2msの追加レイテンシに抑えられる。これは多くのSaaSアプリケーションの要件を満たす。

#### 4.4.2 トークン更新フロー

```
アクセストークン期限切れ → クライアントがRefresh Token を送信

サーバー処理:
  1. Refresh Token のハッシュを計算
  2. Redis から対応エントリを取得・検証
  3. セッションのstatusが "active" であることを確認
  4. 新しいAccess Token を発行（JWTに新しいsidは維持）
  5. Refresh Token を更新（Rotation: 古いトークンを無効化し新しいものを発行）
  6. Redis エントリを更新（last_used, 新token_hash）
```

Refresh Token Rotation を採用することで、リフレッシュトークンの盗難リスクを軽減する。使用済みのリフレッシュトークンで新しいトークンを要求しようとした場合、セッション全体を即時に無効化するdetection機構と組み合わせる。

### 4.5 水平スケーリング設計

#### 4.5.1 ステートレスアプリケーションサーバー

アプリケーションサーバーはセッション状態を一切保持しない。全ての状態はRedisクラスタに集約される。これにより、ロードバランサーはラウンドロビン等の単純な戦略でリクエストを分散できる（スティッキーセッション不要）。

#### 4.5.2 Redisクラスタ構成

```
Redisクラスタ:
  - 3ノード以上のシャード構成（Redis Cluster）
  - 各シャードはプライマリ1台 + レプリカ2台（高可用性）
  - テナントIDをシャードキーのプレフィックスに使用することで
    テナント単位のデータ局所性を確保

キャパシティ計算例（参考）:
  - 同時アクティブセッション 100万件
  - 平均セッションデータ 500 bytes
  - 必要メモリ: 約500MB（セッションデータ）+ インデックス
  - Redisノード 3台構成で十分対応可能
```

#### 4.5.3 JWTの公開鍵管理

JWTの署名検証に使用する公開鍵は、全アプリケーションサーバーがキャッシュする。鍵のローテーション時は以下の手順を踏む。

1. 新しい鍵ペアを生成し、JWKSエンドポイントに追加（既存鍵は維持）
2. 全サーバーが新しい鍵で署名したトークンを発行開始
3. 旧鍵で署名されたトークンの最大有効期限（15分）が経過後、旧鍵を削除

この手順により、鍵ローテーション中もサービスを無停止で継続できる。

---

## 5. 実装上の考慮事項

### 5.1 マルチテナント分離の徹底

全てのRedisキーにテナントIDを含めることで、テナント間のデータ混在を防ぐ。また、管理者API のアクセス制御においては、管理者が自テナントのセッションのみを操作できるよう、JWTの`tid`クレームとAPIパラメータを照合する。

```python
# 管理者APIの認可チェック例（疑似コード）
def revoke_user_sessions(admin_jwt, target_user_id):
    admin_tenant_id = admin_jwt.claims["tid"]
    target_user = db.get_user(target_user_id)

    # テナント所属の確認（重要: これを省略するとテナント間攻撃が可能になる）
    if target_user.tenant_id != admin_tenant_id:
        raise Forbidden("Cross-tenant operation not allowed")

    redis.revoke_all_sessions(admin_tenant_id, target_user_id)
```

### 5.2 監査ログ

セッション関連の全操作を監査ログに記録する。特に管理者によるセッション無効化は、コンプライアンス上の要件から詳細な記録が必要である。

```json
{
  "event": "session_revoked",
  "timestamp": "2026-02-22T10:00:00Z",
  "tenant_id": "tenant_abc",
  "target_user_id": "user_12345",
  "target_session_id": "session_xyz",
  "performed_by": {
    "admin_user_id": "admin_99999",
    "ip_address": "192.0.2.1"
  },
  "reason": "Suspicious login detected"
}
```

### 5.3 レート制限

セッション関連エンドポイントへのレート制限は、テナントIDおよびユーザーIDを単位として適用する。特にログイン（セッション作成）とトークン更新エンドポイントは、ブルートフォース攻撃の標的となりやすいため厳格な制限を設ける。

### 5.4 障害対応

Redisクラスタが一時的に利用不能となった場合の対応方針を事前に定義する必要がある。選択肢は以下の二つである。

**Option A: Fail-open（認証を許可）**
- サービス継続性を優先
- この間に無効化されたセッションが一時的に有効に見える（最大15分）
- セキュリティリスクは限定的だが存在する

**Option B: Fail-closed（認証を拒否）**
- セキュリティを優先
- Redis障害中はサービスが停止する
- 金融・医療等の高セキュリティ要件のテナントに適する

サービスの性質に応じてどちらを選択するかを設計段階で決定し、テナントポリシーとして設定可能にすることが望ましい。

---

## 6. セキュリティ分析

### 6.1 脅威モデル

| 脅威 | 緩和策 |
|---|---|
| アクセストークンの盗難 | 短い有効期限（15分）により被害窓口を制限 |
| リフレッシュトークンの盗難 | Token Rotation + 不正使用検出でセッション即時無効化 |
| テナント間のデータ漏洩 | 全Redisキーへのtenant_idプレフィックス + 認可チェック |
| セッション固定攻撃 | ログイン成功時に新しいsession_idを発行 |
| 管理者の権限濫用 | 監査ログ + テナント内操作のみ許可 |

### 6.2 JWTのセキュリティ注意事項

JWTの`alg`ヘッダーの検証を必ず行い、`alg: none`攻撃を防ぐ。また、署名アルゴリズムはHS256（対称鍵）ではなくRS256またはES256（非対称鍵）を採用することを推奨する。非対称鍵を使用することで、トークン検証サービス（アプリケーションサーバー）がトークン発行サービス（認証サーバー）の秘密鍵を持つ必要がなくなる。

---

## 7. 結論

本稿では、マルチテナントSaaSにおけるセッション管理の四要件（多端末同時ログイン、即時無効化、水平スケーリング、低レイテンシ）を同時に充足するアーキテクチャを提案した。

提案の核心は以下の三点に集約される。

1. **短命JWT + Redisによる無効化リスト**: アクセストークンを15分という短い有効期限に設定し、Redisへの軽量な照会（O(1)のEXISTコマンド）で即時無効化と低レイテンシを両立
2. **セッション粒度のキー設計**: `{tenant_id}:{user_id}:{session_id}:{device_id}` という階層構造により、ユーザー全体・特定セッション・特定デバイスの粒度でセッションを管理
3. **ステートレスアプリケーションサーバー**: 全状態をRedisクラスタに集約し、アプリケーションサーバーをステートレスに保つことで水平スケーリングを実現

本アーキテクチャは、実装の複雑性とセキュリティ・スケーラビリティのバランスを意識的に調整した実用的な設計である。特に、Redis障害時の挙動（fail-open vs fail-closed）については、導入するSaaSの性質とテナントの要件に応じて慎重に設計判断を行う必要がある。

今後の課題として、WebSocketやServer-Sent Eventsなど長期接続プロトコルを使用するアプリケーションへの適用、およびエッジコンピューティング環境でのセッション管理への拡張が挙げられる。

---

## 参考文献

1. Jones, M., Bradley, J., & Sakimura, N. (2015). *JSON Web Token (JWT)*. RFC 7519. IETF.
2. Jones, M., & Hildebrand, J. (2015). *JSON Web Encryption (JWE)*. RFC 7516. IETF.
3. Bertocci, V. (2021). *JSON Web Token Best Current Practices*. RFC 8725. IETF.
4. Hammer, E. (2010). *The OAuth 2.0 Authorization Framework: Bearer Token Usage*. RFC 6750. IETF.
5. Redis Ltd. (2023). *Redis Cluster Specification*. Redis Documentation.
6. OWASP. (2023). *Session Management Cheat Sheet*. OWASP Foundation.
7. Hardt, D. (2012). *The OAuth 2.0 Authorization Framework*. RFC 6749. IETF.
8. Fett, D., Campbell, B., Bradley, J., Lodderstedt, T., Jones, M., & Waite, D. (2020). *OAuth 2.0 Security Best Current Practice*. Internet-Draft. IETF.
