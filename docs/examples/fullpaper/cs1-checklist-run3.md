# CS1 条件D: Structured Checklist — RAG引用リナンバリング (Run 3)

> **Run**: CS1-D-Run3
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c795a-67fa-7c32-bd77-ee5a13944c34)
> **Model**: GPT-5.2 (via Codex)

---

1. 問題の背景と文脈
RAGでは内部参照ID（`source_3`など）をLLMに渡して回答生成します。
一方、UIは可読性のため `[1] [2] [3]` を求めます。
ストリーミングでは将来の出力が未確定なので、「今見せる番号」と「最終的な引用一覧」を両立させる必要があります。

2. 対立する要求やトレードオフ
- 即時表示 vs 最終整合性: 早く出すほど後段の整合制御が難しい。
- 連番の可読性 vs 内部IDの厳密性: 連番は見やすいが、内部IDとの対応管理が必須。
- 番号不変性 vs 訂正可能性: 一度出した番号を固定すると、後からの最適化・再番号付けができない。
- 厳格検証 vs 低遅延: 参照妥当性チェックを強くするとレイテンシが増えやすい。

3. 分析の対象範囲
1回答のストリーム内での「引用タグ検出→番号割当→表示→最終ソース一覧生成」。
検索品質や再ランキング品質は対象外です。

4. 現状のアーキテクチャと制約
- 取得層: `source_n` とメタ情報（title/url/snippet）を返す。
- 生成層: LLMが本文と参照タグをトークン列で出力。
- 配信層: SSE/WebSocketでチャンク配信。
- 制約: チャンク境界は任意、途中テキストの後戻り不可、低遅延要求、幻覚参照の可能性。

5. 既存の解決アプローチとその限界
5.1 アプローチ1: [完了後リナンバリング] — 手法: 全文生成後に連番化 / 利点: 実装容易・整合性高い / 限界: リアルタイム表示要件を満たせない。
5.2 アプローチ2: [内部IDをそのまま表示] — 手法: `source_7`を直接表示 / 利点: 不変・実装簡単 / 限界: UXが悪く連番要件不達。
5.3 アプローチ3: [取得順で事前固定番号] — 手法: retrieval順位で最初に番号付与 / 利点: ストリーム中に不変 / 限界: 未使用ソースが混じりやすく、表示番号が飛びやすい。
5.4 アプローチ4: [LLMに直接[1][2]を出させる] — 手法: プロンプトで番号管理を委譲 / 利点: 中間変換不要 / 限界: 重複・欠番・不整合が起きやすい。

6. 問題の本質的な困難
「未来が見えないオンライン処理」で「一度出した番号は変更不可」という不可逆制約があります。
つまり、部分情報で確定判断しつつ、最後まで整合性を壊さない設計が必要です。

7. 解決策
7.1 基本原理
- 内部IDと表示番号を分離する。
- 「初出時にのみ番号採番」する単調増加マップを採用する。
- 最終ソース一覧は本文解析結果ではなく、この採番マップを唯一の真実源にする。

7.2 実装方針
- LLM出力に機械可読タグを使う（例: ``<cite:source_3>``）。
- ストリーム側でインクリメンタルパーサを実装し、未完了タグはバッファ保持。
- 完了タグ検出時:
  `if source_id not in map: map[source_id]=next_index; next_index+=1`
  既存なら再利用。
- 画面には即時に `[map[source_id]]` を出す（不変）。
- ストリーム完了時、`map`の採番順でソース一覧を生成して表示。
- 不正IDは採番せずログ化し、UIは注記表示（例: `[invalid-citation]`）。

8. 検証条件（Given/When/Then）
- Given `map`空 / When `source_3`初出 / Then `[1]`表示、`map[source_3]=1`。
- Given `map[source_3]=1` / When `source_3`再出 / Then 常に`[1]`表示。
- Given `[1]`表示済み / When 後半で`source_7`初出 / Then `[2]`を新規付与し`[1]`は不変。
- Given タグがチャンク分割（`<cite:so` + `urce_3>`） / When 連結完了 / Then 正しく1回だけ採番。
- Given 未取得ID `source_999` / When タグ到達 / Then 採番しない・エラー記録・最終一覧に含めない。
- Given ストリーム完了 / When 一覧生成 / Then 一覧は表示済み番号と1対1で一致。

9. 制約、限界、今後の課題
- LLMが引用タグを誤生成すると、厳格検証下では参照欠落が増える。
- 番号不変要件のため、後段で本文修正しても番号最適化はできない。
- 複合引用（1箇所で複数ソース）や脚注フォーマット差異の扱いを標準化する必要がある。
- 今後は「構造化出力（JSON/tool-call）で引用イベントを別チャネル送信」にすると堅牢性がさらに上がります。
