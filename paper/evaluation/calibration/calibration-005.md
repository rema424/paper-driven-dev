# Calibration #005

## 1. 問題定義

### 1.1 背景
マルチテナント SaaS では、ユーザー認証後の「セッション（ログイン状態）」を各リクエストで安全かつ高速に検証する必要がある。加えて、テナント管理者による統制（特定ユーザーの強制ログアウト等）を、運用要件として求められることが多い。

### 1.2 矛盾する要求（対立するトレードオフ）
- **即時失効（強い失効） vs 低レイテンシ**：即時失効には「共有状態の参照」または「失効通知の配布」が必要になり、純粋なローカル検証（署名検証のみ）より遅くなり得る。
- **水平スケーリング（ステートレス志向） vs 管理可能性（可変なセッション状態）**：サーバーをステートレスにするとスケールは容易だが、管理者が任意にセッション状態を変更して即時反映するには、どこかに"正"の状態（セッション台帳）が必要となる。
- （副次）**多端末同時ログインの許容 vs セッションの粒度管理**：端末ごとにセッションを分離すると管理は明確になるが、状態・メタデータ・失効操作（件数）のコストが増える。

### 1.3 本文書の範囲
本書は、SaaS の API/Web リクエストにおけるセッション管理方式（トークン形式、失効、水平スケール、レイテンシ）を対象とする。SSO/OIDC 連携の詳細や MFA の方式選定は範囲外とし、必要なら提案手法に組み込める前提で述べる。

---

## 2. 現状のアーキテクチャと制約
- アプリケーションサーバーはロードバランサ配下で複数台稼働し、**水平スケール**する（スティッキーセッションに依存しない）。
- マルチテナントのため、認可判断には **tenant_id** が必須（セッション・トークンのキー空間分離が必要）。
- レイテンシ最小化の観点から、リクエストごとの重い DB 参照は避けたい。一方、管理者操作（失効）は即時反映が必要。
- 共有 KVS（例：Redis Cluster 等）の導入は現実的と仮定する（ただし依存性・可用性が設計論点）。

---

## 3. 既存アプローチとその限界

### 3.1 アプローチ 1: 共有ストア型サーバーサイドセッション（Cookie の Session ID + Redis/DB）
**手法**：クライアントは不透明な session_id を保持し、サーバーは各リクエストで共有ストアからセッション状態（有効/無効、属性）を参照する。
**利点**：即時失効が容易（削除/無効化）。多端末は session_id を端末ごとに発行すれば自然に表現可能。
**限界**：基本的に**毎リクエスト共有ストア参照**になり、レイテンシとストア負荷が支配的になりやすい。ピーク時にストアがボトルネック化すると全体可用性にも直結する。

### 3.2 アプローチ 2: 完全ステートレス JWT（自己完結トークン）
**手法**：JWT に user/tenant 等のクレームを含め、署名検証のみで認証する（サーバーは状態を持たない）。
**利点**：共有ストア不要で低レイテンシ。水平スケールが容易。
**限界**：**即時失効が困難**。失効は基本的に有効期限（exp）待ちになり、要件「管理者が即時無効化」に不適合になりやすい（短命化で緩和すると再発行頻度・運用コストが増える）。

### 3.3 アプローチ 3: JWT + 失効リスト（ブラックリスト/ホワイトリスト）
**手法**：JWT 自体は署名検証しつつ、jti（トークンID）や sid（セッションID）を共有ストアの失効リストで照合する。
**利点**：JWT の利便性を残しつつ失効を実現できる。
**限界**：結局、**照合のための共有ストア参照**が入る。失効リストが増大しやすく、TTL 設計・メモリ圧・多端末/ユーザー単位の一括失効（全トークン列挙）の実装が難しくなる。

### 3.4 アプローチ 4: オーペークトークン + イントロスペクション（OAuth2 的トークン検証）
**手法**：トークンは不透明値とし、各リクエストで認可サーバー/イントロスペクション endpoint に問い合わせて有効性を判定する。
**利点**：中央集権的に制御でき、即時失効が明確。監査・ポリシー適用も集約しやすい。
**限界**：毎リクエストで**ネットワークホップが増える**ためレイテンシ増。検証サービス自体のスケール/可用性がボトルネック化しやすく、キャッシュを入れると失効即時性が損なわれる。

---

## 4. 問題の本質
本問題は、「**分散環境で、低レイテンシな（できればローカルで完結する）検証**」と「**管理者により即時に変化し得るセッション状態（強い失効）**」を同時に満たす点に難しさがある。
すなわち、失効を厳密にするほど"どこかの最新状態"への依存が増え、レイテンシ/可用性/運用複雑性が上がる。一方、状態参照を避けるほど失効は弱くなり、要件不適合となる。

---

## 5. 提案手法

### 5.1 基本原理
**提案**：**「署名付きアクセストークン + セッション台帳（Redis）+ L1 キャッシュ + プッシュ型失効通知」**のハイブリッド方式。
- 認証の基本は JWT 署名検証で行い、通常時は **L1（各アプリノードのメモリ）**でセッション有効性を判断してレイテンシを最小化する。
- "正"のセッション状態は **共有ストア（セッション台帳）**に保持し、管理者による失効は台帳更新と同時に **失効通知を publish** して全ノードの L1 キャッシュを即時に無効化する。
- 多端末は「端末ごとに別 sid を発行」し、管理者はユーザー単位/セッション単位で失効できる。

### 5.2 実装アーキテクチャ
**コンポーネント**
- アプリ/API サーバー（水平スケール、ステートレス）
- セッション台帳：Redis（Cluster 推奨）
- 失効通知：Redis Pub/Sub（同一リージョン前提）またはメッセージング基盤
- 管理者用 API（セッション一覧/失効）

**データ構造（例）**
- `sess:{tenant_id}:{sid}` → Hash
  - `uid`, `state`(active/revoked), `sv`(session_version), `created_at`, `device_meta`, TTL
- `user_epoch:{tenant_id}:{uid}` → Integer（ユーザー一括失効用の世代）
- `user_sids:{tenant_id}:{uid}` → Set（管理画面の列挙・一括操作用）
- `rt:{tenant_id}:{sid}:{rt_id}` → Refresh token ハッシュ + TTL（必要なら）

**トークン設計**
- Access Token（JWT, 短命）：`tenant_id, uid, sid, ue(=user_epoch), sv, exp, iat`
- Refresh Token（オーペーク、回転）：サーバー側にハッシュ保存し、盗難耐性を確保

**リクエスト検証アルゴリズム（高速化と即時失効の両立）**
1. JWT 署名と exp をローカル検証。
2. L1 キャッシュ（キー：`tenant_id:sid`）を参照。
   - `state=active` かつ `token.ue == cached.ue` かつ `token.sv == cached.sv` なら許可（共有ストア I/O なし）。
3. キャッシュミス時のみ Redis をパイプラインで取得（例：`sess` と `user_epoch`）。
   - `sess` が active、`sess.uid` 一致、`token.ue == user_epoch`、`token.sv == sess.sv` を満たせば許可し、L1 を更新。満たさなければ拒否。

**失効（管理者操作）**
- セッション単位失効：`sess.state=revoked` に更新 → `invalidate_session(tenant_id,sid)` を publish → 全ノードが L1 を削除。
- ユーザー一括失効：`INCR user_epoch` → `user_sids` を読み、必要なら sid ごとに invalidate を publish（管理操作は低頻度なので許容）→ 以後、旧 `ue` のトークンは即時に拒否。

**水平スケール**
- アプリはステートレスのまま増減可能。セッション台帳は Redis Cluster でシャーディング。
- 失効通知は全ノード subscribe（ノード数増でも publish/subscribe の運用設計が必要）。

---

## 6. 検証可能な性質
1. **多端末同時ログイン**
   - Given 同一ユーザーが端末A・端末Bでログイン済み（sid が異なる）、when 両端末が同時に API を呼ぶ、then 両方のリクエストが許可される。
2. **セッション単位の即時失効**
   - Given 端末Aの sid が有効、when 管理者がその sid を失効し失効通知が配信される、then 端末Aの既存アクセストークンによる次回リクエストは拒否される。
3. **ユーザー一括失効（全端末）**
   - Given ユーザーの user_epoch=E のトークンが複数端末に存在、when 管理者が user_epoch を E+1 に更新する、then 旧 E のトークンは全端末で拒否される。
4. **キャッシュヒット時の無外部I/O**
   - Given L1 キャッシュに `tenant_id:sid` が存在、when リクエスト検証を実行する、then Redis への問い合わせなしに許可/拒否が決定される（メトリクスで確認可能）。
5. **キャッシュミス時の問い合わせ回数上限**
   - Given L1 ミス、when 検証を行う、then Redis への取得はパイプライン等により"単一往復"で完結する。
6. **ノード増加時の一貫した失効反映**
   - Given アプリノードが N 台稼働し全ノードが subscribe 済み、when 失効通知を publish する、then 全ノードで該当 sid の L1 が削除され、どのノードに到達したリクエストでも拒否される。
7. **共有ストア障害時の安全性**
   - Given Redis が到達不能かつ L1 ミス、when 検証を行う、then リクエストは失敗（例：503/401）として扱われ、未知のトークンを誤って許可しない（fail-closed）。

---

## 7. 制約と今後の課題
- **Redis 依存性**：セッション台帳が単一障害点になり得るため、HA 構成・監視・容量設計が必須。
- **Pub/Sub の信頼性**：Redis Pub/Sub は"配信保証"が弱い。通知欠落時にキャッシュが残存し得るため、(a) L1 の短TTL、(b) 定期再検証、(c) 耐久性のあるメッセージ基盤採用、の検討が必要。
- **マルチリージョン**：リージョン分散時は失効通知の伝播遅延・データ整合性が難化する（グローバル台帳、リージョン別台帳＋同期、などの追加設計が必要）。
- **運用コスト**：`user_sids` の肥大化、端末メタ情報の扱い、監査ログ（誰がいつ失効したか）等の要件追加で複雑化する。
- **セキュリティ詳細**：トークン保管（Cookie/Authorization header）、CSRF 対策、Refresh token の回転・漏洩検知、鍵ローテーション等は別途のセキュリティ設計が必要。
