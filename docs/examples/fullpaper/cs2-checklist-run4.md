# CS2 条件D: Checklist — マルチテナントSaaSセッション管理 (Run 4)

> **Run**: CS2-D-Run4
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c79bb-4b50-78c2-ba6b-9c42a34e8b36)
> **Model**: GPT-5.2 (via Codex)

---

前提として、ユーザー主体は `tenant_id + user_id` で一意、管理者操作は同一テナント内に限定される設計を置きます。

1. 問題の背景と文脈
マルチテナントSaaSでは、業務都合で同一ユーザーの複数端末ログインは必須です。一方で、情報漏えい対策や退職対応のため、管理者による強制ログアウトは即時性が求められます。さらに、APIサーバーは水平スケール前提のため、ローカルメモリ依存のセッション管理は破綻しやすく、認証遅延も抑える必要があります。

2. 対立する要求やトレードオフ
- 即時無効化 vs 低レイテンシ: 毎回中央ストア照会は確実だが遅い。
- ステートレス性 vs 強制失効: 完全JWTは速いが即時失効が難しい。
- 複数端末許容 vs セキュリティ面積: セッション数増加で攻撃面・管理コストが増える。
- テナント分離の厳密性 vs 運用単純性: 分離を強めるほど実装・運用が複雑になる。

3. 分析の対象範囲
対象は、ログイン時のセッション発行、リクエスト認証、管理者失効、失効伝播、スケール時整合性、観測性です。
対象外は、MFA詳細ポリシー、外部IdP連携の個別仕様、課金境界設計です。

4. 現状のアーキテクチャと制約
想定アーキテクチャは `LB -> 複数APIサーバー(ステートレス) -> Redisクラスタ(セッション) + RDB(永続)` です。
制約は、スティッキーセッションなし、ノード増減時の無停止運用、テナント越境禁止、失効反映を秒未満で目指すことです。

5. 既存の解決アプローチとその限界
5.1 アプローチ1: 完全ステートレスJWT — 手法: 署名検証のみ / 利点: 最速・高スケーラブル / 限界: 即時失効が困難。
5.2 アプローチ2: RDBセッション照会 — 手法: 毎リクエストDB確認 / 利点: 失効制御が明確 / 限界: レイテンシ・DB負荷が高い。
5.3 アプローチ3: Redis集中セッション — 手法: Redisで生存確認 / 利点: DBより高速・失効しやすい / 限界: 毎回ネットワーク往復が残る。
5.4 アプローチ4: 短命Access Token + 中央失効状態(ハイブリッド) — 手法: JWT検証+失効情報参照 / 利点: 速度と失効性のバランス / 限界: キャッシュ整合とイベント欠落対策が必要。

6. 問題の本質的な困難
分散環境で「即時失効」と「低遅延」を同時達成するには、各ノードのローカル高速判定と中央真実ソースの整合を崩さない設計が必要です。特に、失効イベント伝播遅延・欠落・再順序化が本質的な難所です。

7. 解決策
7.1 基本原理
- 端末ごとに `session_id` を持つ。
- ユーザー単位の `session_epoch` を持ち、一括失効は epoch インクリメントで表現する。
- 認証は「ローカル高速判定」を基本にし、中央ストアをフォールバックにする。
- Access Tokenは短命、Refresh Tokenはローテーションする。

7.2 実装方針
1. トークン: Access JWTに `tid, uid, sid, epoch, exp` を入れる。Refreshは不透明トークンをハッシュ保存。
2. データ: Redisに `user_epoch:{tid}:{uid}` と `session:{tid}:{sid}` を保持。
3. 認証: JWT署名検証後、ローカルキャッシュの `user_epoch/sid状態` を確認。ミス時のみRedis参照。
4. 管理者失効: 原子的処理で `user_epoch` を増分し、失効イベントをPub/SubやStreamで全ノードへ配信。
5. 複数端末: 端末ごとに独立 `sid` を発行し同時有効化。必要なら端末単位失効も可能。
6. スケール: APIノードは完全ステートレス。新規ノードは起動時に最新epochを同期。

8. 検証条件（Given/When/Then）
- Given 同一ユーザーがPCとスマホでログイン済み, When 両方からAPI呼び出し, Then どちらも認証成功する。
- Given 管理者が対象ユーザーを失効, When 失効後に既存トークンでAPI呼び出し, Then 全ノードで即時に401を返す。
- Given ユーザー失効済み, When 再ログイン, Then 新epochのトークンのみ有効で旧トークンは無効のまま。
- Given APIノードを増設, When 新ノードがトラフィック受信, Then 既存失効状態を反映して誤認証しない。
- Given Redis一時遅延, When 認証処理実行, Then ローカルキャッシュで許容範囲の継続動作をしつつ安全側に倒す。
- Given 通常負荷, When 認証APIを計測, Then p95/p99が目標値（例: p99 < 15ms）を満たす。

9. 制約、限界、今後の課題
Redis/イベント基盤が実質的な依存点になります。イベント欠落時の再同期機構（定期スナップショット照合）が必須です。リージョン跨ぎでは「即時」の定義をSLO化する必要があります。今後は、WebSocket長時間接続の強制切断連携、テナント別ポリシー（同時端末数上限）と監査証跡強化が課題です。
