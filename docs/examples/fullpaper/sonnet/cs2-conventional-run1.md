# CS2 条件A: Conventional — マルチテナントSaaSセッション管理 (Run 1)

> **Run**: CS2-A-Run1
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

# マルチテナントSaaSセッション管理システム 設計分析と解決策

## 1. 問題の分析と要件の整理

### 1.1 要件間のトレードオフの特定

4つの要件を同時に満たすことは、いくつかの本質的なトレードオフを含んでいる。

**低レイテンシ vs 即座の無効化**

最もクリティカルなトレードオフは、認証レイテンシの最小化と即座のセッション無効化の間に存在する。

- JWTのようなステートレストークンはレイテンシを最小化できるが、有効期限まで無効化できない（サーバー側に状態を持たないため）
- サーバーサイドセッションは即座の無効化が可能だが、すべてのリクエストでセッションストアへのI/Oが発生する

**水平スケーリング vs セッション共有**

複数サーバーが存在する場合、セッション情報をどこに持つかが問題になる。

- ローカルメモリにセッションを持つとスケーリング時にセッションが失われる
- 中央集権的なセッションストア（Redisなど）を使えばスケーリングに対応できるが、単一障害点になりうる

**マルチテナント分離**

テナントごとにセッション名前空間を分離しなければ、テナント間の情報漏洩リスクがある。管理者による無効化もテナントをまたがないよう制御が必要である。

### 1.2 設計原則の確認

- **セキュリティ優先**: セッション管理の失敗はデータ漏洩に直結する
- **最小権限の原則**: テナント管理者は自テナントのセッションのみ操作可能
- **フェイルセーフ**: セッションストア障害時にフェイルオープン（認証通過）ではなくフェイルクローズ（認証拒否）する

---

## 2. アーキテクチャ設計

### 2.1 採用するアプローチ: ハイブリッドトークン方式

純粋なJWT方式でも純粋なサーバーサイドセッション方式でもなく、両者の利点を組み合わせたハイブリッド方式を採用する。

**方式の概要**

```
クライアント                   APIサーバー群              セッションストア
    │                              │                         │
    │──── リクエスト + JWT ────────>│                         │
    │                              │──── セッション検証 ──────>│
    │                              │<─── 有効/無効 ───────────│
    │<─── レスポンス ───────────────│                         │
```

**コアとなる考え方**

JWTはセッションIDのみを含む短命（5〜15分）のトークンとして機能する。実際のセッション状態（有効/無効、メタデータ）はRedisに保持する。JWTの有効期限を短くすることで、セッション無効化の最大遅延を許容範囲に収める。ただし、即座の無効化が必要な場合はブラックリスト機構を追加する。

### 2.2 データ構造の設計

**セッションエントリ（Redisハッシュ）**

```
キー: session:{tenant_id}:{session_id}
TTL: セッションの最大有効期間（例: 30日）

フィールド:
  user_id        : "u_123456"
  tenant_id      : "t_acme"
  device_id      : "d_iphone_abc"
  device_label   : "iPhone 15 (Tokyo)"
  created_at     : "2026-02-22T10:00:00Z"
  last_active_at : "2026-02-22T14:30:00Z"
  ip_address     : "203.0.113.42"
  user_agent     : "Mozilla/5.0 ..."
  status         : "active"  // "active" | "revoked"
  scopes         : "read:data,write:data"
```

**ユーザー別セッションインデックス**

```
キー: user_sessions:{tenant_id}:{user_id}
型: Redis Set
値: {session_id} の集合
TTL: なし（セッション削除時に都度更新）
```

**テナント別アクティブセッション数（モニタリング用）**

```
キー: tenant_session_count:{tenant_id}
型: Redis Counter
```

**JWTのペイロード**

```json
{
  "jti": "jwt_unique_id",
  "sid": "session_id",
  "uid": "user_id",
  "tid": "tenant_id",
  "did": "device_id",
  "iat": 1708596000,
  "exp": 1708596900
}
```

JWTには最低限の情報のみを含め、権限情報などはセッションストアから都度取得するか、短いキャッシュで管理する。

### 2.3 セッションライフサイクル

**ログイン処理**

```
1. 認証情報を検証
2. session_id を生成（UUIDv4 + テナントプレフィックス）
3. Redisにセッションエントリを作成（SET with TTL）
4. user_sessions インデックスに session_id を追加（SADD）
5. JWTを生成（ペイロードに session_id を含める）
6. JWTをクライアントに返却
   - HTTPOnly Cookie（推奨）
   - またはレスポンスボディ（SPAの場合）
```

**リクエスト認証処理（クリティカルパス）**

```
1. JWTの署名と有効期限を検証（ローカル処理、ネットワーク不要）
   ├── 無効/期限切れ → 401を返す
   └── 有効 → 次のステップへ

2. Redisからセッション情報を取得
   キー: session:{tid}:{sid}
   ├── キーが存在しない → 401を返す
   ├── status == "revoked" → 401を返す
   └── 有効 → 次のステップへ

3. last_active_at をバックグラウンドで更新（非同期）

4. リクエストコンテキストにセッション情報を付与してハンドラーへ
```

**ステップ2のレイテンシ最適化**

- Redis Single-Get: O(1)のハッシュ取得で1〜2ms
- Connection Pool: コネクションを事前確立
- Redis Cluster: シャーディングで読み取りスループットを向上
- Read Replica: 読み取りをレプリカに分散

---

## 3. マルチテナント対応

### 3.1 テナント分離の実装

**キー名前空間の分離**

すべてのRedisキーにテナントIDを含めることで、テナント間のデータ混在を防ぐ。

```
session:{tenant_id}:{session_id}
user_sessions:{tenant_id}:{user_id}
```

**テナント別設定**

テナントごとに異なるセッションポリシーを適用できるようにする。

```
tenant_config:{tenant_id}
  max_sessions_per_user : 10      // 同時ログイン数の上限
  session_ttl           : 2592000 // 30日（秒）
  jwt_expiry_seconds    : 900     // 15分
  require_mfa           : true
  allowed_ip_ranges     : ["10.0.0.0/8"]
```

**テナント管理者の権限スコープ**

```
管理者操作の検証:
1. 操作者のテナントIDを確認
2. 操作対象のセッションのテナントIDを確認
3. 両者が一致する場合のみ操作を許可
4. スーパー管理者（プラットフォーム管理者）は例外的にすべてのテナントにアクセス可能
```

### 3.2 Redis のテナント分離オプション

**オプション1: 共有Redis、キープレフィックスで分離**（推奨: 小〜中規模）

- シンプルで運用コストが低い
- テナント間のリソース競合リスクあり

**オプション2: テナントグループ別Redisクラスター**（推奨: 大規模）

- テナントを数百〜数千ずつグループ化し、グループごとにクラスターを割り当て
- データ分離が強い
- 運用コストが増える

**オプション3: テナント専用Redis**（推奨: エンタープライズ顧客）

- 大口顧客向けの専用インフラ
- コンプライアンス要件を満たしやすい

---

## 4. セッション即座無効化の実装

### 4.1 無効化の仕組み

**個別セッション無効化**

```
管理者操作:
1. session:{tenant_id}:{session_id} の status を "revoked" に更新
2. TTLを短縮（例: 5分後に自動削除）
3. 監査ログに記録: {admin_id, target_session_id, timestamp, reason}

効果:
- 次のリクエストで認証チェック時に "revoked" を検出
- JWTが有効期限内でも認証を拒否
```

**ユーザーの全セッション無効化**

```
管理者操作:
1. user_sessions:{tenant_id}:{user_id} からすべてのsession_idを取得（SMEMBERS）
2. 各セッションの status を "revoked" に更新（パイプライン処理）
3. インデックスをクリア（DEL）
4. 監査ログに記録

Luaスクリプトでアトミックに実行:
  local sessions = redis.call('SMEMBERS', KEYS[1])
  for _, sid in ipairs(sessions) do
    redis.call('HSET', 'session:' .. ARGV[1] .. ':' .. sid, 'status', 'revoked')
    redis.call('EXPIRE', 'session:' .. ARGV[1] .. ':' .. sid, 300)
  end
  redis.call('DEL', KEYS[1])
  return #sessions
```

**テナント全体の緊急無効化**（インシデント対応時）

```
1. テナント設定に "emergency_lockout: true" を設定
2. 認証チェック時にテナント設定を確認し、ロックアウト中は全リクエストを拒否
3. テナント設定はローカルキャッシュで30秒TTLを設けて効率化
```

### 4.2 無効化の伝播遅延

JWTの有効期限内（例: 15分）は、Redisを参照するまで無効化が検出されない場合がある。これを解消するオプション:

**オプションA: JWTの有効期限を短縮**
- 5分以下にすることで最大遅延を許容範囲に収める
- リフレッシュトークンとの組み合わせで利便性を保つ

**オプションB: WebSocket/SSEによるプッシュ通知**
- セッション無効化時にサーバーからクライアントへ通知
- クライアントがトークンを破棄する
- コネクションを維持するコストがかかる

**オプションC: ブラックリスト（即座の無効化が絶対要件の場合）**

```
キー: blacklist:{tenant_id}:{jti}
TTL: JWTの残余有効期限
値: "revoked"

認証チェックでブラックリストを追加確認:
GET blacklist:{tid}:{jti}
├── 存在する → 401
└── 存在しない → 認証通過
```

ブラックリストはJWT有効期限後に自動削除されるため、ストレージは最小限。ただし毎リクエストで追加のRedis参照が必要。

---

## 5. 水平スケーリング対応

### 5.1 ステートレスAPIサーバー

APIサーバーはセッション状態をメモリに持たない完全なステートレス設計とする。

```
APIサーバーが持つもの:
- JWTの署名検証用公開鍵（定期ローテーション）
- Redisクライアント（コネクションプール）
- テナント設定の短期キャッシュ（30秒TTL）

APIサーバーが持たないもの:
- セッション情報
- ユーザー情報
- テナント固有の状態
```

ロードバランサーは任意のリクエストを任意のサーバーにルーティングできる（スティッキーセッション不要）。

### 5.2 Redisクラスター構成

```
Redis Cluster（シャーディング）:
- 16384スロットを複数ノードに分散
- セッションキーのハッシュタグで関連キーを同一シャードに配置:
  キー: {tenant_id:user_id}:session:xxx
  → テナント+ユーザーの全セッションが同一シャードに

レプリケーション:
- プライマリ: 書き込み（セッション作成・更新・無効化）
- レプリカ: 読み取り（認証チェック）
- レプリカラグ: 通常1〜10ms（許容範囲）
```

**Redisの可用性確保**

```
- クラスター構成: 3プライマリ × 2レプリカ = 6ノード最小構成
- 自動フェイルオーバー: プライマリ障害時にレプリカが自動昇格（15〜30秒）
- クロスAZ配置: 可用性ゾーンをまたいでノードを分散
- バックアップ: RDB + AOFで耐久性を確保
```

### 5.3 リフレッシュトークンの扱い

リフレッシュトークンはJWTより長命（7〜30日）で、新しいアクセストークンの発行に使う。

```
リフレッシュトークンフロー:
1. ログイン時にリフレッシュトークン（不透明な128bitランダム値）を発行
2. Redisに保存: refresh:{tenant_id}:{token_hash}
3. クライアントはHTTPOnly Cookieに保存
4. アクセストークン失効時、リフレッシュエンドポイントで交換
5. 新しいアクセストークン + 新しいリフレッシュトークンを返却
   （リフレッシュトークンローテーション）
```

---

## 6. 複数端末同時ログインのサポート

### 6.1 デバイスセッション管理

ユーザーは複数のデバイスから同時にログインできる。各デバイスは独立したセッションを持つ。

```
データ構造:
user_sessions:{tenant_id}:{user_id}
  = {"session_abc", "session_def", "session_ghi"}
    │                │              └── モバイルアプリ
    │                └── 自宅PC
    └── 職場PC
```

**同時セッション数の制限**

テナントポリシーで上限を設定できる。

```
ログイン時:
1. user_sessions:{tid}:{uid} のメンバー数を確認（SCARD）
2. 上限に達している場合:
   オプションA: 最古のセッションを自動無効化
   オプションB: ログインを拒否してエラーを返す
   オプションC: ユーザーに選択を求める（どのセッションを切るか）
```

### 6.2 デバイス管理UI向けAPI

```
GET /api/v1/sessions
レスポンス:
[
  {
    "session_id": "session_abc",
    "device_label": "職場PC (Chrome)",
    "created_at": "2026-02-20T09:00:00Z",
    "last_active_at": "2026-02-22T14:30:00Z",
    "ip_address": "203.0.113.42",
    "is_current": true
  },
  ...
]

DELETE /api/v1/sessions/{session_id}
→ 特定セッションの無効化（自セッションまたは管理者操作）
```

---

## 7. 実装上の注意点

### 7.1 セキュリティ考慮事項

**セッション固定攻撃の防止**

認証成功後に必ず新しいセッションIDを発行する。ログイン前のセッションIDをそのまま使い続けない。

**セッションハイジャッキングの検出**

```
異常検知の例:
- IPアドレスが短時間で大幅に変化（地理的に不可能な移動）
- User-Agentが突然変化
→ セッションを一時停止し、再認証を要求
```

**JWTの署名アルゴリズム**

RS256（非対称）を推奨。秘密鍵はAPIサーバーに置かず、専用の鍵管理サービス（AWS KMS、HashiCorp Vaultなど）で管理する。公開鍵はAPIサーバーが取得して検証に使う。

### 7.2 モニタリングと可観測性

```
重要メトリクス:
- セッション認証レイテンシ（P50/P95/P99）
- Redis操作レイテンシ
- テナントごとのアクティブセッション数
- セッション無効化の実行回数と理由
- 認証失敗率（テナント別）

アラート:
- Redisレイテンシ > 10ms（P99）
- 認証失敗率の急上昇（ブルートフォース検出）
- 特定テナントの異常なセッション数増加
```

### 7.3 段階的移行戦略

既存のセッション管理から移行する場合:

```
フェーズ1: 並行運用
- 新旧両方のセッション管理を並行稼働
- 新しいログインは新方式で処理
- 既存セッションは旧方式で処理

フェーズ2: 移行促進
- 既存セッションが期限切れになるまで待つ
- または強制的に再ログインを促す

フェーズ3: 旧方式の廃止
- 新方式のみで稼働
```

---

## 8. まとめ

### 採用アーキテクチャの再確認

| 要件 | 解決策 |
|------|--------|
| 複数端末同時ログイン | ユーザー別セッションインデックス（Redis Set）でデバイスセッションを独立管理 |
| 即座のセッション無効化 | RedisのセッションエントリをONE-HOPで更新。すべての認証でRedisを参照するため即座に反映 |
| 水平スケーリング | ステートレスAPIサーバー + Redis Clusterで実現。スティッキーセッション不要 |
| 低レイテンシ認証 | JWTのローカル検証（ネットワーク不要）+ Redis Single-Get（1〜2ms）の2ステップ |

### レイテンシの見積もり

```
JWTローカル検証:    < 1ms
Redis GET（LAN内）: 1〜3ms
合計:               2〜4ms（P50）
                    5〜10ms（P99）
```

これはデータベースへのフルセッション検索（10〜50ms）と比較して大幅に低い。

### 設計の強み

このハイブリッド方式は、JWTの低レイテンシとサーバーサイドセッションの即座の制御可能性を組み合わせることで、4つの要件を実用的なレベルで同時に満たす。純粋なJWT方式と比べてRedis参照が増えるが、そのコストはインフラのレイテンシ要件（10ms以内）に収まる範囲である。

マルチテナントの文脈では、キー名前空間の分離と管理者権限の厳密なスコープ制御が特に重要であり、これを設計の中核に据えた。
