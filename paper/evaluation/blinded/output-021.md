# Output #021

要件同士が一部トレードオフです（**低レイテンシ＝ステートレス寄り**、**即時無効化＝ステートフル寄り**）。両立する現実解は「**JWTで高速認証しつつ、無効化情報だけを最小限ステートとして配るハイブリッド**」です。

**推奨アーキテクチャ（ハイブリッド）**
- **Access Token**: 短命JWT（例: 5〜15分）。`tenant_id`, `user_id`, `session_id(jti)`, `iat`, `exp`, `kid` を含め署名。通常リクエストは**ローカル検証のみ**で完了。
- **Refresh Token**: 長命・不透明トークン（ランダム文字列）。**端末（=セッション）ごとに1本**発行し、サーバ側に**ハッシュ保存**（ローテーション＋再利用検知推奨）。
- **セッションストア（共有）**: Redis Cluster / DynamoDB 等（水平スケール可）。
  - `sess:{tenant}:{session_id}` → `user_id`, `revoked_at`, `device`, `refresh_hash`, …
  - `user_rev:{tenant}:{user_id}` → `revoked_at`（ユーザー全セッション無効化用）
  - `user_sess:{tenant}:{user_id}` → session_id一覧（管理画面で列挙・個別失効用）
- **無効化イベント配信**: Redis Pub/Sub / Kafka / SNS/SQS 等で「`(tenant, user_id)`または`(tenant, session_id)`を失効」を配信し、各APIノードの**インメモリキャッシュを即更新**。

**リクエスト認証（低レイテンシの肝）**
1) JWT署名と`exp`をローカルで検証（DB/Redis不要）
2) 追加で、ローカルキャッシュ上の失効情報と比較して拒否判定
   - `token.iat <= user_revoked_at` なら拒否（ユーザー一括失効）
   - `token.iat <= session_revoked_at` なら拒否（端末/セッション個別失効）
3) キャッシュ未命中時だけRedis等へ参照（TTL短めにキャッシュ）。イベント配信が生きていれば通常は未命中が減ります。

**管理者の即時無効化（要件の肝）**
- **特定ユーザーを即時無効化**: `user_rev:{tenant}:{user_id}=now` を更新し、同内容をイベント配信
  → 以降そのユーザーの既存JWTは全ノードで即座に拒否（キャッシュ更新が反映された瞬間から）
- **特定端末だけ無効化**: `sess:{tenant}:{session_id}.revoked_at=now` 更新＋イベント配信
- 併せて refresh token を失効（ストア削除/フラグ）し、再発行も止める

**水平スケーリング**
- APIサーバは基本ステートレス（JWTローカル検証＋ローカルキャッシュ）
- セッションストアはクラスタ化（Redis Cluster等）
- 新規ノードは起動時にキャッシュ空なので、最初だけストア参照が増えるが、以後はイベントで追従

**代替案（採用判断の目安）**
- **完全ステートフル（毎回セッションストア参照）**: 即時失効は簡単だが、認証レイテンシとストア負荷が増えやすい
- **完全ステートレス（短命JWTのみ）**: レイテンシ最小だが、「即時無効化」は実質「最大TTL待ち」になりがち
