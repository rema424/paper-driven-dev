# Output #009

**推奨設計（結論）**
「`source_id` と表示番号を分離し、ストリーミング中に **初出時だけ採番して固定**」が最も要件に合います。

1. LLMには本文中で `[[source_3]]` のような機械可読タグを出させる
2. ストリーム処理層で `source_id -> 表示番号` を管理する
3. 初めて出た `source_id` にだけ `1,2,3...` を割り当て、以後は再利用する
4. UIにはタグを `[n]` に置換してリアルタイム表示する
5. 完了時はそのマップ順（1→N）でソース一覧を生成する

これで以下を同時に満たせます。
- リアルタイム表示: 置換しながら表示できる
- 番号不変: 一度割り当てた番号を再計算しない
- 最終整合: 同じマップから本文と一覧を作るため一致する

---

**実装の要点**

1. サーバー側状態
- `nextNumber: int = 1`
- `sourceToNumber: Map<source_id, number>`
- `numberToSource: Map<number, source_meta>`
- `streamBuffer: string`（チャンク分断対策）

2. ストリーム処理
- チャンクを `streamBuffer` に追記
- 完全な引用タグ（例 `[[source_7]]`）だけをパース
- 未登録なら採番して固定
- クライアントへ本文差分として `[number]` を送信
- 同時に `citation_added` イベントを送るとUI実装が楽

3. 完了時
- `numberToSource` を 1..N で列挙して最終ソース一覧を送信
- 本文中に出た番号と一覧の双方向チェックを実施（監査ログ推奨）

---

**失敗しやすい点と対策**

1. チャンク境界でタグが分断される
- 正規表現一発ではなく、バッファ＋状態機械で処理

2. LLMが存在しない `source_id` を出す
- 方針を固定（無視 / `[?]` / エラー）し、通常は無視＋ログが安全

3. 後処理で番号を詰め直したくなる
- 詰め直しは禁止（要件違反）。欠番が嫌なら「初出採番」を使う（通常欠番なし）

---

必要なら次に、SSE/WebSocket向けの具体的なイベント仕様（`text_delta`, `citation_added`, `final_sources`）まで落として提案できます。
