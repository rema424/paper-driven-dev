# CS1 条件D: Checklist — RAG引用リナンバリング (Run 5)

> **Run**: CS1-D-Run5
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c79b5-5e31-7a43-8943-a0a106c27e8b)
> **Model**: GPT-5.2 (via Codex)

---

1. 問題の背景と文脈
RAGでは、LLMが内部参照ID（`source_3` など）を使って根拠を示しつつ、トークンを逐次配信します。
一方、ユーザー体験としては `[1] [2] [3]` の連番表示が望まれます。
課題は「全文未確定のストリーミング中に、読みやすい引用番号を即時表示しつつ、後で番号を変えず、最終ソース一覧と一致させる」ことです。

2. 対立する要求やトレードオフ
- 即時性 vs 正確性: 早く表示するほど、後段での整合修正余地が減ります。
- 番号不変性 vs 最適な連番圧縮: 後から詰め直せば見た目は綺麗ですが、番号変更が発生します。
- 実装単純性 vs 堅牢性: 後処理のみは簡単ですが、リアルタイム要件を満たせません。
- LLM自由出力 vs 厳格フォーマット: 自由出力は柔軟ですが、引用抽出の失敗率が上がります。

3. 分析の対象範囲
対象は以下です。
- バックエンドのストリーム処理層（引用ID抽出、番号割当、状態保持）
- フロントエンド表示層（本文内番号表示、ソース一覧更新）
- 完了時整合チェック（本文中参照番号とソース一覧一致）
対象外は、検索品質改善・ランキング最適化・UIデザイン詳細です。

4. 現状のアーキテクチャと制約
前提となる典型構成は以下です。
- Retrieverが `source_n -> メタ情報(title/url/snippet)` を返す
- LLMはストリーミングで本文を返し、本文中に `source_n` を含む
- チャンク境界は任意で、`[source_7]` が分割される可能性がある
- ユーザーに見せた本文は通常巻き戻さない（追記型UI）
このため「後から番号を再計算して本文を置換」は実運用で難しいです。

5. 既存の解決アプローチとその限界
5.1 アプローチ1: 完了後一括変換 — 手法 / 利点 / 限界
- 手法: ストリーム中は内部ID表示、完了後に `[1]...` へ再番号付け。
- 利点: 実装が容易、最終整合は取りやすい。
- 限界: リアルタイムで読みやすい番号を出せない。要件未達。

5.2 アプローチ2: 事前固定マップ（検索順位順） — 手法 / 利点 / 限界
- 手法: `source_n` に固定で表示番号を割り当て、配信中そのまま表示。
- 利点: 番号不変、実装シンプル。
- 限界: 実際に使われないソースが混ざると番号が飛びやすく、可読性が下がる。

5.3 アプローチ3: 初出時確定マップ（推奨） — 手法 / 利点 / 限界
- 手法: 引用が初めて現れた順に `[1],[2]...` を確定し、以後固定。
- 利点: リアルタイム表示・番号不変・最終一覧整合を同時に満たせる。
- 限界: ストリーム中の引用抽出器を堅牢に作る必要がある。

6. 問題の本質的な困難
- 未来の出力は未確定なのに、現在の表示は確定させる必要がある点。
- 一度表示した番号を変更不可にするなら、割当は不可逆コミットになる点。
- LLM出力は揺らぐため、未知ID・誤記・分割チャンクに耐える必要がある点。

7. 解決策
7.1 基本原理
- 「内部ID」と「表示番号」を分離します。
- 表示番号は「初出時にのみ採番し、その後不変」にします。
- 本文表示と同時に、採番ログをイベントとして保存します（append-only）。

7.2 実装方針
- 状態: `display_no_by_source`, `source_by_display_no`, `next_no` をターン単位で保持。
- ストリーム処理:
  1) チャンクを状態機械でパースして引用トークンを抽出
  2) 初出 `source_x` なら `next_no` を割当
  3) 本文には即座に `[n]` を出力（既出は同じ `n`）
  4) 初出時に `citation_bound(source_x, n)` イベントを発行
- 完了処理:
  - `source_by_display_no` 順に最終ソース一覧を構築して返却
  - 本文中に出た番号集合と一覧番号集合の一致を検証
- 異常系:
  - 未取得IDは `[?]` 表示または無効引用として除外し、ログ/メトリクスに記録
  - 再接続時は同一ターン状態を復元し、採番を継続（再採番しない）

8. 検証条件（Given/When/Then）
- Given: `source_7` が最初、`source_3` が次に出る
  When: ストリームを処理する
  Then: 本文表示は `[1]`→`[2]`、最終一覧は `1->source_7`, `2->source_3` になる。

- Given: `source_7` が複数回出る
  When: 全チャンクを処理する
  Then: すべて同じ `[1]` で表示され、番号は変化しない。

- Given: `[source_7]` がチャンク分割される
  When: 分割チャンクを順に受信する
  Then: 壊れた途中表示を出さず、完成時に一度だけ `[1]` を表示する。

- Given: 取得結果にない `source_99` が出る
  When: ストリームを処理する
  Then: 無効引用として扱い、最終ソース一覧に混入しない。

- Given: 途中で接続断が発生し再開する
  When: 同一ターン状態で処理再開する
  Then: 既存番号は維持され、後続引用のみ新規採番される。

9. 制約、限界、今後の課題
- LLMが後方編集可能なストリーム仕様だと「不変番号」と衝突しやすいです。
- 引用記法が自由テキストだと抽出失敗リスクが残るため、将来的に構造化出力（例: `<cite source="...">`）へ寄せるのが有効です。
- 未知ID処理ポリシー（表示/非表示/警告）をプロダクト要件として明文化する必要があります。
- 観測性として、`invalid_citation_rate`、`renumber_attempt`、`stream_reconnect_count` の監視を追加すると運用が安定します。
