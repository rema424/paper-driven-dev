# Output #019

**題目:** ストリーミングRAGにおける不変引用番号付けの設計

**§1. 問題定義**
**§1.1 背景**
RAGでは、LLMが `source_3` や `source_7` のような内部ソースIDを参照しつつ、トークンを逐次生成する。ユーザー体験上は `[1] [2] [3]` の連番引用が望ましいが、ストリーミング中は全文未確定のため、引用集合が確定しない。

**§1.2 矛盾する要求（対立するトレードオフ）**
1. 低遅延表示 vs 最終確定性
ストリーミング即時表示を行うほど、後段での再番号付け余地は失われる。
2. 番号不変性 vs 番号最適化
一度表示した番号を固定すると、最終的な「最小・最適な並び」への再編成はできない。
3. 生成自由度 vs 引用整合性保証
LLMの自由生成を許すほど、存在しないソース参照や不整合検出が難しくなる。

**§1.3 本文書の範囲**
本稿は「引用番号のオンライン割当と最終整合」に限定する。検索品質、回答内容の真偽、UI装飾は対象外とする。

**§2. 現状のアーキテクチャと制約**
一般的構成は `Retriever -> LLM Streaming -> Renderer` である。制約は以下。
- チャンク境界が任意で、引用トークンが分断される。
- 送信済みテキストの後方修正が困難（SSE/WebSocketの追記モデル）。
- 同一ソース再参照が頻発する。
- 再接続や再送で重複イベントが起こる。
- 最終ソース一覧は本文中番号と厳密一致が必要。

**§3. 既存アプローチとその限界**
**§3.1 アプローチ1: 事後一括番号付け — 手法 / 利点 / 限界**
- 手法: 生成完了後に全引用を走査して `[1..N]` を付与。
- 利点: 全体最適な番号付けが可能。
- 限界: ストリーミング中に読みやすい番号を出せない。

**§3.2 アプローチ2: 検索順位の事前固定番号 — 手法 / 利点 / 限界**
- 手法: 検索結果順にあらかじめ番号を固定。
- 利点: 即時表示・不変性は満たしやすい。
- 限界: 未使用番号が増え、本文の出現順と乖離しやすい。

**§3.3 アプローチ3: プレースホルダ表示後に置換 — 手法 / 利点 / 限界**
- 手法: 一時的に `[source_7]` を表示し、後で連番へ置換。
- 利点: 実装が単純。
- 限界: 「一度表示した番号が変わらない」を満たせない（表示変化が発生）。

**§4. 問題の本質**
本問題は「オンライン不可逆ラベリング」である。
引用イベント列 `e_t=(source_id)` に対し、到着時点で表示番号 `c_t` を決め、以後変更不可とする必要がある。
必要条件は次の3つ。
- 同一 `source_id` は常に同一番号。
- 新規 `source_id` への番号割当は単調増加。
- 最終ソース一覧は割当結果から機械的に再構成可能。
よって、事後最適化ではなく「初出時確定」が本質となる。

**§5. 提案手法**
**§5.1 基本原理**
提案: **SMCA (Stable Monotonic Citation Assignment)**
- 初出確定: `source_id` 初出時に次番号を即時割当。
- 不変写像: `source_id -> display_index` を追記専用で保持。
- 逆写像保持: `display_index -> source_id` を同時保持。
- 最終一覧生成: 逆写像をそのままソース一覧へ変換。

擬似規則:
- 未割当 `s` を受信したら `k = size(map)+1` を割当、`[k]` を出力。
- 既割当 `s` なら既存 `k` を再利用。
- 削除・再番号付けは行わない。

**§5.2 実装アーキテクチャ**
1. Citation Extractor: ストリームから `source_id` を抽出（分断チャンク対応）。
2. Allocation Engine: `map_fwd`, `map_rev` を原子的更新。
3. Stream Renderer: 本文へ即時 `[k]` を挿入。
4. Event Log: `session_id, offset, source_id, k` を永続化（再送耐性）。
5. Finalizer: `map_rev` から最終ソース一覧を生成。
6. Validator: 本文出現番号集合と最終一覧の一致を検証。

**§6. 検証可能な性質 — Given/When/Then**
1. Given `map` が空、When `source_7` 初出、Then `[1]` が表示され以後 `source_7->1` は不変。
2. Given `source_7->1` が存在、When `source_7` 再出、Then 常に `[1]` が表示される。
3. Given `source_7->1`、When `source_3` 初出、Then `[2]` が割当され `[1]` は変化しない。
4. Given 引用トークンが複数チャンクに分断、When Extractorが再構成、Then 重複割当なく単一番号が出力される。
5. Given 再接続で過去イベントが再送、When Event Logを参照して再処理、Then 同一 `source_id` は同一番号に収束する。
6. Given ストリーム完了、When Finalizerが `map_rev` から一覧生成、Then 本文中 `[k]` と一覧 `k` が全件一致する。

**§7. 制約と今後の課題**
- 番号順は「初出順」であり、重要度順ではない。
- LLMが不正 `source_id` を出した場合、不変性を保ったままの自動修復は限定的。
- 長文で引用数が多い場合、可読性とUI密度が低下する。
- 今後は、生成時制約（有効 `source_id` のみ許可）と、文単位の事前検証を併用し、整合性と可読性の両立を強化すべきである。
