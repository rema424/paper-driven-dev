# Output #015

**題目:** ストリーミングRAGにおける不変引用番号付与方式の設計分析

**§1. 問題定義**

**§1.1 背景**
RAGシステムでは、検索結果集合 `S={source_1,...,source_n}` を参照しつつ、LLMが逐次トークンを生成します。内部参照ID（例: `source_3`）は機械可読ですが、ユーザー体験上は `[1] [2] [3]` の連番表示が望まれます。問題は、ストリーミング時点では将来の引用出現順が未確定である点です。

**§1.2 矛盾する要求（対立するトレードオフ）**
1. リアルタイム表示 vs 最終最適化
ストリーム中に番号を即時表示したい一方、全文確定後に最適な番号付け（例: 出現順再計算）を行うと番号変更が発生します。
2. 番号不変性 vs 連番の見栄え
一度表示した番号を固定すると、後段の編集や再送処理で欠番・順序の不自然さが生じる可能性があります。
3. 低遅延 vs 厳密整合検証
即時レンダリングを優先すると検証時間が減り、厳密なソース整合（存在確認・重複排除）との両立が難しくなります。

**§1.3 本文書の範囲**
単一回答ストリーム内での引用番号付与を対象とします。対象外は、会話横断の通番共有、外部文献管理システム統合、モデル学習時の引用忠実性保証です。

---

**§2. 現状のアーキテクチャと制約**
典型構成は `Retriever -> LLM Generator -> Stream Transport -> UI Renderer` です。制約は以下です。
1. 出力は逐次到着し、将来トークンは未知。
2. UIは低遅延描画が必要。
3. 参照は重複出現し得る（同一sourceの再引用）。
4. 通信再送・分割により同一イベント重複が起こり得る。
5. 最終的な「本文中の番号」と「ソース一覧」が一致しなければならない。

---

**§3. 既存アプローチとその限界**

**§3.1 アプローチ1: 事後採番（Post-hoc Renumbering） — 手法 / 利点 / 限界**
手法: ストリーム中は内部IDや仮番号で表示し、完了後に全文を再走査して連番化。
利点: 最終形の見栄えが良く、理想的な連番順を作りやすい。
限界: 途中表示と最終表示で番号が変わり、不変性要件に違反。

**§3.2 アプローチ2: 検索順位固定採番（Pre-number by Retrieval Rank） — 手法 / 利点 / 限界**
手法: `source_i` の検索順位をそのまま `[i]` として使う。
利点: 実装が単純で番号は不変。
限界: 本文の初出順と番号順が乖離し、可読性が低い。未引用ソースが一覧に混入しやすい。

**§3.3 アプローチ3: 可変再マッピング（Mutable Client Remap） — 手法 / 利点 / 限界**
手法: クライアント側で都度再採番し、表示済み番号を書き換える。
利点: 最終的な連番品質は高い。
限界: 「一度表示した番号が変わらない」要件を満たせず、ユーザー認知負荷が高い。

---

**§4. 問題の本質**
本問題は、**未来未確定のストリームに対するオンラインラベリング問題**です。必要なのは、
1. `source_id -> display_number` の写像を逐次確定し、
2. 一度確定した写像を不変に保ち、
3. 最終ソース一覧を同一写像から機械的に生成することです。
要するに、「可読性の高い連番」と「オンライン不変性」を同時に満たすには、**初回出現時の単調確定**が必要です。

---

**§5. 提案手法**

**§5.1 基本原理**
提案は **First-Use Monotonic Binding (FUMB)** です。
1. 引用は構造化イベント `CITE(source_id)` として受信する。
2. 初回出現時のみ次番号を割当てる。
3. 割当て表は追記専用（append-only）で更新し、再割当てしない。
4. 最終ソース一覧は同じ割当て表から生成する。

不変条件:
- 不変性: ある時刻 `t` で `f(source)=k` なら、`t' > t` でも `k`。
- 一意性: 異なる `source` に同一 `k` を割り当てない。
- 完全性: 本文に出た `k` は最終一覧に必ず存在。

**§5.2 実装アーキテクチャ**
構成要素:
1. `Source Registry`: 当該回答で有効な `source_id` 集合を保持。
2. `Citation Binder`: `source_id -> number` の永続マップを管理。
3. `Stream Renderer`: `CITE(source_id)` を `[number]` に即時変換。
4. `Finalizer`: ストリーム完了時に番号順でソース一覧を確定。

処理規則（要点）:
- `source_id` 未登録ならエラー扱い（表示禁止または未検証タグ）。
- 既登録なら既存番号を再利用。
- 未割当てなら `next_number` を採番し即時表示。
- 完了時に「本文使用番号集合」と「一覧」を同一Binderから出力し整合保証。

---

**§6. 検証可能な性質（Given/When/Then）**

1. 初回採番の不変性
Given: `Binder` が空。
When: `CITE(source_7)` を受信。
Then: `[1]` を表示し、以後 `source_7` は常に `[1]`。

2. 再引用の再利用
Given: `source_7 -> 1` が確定済み。
When: 後続で再度 `CITE(source_7)`。
Then: 新規採番せず `[1]` を表示。

3. 出現順連番
Given: 有効ソース `source_7, source_3`。
When: ストリーム順が `CITE(source_7)` の後に `CITE(source_3)`。
Then: 表示は `[1][2]` となり、`source_7 -> 1`, `source_3 -> 2`。

4. 完了時整合
Given: 本文中に表示された番号集合が `{1,2}`。
When: ストリーム完了処理を実行。
Then: 最終ソース一覧は `[1]` と `[2]` の2件のみを含み、対応sourceが一致。

5. 冪等性（再送耐性）
Given: 同一 `CITE` イベントが再送される可能性。
When: 同一イベントIDの重複を受信。
Then: 採番状態は変化せず、重複による新規番号発生は起きない。

---

**§7. 制約と今後の課題**
1. LLM出力に構造化引用イベントが必要で、自由文からの後段抽出は誤検出リスクが高い。
2. 途中で本文を書き換える編集型ストリームでは、番号不変と本文整形の両立設計が別途必要。
3. 未検証引用（レジストリ外source）へのUI方針はプロダクト要件依存。
4. 今後は、引用スパン単位の根拠検証、会話横断の番号戦略、分散環境での順序保証プロトコルが課題です。

以上により、FUMBは「リアルタイム表示」「番号不変」「完了時整合」を同時達成する、実装可能かつ検証容易な設計といえます。
