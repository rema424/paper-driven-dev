# Output #006

**設計分析（要件の衝突点）**
- 「低レイテンシ」は本来ステートレスJWTが有利です。
- ただし「即時無効化」は中央状態（セッション/失効情報）参照が必要です。
- したがって、**完全ステートレス**か**毎回DB照会**の二択ではなく、**ハイブリッド構成**が最適です。

**推奨アーキテクチャ（ハイブリッド）**
1. `Access Token`: 短寿命JWT（3〜5分）
2. `Refresh Token`: 長寿命・ローテーション付き（DB/Redisで管理）
3. `Session Store`: Redis Cluster（高速）+ RDB（監査・永続化）
4. `Revocation Event`: Redis Streams or Kafkaで全APIノードへ配信
5. APIノードはローカルL1キャッシュ（失効sid/ユーザーepoch）を持つ

**トークン/セッション設計**
- JWT claims: `tid(tenant)`, `uid`, `sid(session_id)`, `ue(user_epoch)`, `exp`, `iat`, `aud`
- セッションは「端末ごと」に1レコード（同時ログインを自然に実現）
- 管理者による全端末無効化は `user_epoch` をインクリメント
- 特定端末のみ無効化は `sid` を失効セットへ追加

**認証フロー（低遅延）**
1. APIノードでJWT署名検証（ローカル鍵キャッシュ）
2. `exp/aud/tid` を検証
3. L1キャッシュで `sid失効` と `user_epoch` を確認
4. キャッシュミス時のみRedisを1回参照（`MGET`/パイプライン）
5. 失効イベント受信でL1を即時更新

**要件への対応**
- 複数端末同時ログイン: 端末単位セッションで対応
- 管理者の即時無効化: `sid失効` または `user_epoch更新` + イベント配信
- 水平スケーリング: APIサーバーはステートレス、Redis/DBは共有
- 認証レイテンシ最小化: 通常はローカル検証+L1参照、必要時のみRedis

**実装上の重要ポイント**
- キーは必ずテナント境界付き（例: `t:{tid}:u:{uid}:epoch`）
- 失効情報TTLはトークン有効期限に合わせる
- イベント遅延時のフェイルセーフとして「一時的にRedis厳密照会モード」を用意
- 管理操作は監査ログ必須（誰がいつ何を失効したか）

必要であれば次に、`Redisキー設計` と `APIエンドポイント（login/refresh/revoke）` まで具体化します。
