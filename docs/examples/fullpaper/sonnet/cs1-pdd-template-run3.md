# CS1 条件C: PDD Template — RAG引用リナンバリング (Run 3)

> **Run**: CS1-C-Run3
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

# RAGストリーミング環境における引用リナンバリングの設計分析

## §1. 問題定義

### §1.1 背景

Retrieval-Augmented Generation（RAG）システムは、ユーザーの質問に対して外部知識ベースから関連文書を検索し、その検索結果をコンテキストとしてLLMに与えて回答を生成するアーキテクチャである。システムの透明性と信頼性を高めるため、RAGシステムは回答の各主張がどの検索結果（ソース）に基づくかを引用として明示することが一般的に要求される。

LLMによる回答生成においては、ユーザー体験の向上を目的としてストリーミング方式が広く採用される。ストリーミングとは、回答全体が生成完了するまで待機するのではなく、生成されたトークンを逐次的にクライアントに送信してリアルタイム表示を行う方式である。この方式はユーザーの知覚的な待機時間を削減し、インタラクションの流動性を高める。

しかしながら、RAGシステムにおけるストリーミング生成と引用表示の組み合わせは、本質的な設計上の困難を生む。LLMが回答内で参照するソースは内部識別子（例: `source_3`, `source_7`）として表現されるが、ユーザーには `[1]`, `[2]`, `[3]` のような連番表示が求められる。ストリーミング中に「どのソースが最終的に使われるか」が未確定である状況において、この変換をいかに実現するかが本稿の問題の核心である。

### §1.2 矛盾する要求（対立するトレードオフ）

本問題には以下の複数のトレードオフが内在する。

**トレードオフ1: リアルタイム性と完全性**

ストリーミング表示によるリアルタイム性を実現するためには、LLMが各引用を生成した時点で即座にそれをユーザーに表示する必要がある。しかし引用の連番を確定するには、ストリーム全体が完了して「どのソースが実際に使用されたか」の全貌が判明するまで待機することが理想的である。この二つの要求は原理的に矛盾する。リアルタイムに番号を割り当てれば未確定の情報に基づく仮の番号となり、完全性を保証しようとすれば表示の遅延が生じる。

**トレードオフ2: 番号の安定性と情報の正確性**

「一度表示した引用番号を変更しない」という安定性の要求は、ユーザーがすでに目にした番号との整合性を保護する観点から重要である。しかし最終的なソース一覧との整合性を保とうとすると、ストリーム途中で割り当てた番号が最終状態と乖離する可能性がある。たとえば、LLMが `source_3` を最初に参照し `[1]` と仮割り当てしたが、最終的にストリーム全体で使われたソースが `source_1`, `source_3`, `source_7` であり、最終ソース一覧を昇順で整列した場合、`source_3` の最終番号は `[2]` となりうる。番号を固定すれば正確性が損なわれ、正確性を追求すれば安定性が損なわれる。

**トレードオフ3: 生成の自由度とシステム制御可能性**

LLMはプロンプトによって引用形式をある程度誘導できるが、その生成順序と引用パターンは本質的に確率的であり、システムが完全に制御することは困難である。引用順序をシステムが制御しようとすれば、LLMの自然な生成フローに制約を加えることになり、回答品質の低下や生成コストの増大を招く。一方でLLMの自由な生成を許容すれば、引用管理の複雑性がシステム側に集中する。

### §1.3 本文書の範囲

本稿は、上述した三つのトレードオフを前提として、RAGストリーミング環境における引用リナンバリングの設計問題を分析する。具体的には、現状のアーキテクチャと制約を整理した上で、既存アプローチとその限界を検討し、トレードオフを許容可能な範囲に収める提案手法を示す。提案手法は特定のLLMプロバイダや実装言語に依存しない設計原則として記述する。

---

## §2. 現状のアーキテクチャと制約

一般的なRAGストリーミングシステムは以下のコンポーネントから構成される。

**検索層（Retrieval Layer）**: ユーザーのクエリをベクトル化し、ベクトルデータベースに対してk近傍探索を行い、上位N件のドキュメントチャンクを取得する。取得されたチャンクにはシステム内部の識別子（`source_0` 〜 `source_{N-1}`、あるいはドキュメントIDとチャンクIDの組み合わせ）が付与される。

**生成層（Generation Layer）**: 検索結果とシステムプロンプトをコンテキストとしてLLMに入力し、回答を生成する。LLMはストリーミングAPIを通じてトークン列を逐次出力する。引用はLLMが内部識別子を角括弧等で参照する形式（例: `[source_3]`）で表現されることが多い。

**表示層（Presentation Layer）**: ストリームから受信したトークンを解析し、引用マーカーを検出して連番に変換し、クライアントに送信する。

この構成における主要な制約は以下の通りである。

- **ストリームの単方向性**: ストリームは一方向にのみ進行し、一度送信されたテキストをクライアント側で「撤回」または「差し替え」することは標準的なHTTPストリーミング（Server-Sent Events、チャンク転送）では困難である。WebSocketやServer-Sent Eventsの追記的な性質上、既出のテキストへの遡及変更にはクライアント側での特別な状態管理が必要となる。

- **LLMの生成順序の非制御性**: LLMは文脈的に自然な順序でソースを参照するため、引用の出現順序はシステムが事前に予測できない。

- **部分的なトークン境界**: ストリームのチャンク境界が引用マーカーの内部で分割される場合がある（例: `[sour` と `ce_3]` が別チャンクで到着する）。これにより単純な文字列マッチングは困難となる。

---

## §3. 既存アプローチとその限界

### §3.1 アプローチ1: ポストプロセッシング（後処理リナンバリング）

**手法**

LLMのストリーム全体を受信バッファに蓄積し、生成完了後に全文を解析して引用を連番に置換する。置換後のテキストを一括でクライアントに送信する。

**利点**

実装が単純であり、全引用の出現順序が確定した状態で置換を行うため、連番の正確性と整合性を完全に保証できる。ソース一覧は使用済みソースのみを順番通りに列挙できる。

**限界**

ストリーミングの本質的な利点であるリアルタイム表示が損なわれる。ユーザーは生成完了まで一切のテキストを受け取れず、LLMの生成時間が長い場合（長文回答、複数ソース参照）には体験の劣化が著しい。本要件「ストリーミング中にリアルタイムで引用番号を表示する」を正面から満たさない。

### §3.2 アプローチ2: 内部識別子のそのまま表示

**手法**

ストリーム中にLLMが生成した引用識別子（`source_3` など）をそのままユーザーに表示する。ソース一覧はストリーム完了後に追記する。

**利点**

変換ロジックが不要であり、実装コストが最小限である。表示される情報がLLMの生成そのままであるため、生成と表示の乖離が生じない。

**限界**

`source_3` のような内部識別子はユーザーにとって意味を持たず、可読性が著しく低い。システムの内部構造がユーザーインターフェースに漏出する設計上の問題がある。また、識別子の形式がシステムの実装依存であるため、ユーザー体験の一貫性が損なわれる。

### §3.3 アプローチ3: 出現順即時割り当て（ファーストカム・ファーストサーブ）

**手法**

ストリームを解析し、新たなソース識別子が初めて出現した時点で即座に連番（`[1]`, `[2]`, ...）を割り当て、その割り当てをセッション中固定する。以降、同一識別子が再出現した場合は同一番号を表示する。

**利点**

リアルタイム表示が実現される。一度割り当てた番号は変更されないため、番号の安定性が保証される。ストリーム完了後のソース一覧は、割り当て済みの番号に対応するソースを順番に並べれば整合する。

**限界**

番号の割り当て順序が「LLMが最初にそのソースを参照した順」に依存するため、最終的なソース一覧の並び順が文書の重要度や関連度とは無関係になる。また、LLMがあるソースに言及した後に参照をやめる場合（ストリームの前半で `source_5` に言及し後半では使用しない場合）、そのソースが割り当て済み番号を持ちながらソース一覧に登場するという不整合が生じうる。さらに、チャンク境界での識別子分割への対処が必要である。

### §3.4 アプローチ4: クライアントサイドリプレース（二段階表示）

**手法**

サーバーはストリーム中に内部識別子をプレースホルダー（例: `{{source_3}}`）として送信し、クライアントがリアルタイムでローカルの対応表に基づいて連番に変換して表示する。ストリーム完了後にサーバーから最終的なソース一覧と番号対応表を送信し、クライアントが表示を更新する。

**利点**

サーバーとクライアントの責務が分離される。プレースホルダーのままでは表示しないため、ユーザーには常に連番が見える。最終対応表受信後のクライアント側更新が可能。

**限界**

クライアントの実装複雑性が著しく増大する。「一度表示した番号が後から変わらない」という要件と「ストリーム完了時にソース一覧と整合」の両立のために、クライアントが最終対応表受信後に過去の表示を修正する必要が生じ、番号の安定性要件に抵触する可能性がある。また、DOMの遡及的書き換えはシングルページアプリケーションでは技術的に可能だが、アクセシビリティや読み上げの整合性に悪影響を及ぼす。

---

## §4. 問題の本質

前節の分析から、問題の本質は以下のように定式化できる。

**出現順即時割り当て（§3.3）は、三つのトレードオフのうち「リアルタイム性」と「番号の安定性」を同時に達成する唯一のアプローチである。** 残る課題は「ストリーム完了時のソース一覧との整合」であるが、これは「ソース一覧の整合の定義」を再定義することで解決できる。

具体的には、「ソース一覧の整合」を「ソースが最終的な重要度順に整列されている」と定義するのではなく、「ソース一覧がストリーム中に表示された引用番号と一対一対応している」と定義し直せば、出現順割り当てで生成された番号とソース一覧は自然に整合する。

さらに、§3.3の限界として挙げた「途中で参照をやめたソースの扱い」は、割り当てポリシーに「ソースが実際にストリームに出現した場合のみ割り当てる」という条件を加え、ストリーム完了時にソース一覧を確定することで解決できる。すなわち：

1. ストリーム中: 出現順に即時割り当て（リアルタイム性と安定性の保証）
2. ストリーム完了後: 出現したソースのみをリスト化（整合性の保証）

この設計では、割り当て済みだが結果的に使われなかったソースという状況は発生しない。なぜなら、「割り当て」は「ストリームへの出現」と同義であり、出現したソースは必ずソース一覧に登録されるからである。

残る技術的な課題はチャンク境界での識別子分割への対処であり、これはステートフルなパーサーによって対処可能である。

---

## §5. 提案手法

### §5.1 基本原理

提案手法の基本原理は**出現優先即時割り当て（First-Occurrence Immediate Assignment, FOIA）**と名付ける。以下の三つの不変条件を設計の基礎とする。

**不変条件1（即時性）**: ストリーム中にソース識別子が初めて出現した時点で、即座に次の連番を割り当て、その番号を含むテキストをクライアントに送信する。

**不変条件2（単調性）**: 一度割り当てられた番号とソースの対応は、以後変更されない。

**不変条件3（完全性）**: ストリーム完了時に、割り当てられた全ての番号に対応するソース情報がソース一覧として送信され、番号とソースの対応が明示される。

この三つの不変条件は相互に矛盾せず、§1.2で定義した三つのトレードオフに対してそれぞれ対応する。

### §5.2 実装アーキテクチャ

実装は以下のコンポーネントから構成される。

**コンポーネント1: ステートフルストリームパーサー（StreamParser）**

LLMのストリーム出力を受信し、引用識別子を検出する責務を持つ。引用識別子の形式は正規表現で定義し（例: `\[source_\d+\]`）、チャンク境界をまたぐ識別子に対してバッファリング処理を行う。

```
StreamParser:
  state: partial_buffer = ""

  on_chunk(chunk):
    candidate = partial_buffer + chunk

    # 完全な識別子を全て抽出
    for each complete_citation in extract_complete_citations(candidate):
      emit CiteFound(citation)

    # 末尾の不完全なパターンをバッファに保持
    partial_buffer = remaining_incomplete_prefix(candidate)

    # 識別子以外のテキスト部分を即座に emit
    emit Text(non_citation_text(candidate))

  on_end():
    flush partial_buffer as Text
    emit StreamEnd
```

**コンポーネント2: 引用マップマネージャー（CitationMapManager）**

FOIAポリシーを実装するコンポーネントである。内部識別子から連番への対応表を管理する。

```
CitationMapManager:
  state:
    citation_map: Map<InternalId, DisplayNumber> = {}
    next_number: int = 1
    ordered_citations: List<InternalId> = []

  get_or_assign(internal_id) -> DisplayNumber:
    if internal_id not in citation_map:
      citation_map[internal_id] = next_number
      ordered_citations.append(internal_id)
      next_number += 1
    return citation_map[internal_id]

  get_source_list(source_metadata: Map<InternalId, SourceInfo>) -> List<(DisplayNumber, SourceInfo)>:
    return [(citation_map[id], source_metadata[id]) for id in ordered_citations]
```

**コンポーネント3: ストリームトランスフォーマー（StreamTransformer）**

StreamParser と CitationMapManager を接続し、変換済みのストリームを出力する。

```
StreamTransformer:
  parser: StreamParser
  cmap: CitationMapManager
  source_metadata: Map<InternalId, SourceInfo>  # 検索層から取得済み

  on_text(text):
    send_to_client(text)

  on_cite_found(internal_id):
    display_number = cmap.get_or_assign(internal_id)
    send_to_client("[" + str(display_number) + "]")

  on_stream_end():
    source_list = cmap.get_source_list(source_metadata)
    send_source_list_to_client(source_list)
```

**データフロー**

```
LLM Stream
    ↓
StreamParser
    ├─ Text → StreamTransformer → Client
    └─ CiteFound(internal_id)
            ↓
       CitationMapManager
            ↓ display_number
       StreamTransformer → Client
                                ↑
                    StreamEnd → source_list → Client
```

**ストリーミングプロトコルの考慮**

クライアントへの送信にはServer-Sent Events（SSE）を推奨する。各イベントにはイベント種別を付与する。

- `event: text`: 通常テキストチャンク
- `event: citation`: 引用番号（`data: {"display": 1, "internal": "source_3"}`）
- `event: sources`: ストリーム完了後のソース一覧（`data: [{number: 1, title: "...", url: "..."}, ...]`）
- `event: done`: ストリーム終了

---

## §6. 検証可能な性質

提案手法の正確性は以下のGiven/When/Then形式のテスト可能な性質として定義する。

---

**性質1: 初出識別子への即時割り当て**

- Given: CitationMapManagerが空の対応表を持ち、StreamTransformerが初期化されている
- When: ストリームに `[source_5]` が初めて出現する
- Then: クライアントは `[1]` を受信し、内部対応表に `source_5 → 1` が記録される

---

**性質2: 再出識別子への同一番号返却**

- Given: `source_5 → 1` の対応が既に記録されている
- When: ストリームに `[source_5]` が再び出現する
- Then: クライアントは `[1]` を受信し、対応表は変更されない（next_numberは増加しない）

---

**性質3: 複数識別子への連番割り当て**

- Given: CitationMapManagerが空の対応表を持つ
- When: ストリームに `[source_7]`, `[source_2]`, `[source_7]`, `[source_9]` がこの順で出現する
- Then: クライアントは順に `[1]`, `[2]`, `[1]`, `[3]` を受信し、対応表は `{source_7→1, source_2→2, source_9→3}` となる

---

**性質4: ソース一覧の整合性**

- Given: ストリームが完了し、対応表が `{source_7→1, source_2→2, source_9→3}` である
- When: `on_stream_end()` が呼ばれる
- Then: クライアントが受信するソース一覧は番号1, 2, 3の順に `source_7`, `source_2`, `source_9` に対応するメタデータを含み、それ以外のソースは含まれない

---

**性質5: チャンク境界をまたぐ識別子の正確な検出**

- Given: StreamParserが空のバッファで初期化されている
- When: 連続するチャンク `"回答テキスト[sour"` と `"ce_3]の続き"` が到着する
- Then: `[source_3]` が正確に1回 CiteFound として emit され、前後のテキストは Text として emit される

---

**性質6: ストリーム完了前の番号不変性**

- Given: ストリーム処理中に `source_3 → 1` が割り当てられた
- When: その後ストリームの任意の位置で新たなソース識別子が出現する
- Then: `source_3` の表示番号は `1` のまま変化しない

---

**性質7: 空ストリームの安全な処理**

- Given: StreamTransformerが初期化されている
- When: 引用識別子を一切含まないストリームが完了する
- Then: ソース一覧は空リストであり、クライアントはエラーを受信しない

---

## §7. 制約と今後の課題

**制約1: ソースメタデータの事前取得要件**

提案手法は、ストリーム開始前に検索層から全候補ソースのメタデータ（タイトル、URL等）を取得していることを前提とする。オンデマンドでメタデータを取得する構成（遅延フェッチ）では、ストリーム完了時のソース一覧生成に非同期処理が必要となり、実装の複雑性が増す。

**制約2: LLMが識別子形式を遵守することへの依存**

StreamParserは事前定義した正規表現パターンで識別子を検出する。LLMが指示に反して異なる形式（例: `[3]` のような連番を直接使用、または引用を省略）で生成した場合、検出は失敗する。この問題はプロンプトエンジニアリングによる軽減が可能だが、完全な保証は困難である。

**制約3: 番号順序のユーザー期待との乖離**

FOIA方式では引用番号の順序がLLMの生成順（文脈的な自然な登場順）に依存するため、ユーザーがソースの重要度や文書内の登場頻度に基づく順序を期待する場合、その期待と乖離する。これは根本的なトレードオフであり、本設計の選択としてドキュメント化すべきである。

**今後の課題1: ブラウザ側でのストリーム更新**

WebSocketを採用した場合、ストリーム完了後にクライアントがソース一覧の最終確定情報を受け取り、引用番号の周囲に追加のUIコンテキスト（ホバーツールチップ、クリックでソースプレビュー）を付与することが可能になる。この機能拡張とSSEとの親和性の評価は今後の課題である。

**今後の課題2: マルチターン対話における引用の継続性**

本稿は単一のユーザーターンに対するシングルストリームを前提とする。マルチターン対話では、前のターンで表示された引用番号と新ターンの引用番号の関係（継続/リセット）についての設計判断が必要となる。

**今後の課題3: 同一コンテンツの複数ソースの扱い**

異なる内部識別子（`source_2`, `source_8`）が実質的に同一のドキュメントを指す場合（重複チャンク）、FOIA方式では異なる連番が割り当てられる。重複排除をストリーム前処理として行うか、後処理として行うかは、検索層の設計と連携した判断が必要である。

**今後の課題4: ストリームの異常終了への対処**

ネットワーク障害やLLMのエラーによりストリームが途中で終了した場合、`on_stream_end()` が呼ばれずソース一覧が送信されない可能性がある。タイムアウト検出と部分的なソース一覧送信のフォールバック機構の設計が必要である。
