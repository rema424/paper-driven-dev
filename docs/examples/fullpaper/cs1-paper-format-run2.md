# CS1 条件B: Paper Format — RAG引用リナンバリング (Run 2)

> **Run**: CS1-B-Run2
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c79a2-0c82-7583-9c9c-7832e592aa64)
> **Model**: GPT-5.2 (via Codex)

---

**題目**
ストリーミングRAGにおける不変連番引用のオンライン割当て設計

**要旨**
本稿は、RAGシステムのストリーミング生成中に、内部参照（例: `source_3`, `source_7`）をユーザー向け連番引用（例: `[1]`, `[2]`）へ変換する設計を示します。要件は、(R1) リアルタイム表示、(R2) 表示後の番号不変、(R3) 完了時の参考文献整合です。提案は「初出順・単調割当て（Monotonic First-Seen Mapping）」であり、引用ID→表示番号の写像を追記専用で管理します。この方式は実装が軽量で、3要件を同時に満たせます。

**キーワード**
RAG、ストリーミング生成、引用管理、オンラインアルゴリズム、整合性保証

## 1. 問題設定
LLMは生成中にどのソースを使うかが逐次的に決まるため、後処理で一括採番すると表示済み番号の変更が起こり得ます。これはR2に反します。
したがって、採番は「オンライン（逐次）」で行い、かつ過去決定を変更しない設計が必要です。

## 2. 提案手法
### 2.1 基本方針
1. LLM出力には機械可読な引用マーカ（例: `<cite id="source_7"/>`）を含めます。
2. ストリーム受信側でマーカを検出した時点で番号を確定します。
3. 未登場ソースには次の番号を付与し、既登場ソースは同じ番号を再利用します。
4. 完了時は確定済み写像から参考文献一覧を生成します。

### 2.2 状態
- `id2num: Map<source_id, int>`
- `num2id: Array<source_id>`（1始まり相当）
- `next_num: int`（初期値1）

### 2.3 オンライン割当てアルゴリズム
```text
onCitation(source_id):
    if source_id not in id2num:
        id2num[source_id] = next_num
        num2id[next_num] = source_id
        next_num += 1
    emit("[" + id2num[source_id] + "]")
```

## 3. 性質（要件適合）
**命題1（リアルタイム性）**
引用マーカ検出時に即時 `emit` するためR1を満たします。

**命題2（番号不変）**
`id2num` は追記のみで更新し、既存キーの値を変更しないため、表示後番号は不変です（R2）。

**命題3（完了時整合）**
参考文献一覧を `num2id[1..next_num-1]` から生成すれば、本文内番号と一対一対応します（R3）。

## 4. 実装上の注意
1. **追記専用ストリーム前提**: プロバイダがロールバックを返す場合は「コミット済みチャンクのみ表示」層を挟みます。
2. **部分トークン対策**: マーカがチャンク分割されるため、パーサにバッファを持たせます。
3. **不正ID対策**: 検索集合外IDは表示せずログ化、または明示的に無効表示ポリシーを定義します。
4. **再接続対策**: `id2num` をセッション永続化し、途中復帰でも番号を維持します。

## 5. 方式比較（簡潔）
- 後処理一括採番: 実装容易だがR2違反。
- 検索順位の事前固定採番: 不変だが可読性（連番の自然さ）が低い。
- 提案方式: 可読性・不変性・整合性を同時達成。

## 6. 結論
ストリーミングRAGの引用表示には、**初出順・単調割当て**が最小構成で有効です。
この設計により、生成途中で `[1][2]...` を即時提示しつつ、番号の後変更を防ぎ、完了時の参考文献一覧と厳密に整合できます。
