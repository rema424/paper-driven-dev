# CS2 条件D: Checklist — マルチテナントSaaSセッション管理 (Run 5)

> **Run**: CS2-D-Run5
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c79b7-82e7-7033-98e7-56d7a0bc453d)
> **Model**: GPT-5.2 (via Codex)

---

1. 問題の背景と文脈
マルチテナントSaaSでは、同一ユーザーがWeb/モバイルなど複数端末で同時利用する一方、管理者はセキュリティ事故や退職時に即時ログアウトを要求します。さらに、APIサーバーはオートスケール前提で、認証処理は高頻度で呼ばれるため、1リクエストあたりの認証遅延を極小化する必要があります。

2. 対立する要求やトレードオフ
2.1 即時無効化と低レイテンシ: 即時失効には中央状態参照が必要になりやすく、参照回数を増やすと遅延が増えます。
2.2 ステートレス性と失効制御: 完全JWT検証のみは高速ですが、管理者失効を即時反映しづらいです。
2.3 長寿命トークンとセキュリティ: 長寿命はUX/負荷に有利ですが、漏えい時の被害時間が長くなります。
2.4 厳密なテナント分離と運用効率: 共有基盤は効率的ですが、キー設計や権限制御を誤ると越境リスクが出ます。

3. 分析の対象範囲
対象は、ログイン・トークン発行、リクエスト時認証、管理者失効API、キャッシュ/配信、スケール時の整合性です。
対象外は、MFA詳細、業務権限モデル（認可ポリシー全体）、IdP連携の仕様詳細です。

4. 現状のアーキテクチャと制約（想定）
APIノードはステートレスでLB配下、共有のRedisクラスタとRDBを利用します。
制約は、非スティッキー運用、テナント境界の厳守、イベント配信遅延/重複への耐性、障害時の安全側動作（少なくとも管理系はfail-closed）です。

5. 既存の解決アプローチとその限界
5.1 アプローチ1: Opaque Session + Redis照会
手法: 毎リクエストでsession_idをRedis照会。
利点: 失効が単純で即時性が高い。
限界: 毎回ネットワークI/Oが発生し、認証遅延とRedis集中負荷が増える。

5.2 アプローチ2: 完全ステートレスJWT
手法: 署名・期限のみローカル検証。
利点: 高速で水平スケールしやすい。
限界: 管理者による即時失効が困難。ブラックリスト導入で中央参照が復活。

5.3 アプローチ3: Introspection API集中
手法: Gateway/認証サーバーで都度トークン照会。
利点: 失効制御を集中管理しやすい。
限界: ホットスポット化しやすく、遅延と可用性リスクが増える。

5.4 アプローチ4: ハイブリッド（短命Access + Refresh + 失効バージョン）
手法: Accessは短命JWT、Refreshは状態管理、失効はユーザーバージョンで管理。
利点: 低遅延と即時失効のバランスが取れる。
限界: 実装が複雑で、イベント遅延時の整合性設計が必要。

6. 問題の本質的な困難
分散環境で「全ノードに即時反映される失効」と「各リクエストで中央参照しない低遅延」を同時に満たすことが本質的に難しい点です。加えて、複数端末セッションの粒度（全失効/個別失効）とテナント分離を同時に安全に扱う必要があります。

7. 解決策
7.1 基本原理
短命Access JWT（例: 3〜5分）をローカル検証し、失効は「ユーザー単位の`session_version`」と「セッション単位の失効キー」の二層で管理します。失効操作時はRedis更新＋イベント配信で各ノードのローカルキャッシュを即時更新します。

7.2 実装方針
トークンClaimは`tid, uid, sid, sv, exp, jti`を必須化。
Redisキーは`sv:{tid}:{uid}`（整数）と`rvk:{sid}`（TTL付き）を利用。
ログイン時は`sid`を発行し、現在`sv`を埋めたAccess/Refreshを発行。
認証時は署名検証後、ローカルキャッシュで`sv`一致と`sid`失効有無を判定し、キャッシュミス時のみRedis参照。
「特定ユーザー全失効」は`INCR sv:{tid}:{uid}`を原子的に実行し、イベント配信。
「特定セッション失効」は`SET rvk:{sid}`を実行し、イベント配信。
Refreshはローテーション前提で、失効済み`sid`または旧`sv`は再発行不可。
APIノードは完全ステートレスのまま増減可能です。

8. 検証条件（Given/When/Then）
8.1 Given 同一ユーザーが2端末でログイン済み。When 両端末が同時にAPI呼び出し。Then 両方200で独立セッションとして継続利用できる。
8.2 Given ユーザーに3セッションが存在。When 管理者が「全セッション失効」を実行。Then 1秒以内に全ノードで次回リクエストが401になる。
8.3 Given セッションA/Bが有効。When 管理者がAのみ失効。Then Aは401、Bは200を維持。
8.4 Given APIノード4台で運用中。When 4→12→4台にスケール。Then セッション継続性を保ち、認証エラー率がSLO内（例: 0.1%未満）。
8.5 Given キャッシュヒット率95%以上。When 認証処理を高負荷実行。Then 認証追加遅延がp95 2ms以下、p99 5ms以下。
8.6 Given テナントX管理者とテナントYユーザー。When X管理者がYユーザー失効を試行。Then 403で拒否され、Y側キーは不変。

9. 制約、限界、今後の課題
「即座」は物理的に厳密同時ではなく、SLO（例: 1秒以内）として定義する必要があります。
イベント遅延や分断時には短時間の不整合窓が残るため、短命Access TTLで被害時間を限定します。
今後はマルチリージョン時の失効伝播最適化、失効監査の強化、障害注入（chaos）テストによる整合性検証を進めるのが実務的です。
