# CS2 条件D: Structured Checklist — マルチテナントSaaSセッション管理 (Run 2)

> **Run**: CS2-D-Run2
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

## 1. 問題の背景と文脈

マルチテナントSaaSにおけるセッション管理は、単一テナントのシステムと比較して根本的に異なる複雑性を持つ。各テナント（企業・組織）が独自のユーザーベース、セキュリティポリシー、コンプライアンス要件を持ち、それらを同一インフラ上で隔離しながら運用する必要がある。

現代のSaaSプロダクトでは以下の業務的背景が存在する。テレワークの普及によりユーザーは自宅PC、会社PC、スマートフォンなど複数端末から同時にサービスを利用する。一方、セキュリティインシデント発生時（アカウント侵害の疑い、退職者処理等）には管理者が即座にセッションを無効化できなければならない。さらにSaaSは利用者数の変動に応じてサーバーを動的にスケールさせるビジネスモデルが前提であり、セッション管理はこれを阻害してはならない。

認証レイテンシの最小化はユーザー体験に直結する。すべてのAPIリクエストに認証処理が伴うため、数十ミリ秒の差がシステム全体のレスポンスタイムに累積的な影響を与える。

## 2. 対立する要求やトレードオフ

**トレードオフ1: ステートレス性 vs. 即時無効化能力**

JWTのようなステートレストークンはサーバー側に状態を持たないため水平スケーリングとレイテンシ最小化に優れる。しかし「サーバー側の状態がない」という特性は「サーバー側から能動的にセッションを無効化できない」ことを意味する。トークン有効期限が切れるまでの時間（通常数時間〜1日）、無効化命令を出してもトークンが機能し続けてしまう。即時無効化のためにはブロックリストなどのサーバー側状態が必要だが、これはステートレス性を損なう。

**トレードオフ2: レイテンシ最小化 vs. 一貫性保証**

認証レイテンシを最小化するには各サーバーがローカルキャッシュでトークン検証を行うのが理想的である。しかしセッション無効化の情報が各サーバーのキャッシュに伝播するまでの時間（キャッシュ有効期限TTL）の間、無効化済みセッションが有効として扱われる可能性がある（結果整合性）。強い一貫性を保証するにはすべてのリクエストで中央ストアを参照する必要があり、レイテンシが増大する。

**トレードオフ3: 複数端末サポート vs. セッション管理の複雑性**

複数端末からの同時ログインをサポートすると、1ユーザーに対して複数のアクティブセッションが存在する。これは正常な状態であり悪意のある多重ログインと区別が難しい。また管理者が「ユーザーの全セッションを無効化」するときにすべての端末のセッションを正確に把握・管理する必要がある。セッション数の増加はストレージと検索の複雑性を高める。

**トレードオフ4: テナント分離 vs. インフラ効率**

テナントごとに完全に独立したセッションストアを持つと分離は完全だがリソース効率が悪い。共有インフラ上でテナントを論理的に分離する場合はコストは抑えられるが、テナント間の影響（ノイジーネイバー問題）やデータ漏洩リスクが生じる。

## 3. 分析の対象範囲

本分析では以下のスコープを対象とする。

- セッション発行メカニズム（ログイン処理）
- セッション検証メカニズム（各APIリクエストの認証処理）
- セッション無効化メカニズム（ログアウト、管理者による強制無効化）
- セッションストレージ層の設計
- マルチテナント隔離の実現方式
- 水平スケーリング時のセッション同期

スコープ外とする事項として、認証プロバイダーの選定（OAuth2/SAML等のプロトコル詳細）、アプリケーション層のビジネスロジック、ネットワーク層のセキュリティ（TLS設定等）は詳細分析の対象から除外する。

## 4. 現状のアーキテクチャと制約

典型的なマルチテナントSaaSの既存アーキテクチャは以下の構成を持つことが多い。

**典型的な既存構成:**

ロードバランサーが複数のアプリケーションサーバーにリクエストを分散させ、各アプリケーションサーバーはセッション検証のためにデータベースまたはキャッシュ層を参照する。データベースはテナントごとにスキーマを分離するか、テナントIDカラムでマルチテナント化されていることが多い。

**制約条件:**

- 既存のユーザー認証データベース（ユーザーID、パスワードハッシュ、テナント所属）が存在する
- 既存のAPIは認証ヘッダー（Authorization: Bearer）を前提に構築されている
- SLAとして認証処理のP99レイテンシを10ms以内に収めることが求められる
- テナントごとのデータ主権要件（欧州テナントのデータを欧州リージョンに保存等）が存在する場合がある
- セッション無効化は要件として「即座」（数秒以内）と定義する

## 5. 既存の解決アプローチとその限界

### 5.1 アプローチ1: ステートフルセッション（サーバーサイドセッション）

**手法:** ログイン時にサーバーがランダムなセッションIDを生成してデータベースまたはRedis等のインメモリストアに保存する。クライアントはセッションIDをCookieまたはヘッダーで保持する。各リクエストでサーバーはセッションIDを受け取り、ストアを参照してセッションの有効性を確認する。

**利点:** セッション無効化が即座に行える。セッションIDに対応するレコードを削除するだけでよい。複数端末管理が容易で、ユーザーIDをキーに全セッションを検索できる。テナント隔離もテナントIDをセッションレコードに含めることで実現できる。

**限界:** すべてのリクエストがセッションストアを参照するため、ストアがボトルネックになる。水平スケーリング時にセッションデータの共有が必要で、スティッキーセッションを使わない限り共有ストア（Redis等）が必要になる。共有ストアが単一障害点になりやすい。高トラフィック時のストア負荷が高い。

### 5.2 アプローチ2: JWT（JSON Web Token）によるステートレス認証

**手法:** ログイン時にサーバーが秘密鍵でJWTを署名して発行する。JWTにはユーザーID、テナントID、有効期限、権限情報等をペイロードに含める。各リクエストでサーバーはJWTの署名検証と有効期限チェックのみを行う。ストアへの参照が不要。

**利点:** ステートレスなため水平スケーリングが容易。各サーバーが独立して検証できる。レイテンシが低い（暗号演算のみで検証完了）。サーバー間でのセッション情報共有が不要。

**限界:** トークン発行後の即時無効化が本質的に困難。有効期限まで無効にできない。ブロックリスト（無効化したJWTのIDリスト）を導入するとステートレス性を失う。複数端末管理が困難で、発行したトークンをサーバーが追跡していないため「このユーザーの全端末のトークンを無効化する」ことができない。

### 5.3 アプローチ3: 短命JWTとリフレッシュトークンの組み合わせ

**手法:** アクセストークン（JWT、有効期限5〜15分）とリフレッシュトークン（長期間有効、サーバー側に保存）を組み合わせる。アクセストークンが期限切れになるとリフレッシュトークンを使って新しいアクセストークンを取得する。リフレッシュトークンはサーバー側でDBに保存し管理する。

**利点:** 無効化の最大遅延をアクセストークンのTTL（5〜15分）に限定できる。リフレッシュトークンを削除することで実質的な即時無効化に近い動作を実現できる。

**限界:** 無効化の即座性（数秒以内）という要件を厳密には満たせない（TTL分の遅延が残る）。クライアント実装が複雑になる。リフレッシュトークンストアはステートフルであり、これ自体がスケーリング上の課題を持つ。

### 5.4 アプローチ4: トークン無効化リスト（Blocklist/Denylist）

**手法:** JWTにjti（JWT ID）クレームを付与し、無効化時にそのjtiをブロックリスト（Redis等）に登録する。各リクエストでJWT検証後にjtiがブロックリストに存在するかを確認する。

**利点:** JWTの利便性を保ちつつ即時無効化を実現できる。ブロックリストは「無効化されたトークンのみ」を保持するため、通常時はリストが空に近くサイズが小さい。

**限界:** すべてのリクエストでブロックリストを参照するためステートレス性の利点が薄れる。ブロックリストが結局ボトルネックになりうる。JWTの有効期限が切れた後はブロックリストから削除できるが、有効期限が長いと大量のエントリが蓄積する。

## 6. 問題の本質的な困難

この問題の本質的な困難は「分散システムにおける即時性と効率性のトリレンマ」である。

ステートレス認証（効率性・スケーラビリティ）とステートフル管理（即時無効化・複数端末管理）は原理的に対立する。分散システムのCAP定理が示すように、一貫性（Consistency：無効化命令が即座に全サーバーに反映）と可用性（Availability：認証処理が常に低レイテンシで完了）をネットワーク分断下で同時に完全に満たすことはできない。

更に具体的に言えば、「即時無効化」と「低レイテンシ認証」の間には物理的な矛盾が存在する。低レイテンシのためにキャッシュを使うと無効化情報の伝播に時間がかかる。即時伝播のために常に中央ストアを参照するとレイテンシが増大する。

マルチテナントという次元が加わることで、テナントごとのポリシー差異（あるテナントは即時無効化必須、別のテナントは数分の遅延を許容する等）への対応も求められ、システムの複雑性が増す。

したがって「完全な即時無効化」「完全なステートレス性」「完全な低レイテンシ」の3つを同時に達成することは不可能であり、設計はこれらの間で許容可能なトレードオフを選択することになる。

## 7. 解決策

### 7.1 基本原理

**ハイブリッドトークンアーキテクチャ**を採用する。短命アクセストークン（JWT、TTL=60秒〜5分）と長命セッションリファレンストークン（サーバー管理）の2層構造を組み合わせる。

基本的なトレードオフの決定として「無効化の遅延を最大TTL（例: 60秒）以内に限定すること」を受け入れる代わりに、通常のリクエスト処理ではローカル検証のみで完結させてスケーラビリティと低レイテンシを確保する。

テナント隔離はストレージキーの設計で実現する（`{tenantId}:session:{sessionId}`形式）。

**Pub/Sub による準即時無効化:** セッション無効化イベントをメッセージブローカー（Redis Pub/Sub またはKafka）でブロードキャストし、各サーバーのローカルキャッシュを能動的に無効化することで、TTL切れを待たずに数秒以内の実質的な無効化を達成する。

### 7.2 実装方針

**セッションデータモデル:**

```
Session {
  sessionId: UUID,           // ランダム一意ID
  tenantId: string,          // テナント識別子
  userId: string,            // ユーザー識別子
  deviceId: string,          // 端末識別子（複数端末管理用）
  deviceName: string,        // ユーザー向け表示名
  createdAt: timestamp,
  lastActivityAt: timestamp,
  expiresAt: timestamp,      // 絶対有効期限
  isActive: boolean,         // 管理者による無効化フラグ
  ipAddress: string,         // セキュリティ監査用
  userAgent: string
}
```

**アクセストークン（JWT）:**

```
Payload {
  jti: UUID,                 // JWT固有ID（ブロックリスト照合用）
  sub: userId,
  tid: tenantId,             // テナントID
  sid: sessionId,            // セッションリファレンス
  iat: issuedAt,
  exp: issuedAt + 300        // 5分固定（要件に応じて調整）
}
```

**ストレージ設計（Redis）:**

```
# セッション情報（ハッシュ）
Key: {tenantId}:session:{sessionId}
Value: Session オブジェクトのフィールド群
TTL: セッションの絶対有効期限まで

# ユーザーのアクティブセッション一覧（セット）
Key: {tenantId}:user:{userId}:sessions
Value: Set<sessionId>
TTL: 最長セッション有効期限まで

# テナントの全セッション（管理用）
Key: {tenantId}:sessions
Value: Set<sessionId>
TTL: 管理クエリ用（定期的なクリーンアップを実施）
```

**リクエスト認証フロー:**

1. クライアントがAuthorizationヘッダーでJWT（アクセストークン）を送信する。
2. サーバーがJWTの署名をローカルに検証する（ストア参照なし）。
3. サーバーが有効期限をローカルに検証する（ストア参照なし）。
4. サーバーがローカルキャッシュ（インメモリ）で無効化済みjtiを確認する。ヒットしたら即座に401を返す。
5. キャッシュミスの場合、P(無効化)が低い通常ケースでは検証完了とみなしてリクエストを処理する。（高セキュリティエンドポイントのみRedis確認を追加する）
6. バックグラウンドで定期的にRedisの無効化リストをポーリングしてローカルキャッシュを同期する。

**セッション無効化フロー（管理者操作）:**

1. 管理者がAPIで特定ユーザーまたはセッションの無効化を指示する。
2. サーバーがRedisのセッションレコードを `isActive: false` に更新する。
3. サーバーがPub/Subチャンネル `{tenantId}:session-revoked` にメッセージを発行する。
4. 全アプリケーションサーバーがメッセージを受信してローカルキャッシュに無効化済みjtiを追加する。
5. 以降のリクエストで該当セッションのJWTはステップ4のキャッシュヒットにより即座に拒否される（数秒以内）。
6. JWTのTTL（5分）経過後、ブロックリストからエントリを削除してキャッシュを縮小する。

**複数端末管理:**

管理者コンソールはユーザーIDを指定して `{tenantId}:user:{userId}:sessions` のセットを参照し全アクティブセッションを一覧表示する。各セッションは `deviceName`、`lastActivityAt`、`ipAddress` を表示する。「全端末からのログアウト」操作はセット内の全sessionIdに対して無効化フローを実行する。

**水平スケーリング対応:**

アプリケーションサーバーは完全にステートレスである（ローカルキャッシュはプロセス内の揮発性メモリで、サーバー再起動で自動的にリフレッシュされる）。新しいサーバーが起動すると自動的にPub/Subチャンネルをサブスクライブして以降の無効化メッセージを受信する。起動時に直近N分間の無効化済みjtiリストをRedisから取得してローカルキャッシュを初期化する。RedisはCluster構成またはRedis Sentinelでハイアベイラビリティを確保する。

## 8. 検証条件

**シナリオ1: 複数端末同時ログイン**

- Given: テナントAのユーザーUが存在し、セッションは複数端末許可のポリシーを持つ
- When: ユーザーUがデバイスD1（PC）とデバイスD2（スマートフォン）からそれぞれログインする
- Then: D1とD2それぞれに異なるsessionIdを持つJWTが発行される。`tenantA:user:U:sessions` セットにsessionId1とsessionId2が登録される。D1のJWTを使ったAPIリクエストが成功する。D2のJWTを使ったAPIリクエストが成功する。管理コンソールでユーザーUのアクティブセッションが2件表示される。

**シナリオ2: 管理者による特定セッション無効化**

- Given: ユーザーUがD1とD2の2つのアクティブセッションを持つ
- When: 管理者がD2のsessionId2を指定して無効化操作を実行する
- Then: 5秒以内にD2のJWTを使ったAPIリクエストが401エラーを返す。D1のJWTを使ったAPIリクエストは引き続き200を返す。管理コンソールでユーザーUのアクティブセッションが1件（D1のみ）表示される。

**シナリオ3: 管理者によるユーザーの全セッション無効化**

- Given: ユーザーUがD1、D2、D3の3つのアクティブセッションを持つ（セキュリティインシデント対応）
- When: 管理者がユーザーUの全セッション無効化操作を実行する
- Then: 5秒以内にD1、D2、D3のすべてのJWTを使ったAPIリクエストが401エラーを返す。ユーザーUのアクティブセッション数が0になる。ユーザーUが再ログインすると新しいセッションが発行される。

**シナリオ4: 水平スケーリング時の認証一貫性**

- Given: アプリケーションサーバーが3台稼働中で、ユーザーUのセッションが管理者によって無効化された
- When: 新しいアプリケーションサーバー（サーバー4台目）がオートスケーリングにより起動する
- Then: 起動後10秒以内にサーバー4台目がユーザーUの無効化済みセッションのJWTを適切に拒否する。起動後のサーバー4台目に対する他のユーザーの正常なJWTは引き続き有効として処理される。

**シナリオ5: 認証レイテンシ**

- Given: アプリケーションサーバーが正常稼働中で、ローカルキャッシュが適切に初期化されている
- When: 有効なJWTを持つクライアントが通常のAPIリクエストを送信する
- Then: 認証処理（JWT検証 + ローカルキャッシュ確認）のP99レイテンシが5ms以内に完了する。Redisへの追加参照は発生しない。

**シナリオ6: テナント間のセッション隔離**

- Given: テナントAのユーザーUAとテナントBのユーザーUBがそれぞれログイン中である
- When: テナントAの管理者がユーザーUAのセッションを無効化する
- Then: テナントBのユーザーUBのセッションは影響を受けない。テナントAの無効化操作のPub/Subメッセージはテナント固有のチャンネルで送信されテナントBの処理に干渉しない。

## 9. 制約、限界、今後の課題

**現行設計の制約:**

最大5分間の無効化遅延が残存する。ローカルキャッシュのヒット前の最初のリクエスト（Pub/Subメッセージ到達前）で無効化済みセッションが一時的に有効とみなされる可能性がある。セキュリティ要件が非常に厳しい場合（金融取引等）は、特定エンドポイントでRedis直接参照を追加することで対応するが、そのエンドポイントのレイテンシは増大する。

**Redisの可用性依存:** セッション管理の中核にRedisを置くため、Redisクラスターの障害はセッション発行・無効化機能に影響する。Redisが停止してもJWT検証はローカルで継続できるが、新規ログインと無効化操作は停止する。Redis Cluster + Multi-AZ配置による冗長化が前提となる。

**キャッシュサイズの管理:** 無効化済みjtiのローカルキャッシュはJWTの発行量と無効化頻度に応じて増大する。TTLベースの自動削除（JWTのexpと同じTTLを設定）により制御するが、大規模テナントでの一括無効化（数万セッション）ではメモリ使用量が一時的に増大する。

**今後の課題:**

テナントごとのカスタムTTLポリシー（高セキュリティテナントは1分、一般テナントは5分等）への対応。デバイストラストスコアやリスクベース認証との統合（異常なIPからのアクセス時の追加認証フロー）。セッション管理の監査ログの標準化とSIEM連携。地理的分散環境でのセッション管理（マルチリージョンRedis同期の課題）。ゼロトラストアーキテクチャへの対応として、セッショントークンに加えてデバイス証明書による相互TLS認証の追加。
