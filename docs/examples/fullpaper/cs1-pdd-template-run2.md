# CS1 条件C: PDD Template — RAG引用リナンバリング (Run 2)

> **Run**: CS1-C-Run2
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c79a9-e3af-7c03-8999-bb072621c7cf)
> **Model**: GPT-5.2 (via Codex)

---

**題目**
ストリーミングRAGにおける不変引用番号付与方式の設計分析

## §1. 問題定義
### §1.1 背景
RAGでは、LLMが `source_3` や `source_7` のような内部IDを参照しつつ回答を逐次生成します。
一方、ユーザー提示では `[1]`, `[2]`, `[3]` の連番が可読性に優れます。
問題は、ストリーミング中は最終文面が未確定であり、どの引用が最終的に残るかが確定しない点です。

### §1.2 矛盾する要求（対立するトレードオフ）
1. 低遅延表示 vs 全文確定後の最適整形
即時表示を優先すると、後段での再番号付け余地が減ります。
2. 表示済み番号の不変性 vs 生成過程の可塑性
LLMは後続トークンで文脈を変え得ますが、UI上は過去番号を変更できません。
3. 連番の可読性 vs 内部IDの安定性
`source_x` は安定ですが読みにくく、`[n]` は読みやすい反面、割当規則を厳密化しないと整合性が崩れます。

### §1.3 本文書の範囲
単一回答ターン内のサーバーサイド・ストリーミングを対象とします。
対象は「本文中の引用番号」と「最終ソース一覧」の整合設計であり、検索品質や要約品質自体は扱いません。

## §2. 現状のアーキテクチャと制約
典型構成は、Retriever→Prompt Builder→LLM Stream→Renderer→Source List Builder です。主要制約は以下です。

1. 出力は追記型（append-only）であり、既送信テキストの後方修正が困難。
2. 引用タグはチャンク境界で分断され得るため、逐次パーサが必要。
3. LLMが未登録IDを出力する可能性がある。
4. 完了時ソース一覧は、本文で表示された番号と厳密一致する必要がある。

## §3. 既存アプローチとその限界
### §3.1 アプローチ1: 事後一括リナンバリング — 手法 / 利点 / 限界
手法: ストリーム中は仮表記、終了後に全文を解析して `[1..N]` を再付番。
利点: 最終整合は取りやすい。
限界: リアルタイム番号表示と「表示済み不変」を満たせません。

### §3.2 アプローチ2: 検索順位の事前固定番号 — 手法 / 利点 / 限界
手法: 取得順に `source_i -> [i]` を先に固定。
利点: 実装が単純で番号不変。
限界: 実際に未使用のソースが混ざりやすく、本文と一覧の意味的整合が弱い。

### §3.3 アプローチ3: 仮番号表示後の差し替え — 手法 / 利点 / 限界
手法: ストリーム中は暫定番号、終了時に差し替え。
利点: 途中表示は可能。
限界: 「一度表示した番号が変わらない」要件に違反します。

### §3.4 アプローチ4: 内部IDをそのまま表示 — 手法 / 利点 / 限界
手法: `source_3` をUI表示。
利点: 一意性・不変性は高い。
限界: 可読性要件を満たせません。

## §4. 問題の本質
本問題は「不可逆な逐次公開を伴うオンライン番号割当」です。
必要なのは、時刻 `t` までの観測に対し、写像 `M_t: source_id -> 正の整数` を以下で維持することです。

1. 初出時のみ `M_t(id)=|dom(M_{t-1})|+1` を付与。
2. 既出IDは再利用し、値を変更しない。
3. 完了時、番号集合は `1..K` の密な連番となる。
4. 最終ソース一覧は `M` から直接生成し、本文と同一写像を共有する。

## §5. 提案手法
### §5.1 基本原理
提案は「初出コミット方式（First-mention Commit）」です。
引用が確定的に検出された瞬間に番号を確定し、その後は不変とします。
番号体系は「使用されたソースのみ」に対して成長するため、完了時も自然に連番となります。

### §5.2 実装アーキテクチャ
1. Source Registry
検索結果を `source_id -> metadata` で保持します。
2. 構造化引用出力
LLMに `<cite id="source_7"/>` のような固定構文を要求します。
3. Incremental Citation Parser
チャンク分断を吸収し、`Citation(id)` イベントを生成します。
4. Citation Allocator（中核）
`id` 未登録なら `next++` で割当、既登録なら再利用。
本文には即時に `[n]` を出力します。
5. Citation Ledger
`(n, source_id, first_offset)` を追記ログ化し、監査可能にします。
6. End-of-Stream List Builder
Ledger順に `[n] -> metadata` を生成し、本文表示と同一写像で確定します。

## §6. 検証可能な性質 — Given/When/Then 形式
1. 初出割当の決定性
Given: `map` が空、入力順が `source_7, source_3, source_7`
When: ストリームを処理する
Then: 本文は `[1], [2], [1]` となる。

2. 番号不変性
Given: 既に `source_3 -> [1]` が表示済み
When: 後続で新規 `source_9` が出る
Then: 既存 `[1]` は変更されず、`source_9` は `[2]` になる。

3. 完了時整合性
Given: ストリーム完了時の `map` が `K` 件
When: ソース一覧を生成する
Then: 一覧はちょうど `K` 件で、本文中の各 `[n]` と1対1に一致する。

4. チャンク分断耐性
Given: `<cite id="source_7"/>` が複数チャンクに分割される
When: Incremental Parserで処理する
Then: `Citation(source_7)` は1回だけ発火し、番号も1回だけ表示される。

5. 未登録IDの扱い
Given: `source_99` がRegistryに存在しない
When: その引用が出力される
Then: 正式番号は発行せず検証エラーを記録し、最終一覧にも含めない。

## §7. 制約と今後の課題
本方式は、LLMが構造化引用構文を守ることを前提とします。また、append-only配信では誤引用の事後修正が本質的に難しいです。
今後の課題は以下です。

1. 制約付きデコーディングによる未登録IDの抑止。
2. 引用妥当性を別モデルで逐次検証する二重化。
3. 複数ターン横断での番号継続戦略（会話単位の安定参照）。

以上より、初出コミット方式は、要求された3要件を同時に満たす最小構成として妥当です。
