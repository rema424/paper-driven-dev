# CS2 条件D: Structured Checklist — マルチテナントSaaSセッション管理 (Run 1)

> **Run**: CS2-D-Run1
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

## 1. 問題の背景と文脈

マルチテナントSaaSにおけるセッション管理は、単一テナント向けシステムと比較して本質的に複雑な問題を抱えている。複数の企業（テナント）が同一インフラ上でサービスを共有する構造において、各テナントのユーザーのセッションを安全かつ効率的に管理する必要がある。

現代のSaaSサービスでは、ユーザーがスマートフォン、タブレット、PCなど複数の端末から同時にサービスを利用するケースが一般的となっており、単一セッションのみを許可するという旧来の制約はユーザビリティを著しく損なう。一方で、セキュリティインシデント発生時（アカウント不正利用の検知、退職者のアクセス遮断、コンプライアンス要件への対応等）に管理者が特定ユーザーのセッションを即座に無効化できる能力は、エンタープライズSaaSにとって必須機能である。

さらに、SaaSビジネスモデルの特性上、ユーザー数の急激な増減に対してインフラを柔軟にスケールできることが求められる。この要件は、セッション情報の管理方法に直接的な制約を課す。水平スケーリング（サーバー台数の増減）に対応するためには、特定のサーバーインスタンスにセッション状態が依存しないステートレスなアーキテクチャが原則的に望ましいが、即座のセッション無効化という要件はある種の中央管理状態を必要とする。

認証レイテンシの最小化は、サービス品質とユーザー体験に直結する。APIエンドポイントへのリクエストごとに認証処理が発生するため、このオーバーヘッドが積み重なることで体感性能に影響する。

## 2. 対立する要求やトレードオフ

### トレードオフ1: ステートレス性と即時無効化能力の対立

JWTに代表されるトークンベース認証はステートレス性に優れ、サーバー側に状態を持たないため水平スケーリングと低レイテンシを自然に実現する。しかし、ステートレスの本質は「トークン自体が真実の源泉である」ことであり、サーバー側でトークンを無効化する手段がない。トークンの有効期限が切れるまで（数時間〜数日）、不正なセッションを即座に止めることができない。

この対立を解消しようとすると、必然的にサーバー側にブラックリスト（無効化されたトークンの集合）やホワイトリスト（有効なセッションの集合）という状態を導入することになり、ステートレス性のメリットが部分的に失われる。

### トレードオフ2: 認証レイテンシと整合性保証の対立

セッションの有効性をリクエストごとに中央ストア（データベース、キャッシュ）に問い合わせることで、最新のセッション状態（管理者による無効化を含む）を常に把握できる。しかし、この方式はリクエストごとにネットワークラウンドトリップが発生し、レイテンシが増加する。

逆に、認証情報をローカルキャッシュ（アプリケーションサーバーのメモリ内）に保持することでレイテンシを最小化できるが、管理者がセッションを無効化してもキャッシュの有効期限内は変更が反映されず、結果整合性に留まる。強整合性と低レイテンシは根本的に緊張関係にある。

### トレードオフ3: 水平スケーリングとセッション状態管理の対立

水平スケーリングに対応するためにはサーバーインスタンス間で状態を共有する仕組みが必要となるが、共有状態の管理は分散システムにおける難問（CAP定理の制約）を引き起こす。スティッキーセッション（特定ユーザーのリクエストを常に同一サーバーへ送る）は問題を回避できるが、サーバー障害時の対応が複雑になり、スケーリングの柔軟性が制限される。

## 3. 分析の対象範囲

本分析の対象範囲は以下の通りである。

- セッショントークンの発行・検証・無効化メカニズム
- マルチテナント環境におけるテナント分離の考慮
- 水平スケーリングに対応したセッションストアのアーキテクチャ
- 管理者によるセッション無効化のリアルタイム伝播
- 複数端末からの同時ログインのサポート構造

対象外とするもの:
- 認証（Authentication）そのものの仕組み（OAuth 2.0、SAML等の認証プロトコル）
- 認可（Authorization）システムの詳細設計
- テナント別課金・利用制限の実装
- パスワードリセットフローの詳細

## 4. 現状のアーキテクチャと制約

### 典型的な現状構成

マルチテナントSaaSの一般的な初期実装では以下の構成が多い。

**トークン形式**: JWTを採用し、ペイロードにユーザーID・テナントID・有効期限を埋め込む。署名検証のみで認証を完結させる設計を当初は採用することが多い。

**セッションストア**: なし（純粋なステートレス）または単一のRDBMSのセッションテーブル。

**スケーリング**: 初期はサーバー台数が少なく、スティッキーセッションやDBルックアップで対処できている。

### 制約

- 既存のJWT実装を大幅に変更することは認証・認可ロジック全体への影響が大きい
- RDBMSのセッションテーブルへの全リクエスト時ルックアップはI/Oボトルネックになりやすい
- マルチテナント構成でテナントをまたいだセッション汚染が発生しないよう、テナントID管理に細心の注意が必要
- セッション無効化の伝播タイムラグについてテナント（顧客企業）との明示的なSLA合意が必要

## 5. 既存の解決アプローチとその限界

### 5.1 アプローチ1: 純粋なJWT（ステートレストークン）

**手法**: JWTを発行し、サーバー側には状態を持たない。リクエスト時は署名検証のみで認証を完結させる。複数端末対応は複数のJWTを発行することで自然に実現できる。

**利点**: サーバー側の状態管理が不要なため、水平スケーリングが容易。認証レイテンシが最小（署名検証のみ、CPUバウンドで高速）。インフラシンプル。

**限界**: 即時セッション無効化が実質的に不可能。JWTの有効期限（exp クレーム）が切れるまでトークンを止める手段がない。短期トークン（5〜15分）と長期リフレッシュトークンの組み合わせで緩和できるが、最大で有効期限分のギャップが残る。エンタープライズ要件を満たさない。

### 5.2 アプローチ2: サーバーサイドセッション（DB中央管理）

**手法**: セッションIDをランダム生成し、サーバー側のRDBMSまたはKey-Valueストアに全セッション情報を保存する。リクエストごとにセッションIDを照合し、有効性を確認する。

**利点**: セッション無効化が即座に反映される。セッション情報の完全な管理・可視性がある。複数端末は複数のセッションレコードとして自然に表現できる。

**限界**: リクエストごとのDBルックアップがボトルネックになる。単一のDBは水平スケーリング時のSPOF（単一障害点）になりうる。DBの可用性がセッション管理の可用性に直結する。

### 5.3 アプローチ3: JWTブラックリスト方式

**手法**: JWTをベースとしつつ、無効化されたトークンのIDをブラックリスト（RedisなどのKVストア）に登録する。リクエスト時はJWT署名検証とブラックリスト照合の両方を行う。

**利点**: 通常時のレイテンシはブラックリスト照合の追加コスト分のみ。無効化操作はブラックリストへの追記で実現。JWTの有効期限を超えたトークンはブラックリストから自動削除できる。

**限界**: ブラックリストが増大すると照合コストが増加する（RedisのO(1)操作で緩和可能）。ブラックリストストアの可用性がシステム全体の認証可用性に影響する。ブラックリストへの書き込みから読み取りまでの伝播タイムラグがある（Redisクラスターのレプリケーションラグ等）。本質的には「無効化のみを追跡する」反転した状態管理であり、有効なセッションの全体像を把握しにくい。

### 5.4 アプローチ4: 短期JWT + リフレッシュトークン分離

**手法**: 短命のアクセストークン（JWT、有効期限5〜15分）と長命のリフレッシュトークン（サーバーサイド管理、有効期限数日〜数週間）を分離する。リフレッシュトークンのみをDBで管理し、アクセストークンはステートレスに検証する。

**利点**: 通常のAPI呼び出しはアクセストークンのステートレス検証のみで完結し低レイテンシ。セッション無効化はリフレッシュトークンの削除で実現でき、最大でアクセストークンの有効期限分（5〜15分）のギャップに限定できる。管理対象となるリフレッシュトークンの数はアクセストークンより少なく、DBの負荷が低い。

**限界**: 即座（秒単位）の無効化は依然として実現できない。アクセストークン有効期限内は不正なセッションが継続しうる。厳格なセキュリティ要件（金融系、医療系等）では許容できない場合がある。アクセストークンのリフレッシュロジックがクライアント側に必要となりクライアント実装が複雑化する。

## 6. 問題の本質的な困難

本問題の本質的な困難は「分散システムにおける強整合性と低レイテンシの同時達成はCAP定理上根本的に不可能である」という事実から生じている。

具体的には以下の三点に集約される。

**第一の困難: 無効化伝播の物理的限界**
セッションの無効化を全サーバーインスタンスに即座に（ゼロレイテンシで）伝播させることは物理的に不可能である。ネットワーク伝播時間、プロセス間通信コスト、キャッシュの更新ラグは必ず存在する。「即座」の定義をどこまで厳格にするか（ミリ秒、秒、分）によって実現可能な設計が変わる。

**第二の困難: 状態管理の中央集権と分散の矛盾**
水平スケーリングの本質は「どのサーバーインスタンスがリクエストを処理しても同じ結果を返せること」であるが、セッション管理において「最新の状態」を全インスタンスが即座に知るためには、何らかの共有状態（中央ストア）へのアクセスが必要となる。この中央ストア自体がスケーリングのボトルネックになるというパラドックスが生じる。

**第三の困難: テナント分離の複雑性**
マルチテナント環境では、あるテナントの大量ユーザーが引き起こすセッション管理の負荷が他のテナントに影響しない（ノイジーネイバー問題の回避）という要件と、インフラの共有による運用コスト削減という要件が対立する。テナントごとに完全に独立したセッションストアを持てば分離は完全だが、コストが倍増する。

## 7. 解決策

### 7.1 基本原理

本問題に対する設計原理は「**階層的キャッシュと選択的整合性（Hierarchical Caching with Selective Consistency）**」である。

全てのリクエストに対して同一の整合性レベルを要求するのではなく、リスクレベルと業務上の必要性に応じて整合性保証を使い分ける。通常のリクエスト処理は高速なローカルキャッシュで処理し、セキュリティ上クリティカルな場面（無効化直後の数分間）のみ強整合性を保証する仕組みを設ける。

セッション情報は以下の三層で管理する。
- **L1: プロセスメモリキャッシュ**（ミリ秒、各サーバーインスタンス内）
- **L2: 共有分散キャッシュ**（数ミリ秒、Redisクラスター等）
- **L3: 永続化ストア**（数十ミリ秒、RDBMSまたはNoSQL）

### 7.2 実装方針

#### セッショントークン設計

アクセストークンとセッショントークンを分離する。

```
AccessToken (JWT, 有効期限: 5分)
  - sub: user_id
  - tid: tenant_id
  - sid: session_id  ← セッション識別子を埋め込む
  - exp: (5分後)
  - jti: token_id

SessionToken (不透明トークン, 有効期限: 数日〜数週間)
  - サーバーサイドのみで管理
  - アクセストークンのリフレッシュに使用
```

#### セッションストアのデータモデル

```
Session {
  session_id: UUID,
  tenant_id: String,
  user_id: String,
  device_info: {
    device_id: String,
    user_agent: String,
    ip_address: String,
    last_seen: Timestamp
  },
  status: Enum(ACTIVE, REVOKED),
  created_at: Timestamp,
  expires_at: Timestamp,
  revoked_at: Timestamp | null,
  revoked_by: user_id | null  ← 管理者IDを記録
}
```

複数端末は同一 `user_id` + `tenant_id` に複数の `Session` レコードとして表現する。

#### 認証フロー（通常リクエスト時）

1. リクエストヘッダからアクセストークン（JWT）を取得
2. JWTの署名検証（ローカル、CPUバウンドで高速）
3. JWTの有効期限確認
4. `sid`（セッションID）を使ってL1キャッシュを確認
   - L1ヒット かつ キャッシュ生成時刻が30秒以内: 認証完了、リクエスト処理へ
   - L1ミス: L2（Redis）を確認
5. L2から `Session` レコードを取得
   - `status == REVOKED`: 401を返す
   - `status == ACTIVE`: L1に書き込み（TTL: 30秒）、認証完了
   - L2ミス: L3（DB）から取得し、L2・L1に書き込み

#### セッション無効化フロー

管理者が特定ユーザーのセッションを無効化する際:

1. 管理者のAPIリクエストを受信
2. L3（DB）の該当セッションを `REVOKED` に更新
3. L2（Redis）の該当セッションキャッシュを即座に削除（`DEL` コマンド）
4. Pub/Subチャネルを通じて全サーバーインスタンスのL1キャッシュに無効化シグナルを送信
5. 各サーバーインスタンスはシグナル受信後、L1の該当エントリを削除

このフローにより、Pub/Subシグナルの伝播時間（通常数十ミリ秒〜数百ミリ秒）以内にL1キャッシュが無効化され、以降のリクエストはL2（既に削除済み）→L3で `REVOKED` を取得する。実質的に秒以内での無効化伝播を実現できる。

#### 水平スケーリング対応

- Redisクラスター（L2）はシャーディングにより水平スケール可能
- `tenant_id` をシャーディングキーの一部として使用することでテナント分離を促進
- サーバーインスタンスはステートレスに近い設計（L1はウォームキャッシュに過ぎず、消えても動作する）
- セッションIDをランダム分散させることでRedisシャード間の負荷を均等化

#### マルチテナント分離

- 全クエリ・キャッシュキーに `tenant_id` プレフィックスを付与: `session:{tenant_id}:{session_id}`
- 管理者APIはテナントスコープで認可チェックを実施（他テナントのセッションを操作不可）
- テナントごとのセッション上限数をL2で管理（ノイジーネイバー抑制）

## 8. 検証条件

### シナリオ1: 複数端末の同時ログイン

**Given**: テナントAのユーザーUが、デバイスD1（PC）でセッションS1を持っている

**When**: 同一ユーザーUがデバイスD2（スマートフォン）でログインする

**Then**: セッションS2が新規作成され、S1とS2の両方が `ACTIVE` 状態である。ユーザーUは両デバイスから同時にサービスを利用できる。

---

### シナリオ2: 管理者によるセッション即時無効化

**Given**: テナントAのユーザーUがデバイスD1でセッションS1を持ち、正常にAPIリクエストを行っている

**When**: テナントAの管理者がユーザーUのセッションS1を無効化する操作を実行する

**Then**: 無効化操作完了から5秒以内に、デバイスD1からのAPIリクエストが401 Unauthorizedを返す。他のテナントBのユーザーのセッションは影響を受けない。

---

### シナリオ3: 水平スケーリング時のセッション継続

**Given**: 10台のサーバーインスタンスが稼働しており、ユーザーUのセッションS1が存在する

**When**: スケールアウトにより新たに5台のサーバーインスタンスが追加される（合計15台）

**Then**: ユーザーUのその後のリクエストが新旧いずれのインスタンスに到達しても、追加認証なしに正常に処理される。

---

### シナリオ4: 認証レイテンシの上限

**Given**: システムが通常負荷（p50負荷）で稼働している

**When**: 認証済みユーザーのAPIリクエストが到達する

**Then**: 認証処理（JWT検証 + セッション有効性確認）のレイテンシがp99で10ミリ秒以内である（L1キャッシュヒット時: 1ミリ秒以内、L2キャッシュヒット時: 5ミリ秒以内）。

---

### シナリオ5: テナント間のセッション分離

**Given**: テナントAにユーザーUA、テナントBにユーザーUBが存在する

**When**: テナントAの管理者がユーザーUAの全セッションを無効化する

**Then**: テナントBのユーザーUBのセッションは引き続き有効であり、影響を受けない。テナントAの管理者はテナントBのセッションにアクセスも無効化もできない。

---

### シナリオ6: L2キャッシュ障害時のフェイルオーバー

**Given**: Redisクラスター（L2）が一時的に利用不可能な状態になる

**When**: ユーザーUのAPIリクエストが到達する

**Then**: L3（DB）へのフォールバックが発動し、認証は成功する（レイテンシは増加するが機能は継続）。L2復旧後、自動的に通常フローに戻る。

## 9. 制約、限界、今後の課題

### 制約

**無効化伝播の最大タイムラグ**: 本提案の設計では、L1キャッシュのTTL（30秒）がセキュリティ上の最大許容タイムラグとなる。Pub/Subシグナルが正常に機能している場合は秒以内に伝播するが、ネットワーク分断等の障害時はTTL満了まで（最大30秒）旧状態が残る可能性がある。金融系・医療系等でゼロ秒の即時無効化を要求するユースケースでは、L1キャッシュを廃止してL2のみに頼る必要があり、レイテンシが増加する。

**Redisへの依存**: L2としてRedisを採用した場合、Redisクラスターの可用性がシステム全体の認証可用性に影響する。Circuit Breakerパターンを用いてL3へのフォールバックを実装することで緩和できるが、フォールバック時のレイテンシ増加は避けられない。

### 限界

**大規模テナントのセッション上限**: 一つのテナントが極めて多数のユーザー（例: 数百万ユーザー）を持つ場合、そのテナントのセッション情報が特定のRedisシャードに集中するリスクがある。テナントIDをシャーディングキーとして使用しているため、大規模テナントの負荷を分散させるには追加のサブシャーディング戦略が必要となる。

**セッション情報のエントロピー**: 複数端末・長期間の利用が積み重なることで、失効済みセッションを含む大量のセッションレコードがL3に蓄積する。定期的なガベージコレクション（有効期限切れセッションの削除）ジョブが必要となるが、このジョブがDBに与える負荷を適切に管理する必要がある。

**クライアント側の実装複雑度**: アクセストークン（短命）とセッショントークン（長命）を分離した設計では、クライアント（ブラウザSDK、モバイルアプリ）がリフレッシュロジックを実装する必要がある。クライアント実装の品質がシステム全体のセキュリティに影響するため、公式のSDKを提供し実装を標準化することが望ましい。

### 今後の課題

**デバイス信頼レベルの導入**: 現在の設計では全デバイスを同一に扱っているが、デバイス認証（MFA完了済み端末への信頼付与）と組み合わせることで、高リスク操作時のみ追加認証を要求するリスクベース認証への発展が可能である。

**セッションの地理的制限**: テナントのコンプライアンス要件（GDPR等）に応じて、セッション情報を特定のリージョンにのみ保存するデータレジデンシー対応の実装が必要になる場合がある。

**異常なセッションパターンの検出**: 同一セッションが異なる地理的位置から短時間に使用される（不可能な旅行）等の異常パターンを検出し、自動的にセッションを保留状態にするリスクエンジンとの統合が、エンタープライズSaaSの次世代要件として浮上している。

**リアルタイムセッション監査ログ**: 規制業種のテナント向けに、全セッションイベント（作成、アクセス、無効化）の改ざん防止ログを提供する機能の追加が求められる。これはストリーミングプラットフォーム（Kafka等）を介した非同期ログ書き込みで実現できるが、設計上の追加考慮が必要である。
