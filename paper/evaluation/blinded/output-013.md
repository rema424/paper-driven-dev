# Output #013

要件を同時に満たすなら、`短命JWT + 中央セッションストア(Redis) + 失効イベント配信`のハイブリッド構成が最適です。

**設計方針**
1. 認証は原則ローカル検証で低レイテンシ化する。
2. 失効判定は中央管理で即時性を担保する。
3. APIサーバーは完全ステートレスにして水平スケールする。

**推奨アーキテクチャ**
1. `Auth Service`
2. `API Nodes (stateless)`
3. `Redis Cluster`（セッション・失効状態の真実源）
4. `Pub/Sub or Stream`（失効イベント伝播）
5. `RDB`（監査ログ、履歴保存。リクエスト認証パスからは外す）

**データモデル（Redis）**
1. `tenant:{tid}:user:{uid}:epoch`（ユーザー失効世代。全セッション無効化に使用）
2. `tenant:{tid}:session:{sid}`（端末ごとのセッション状態）
3. `tenant:{tid}:user:{uid}:sessions`（sid一覧）

**トークン戦略**
1. Access Token: JWT（有効期限2〜5分、`tid/uid/sid/epoch/jti`を含む）
2. Refresh Token: 乱数Opaque（ローテーション必須、Redisで状態管理）

**要件との対応**
1. 複数端末同時ログイン: 端末ごとに`sid`を発行し独立管理。
2. 管理者の即時無効化: `epoch`を`INCR`し失効イベント配信。全ノードが即時反映。
3. 水平スケーリング: APIノードは状態を持たず、追加・削除が容易。
4. 低レイテンシ: JWT署名検証はローカル、失効はノード内L1キャッシュ＋Redisフォールバック。

**運用上の重要点**
1. Pub/Sub取りこぼし対策として、Stream再読込または定期再同期を入れる。
2. Redis障害時は「短時間キャッシュ許容後にfail-closed」を推奨。
3. マルチテナント分離のため、全キーに`tenant_id`を必須付与。

必要であれば次に、想定QPS/レイテンシ目標に合わせたTTL値とキャッシュ戦略（L1/L2）の具体値まで落とし込みます。
