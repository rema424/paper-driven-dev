# CS1 条件C: PDD Template — RAG引用リナンバリング (Run 5)

> **Run**: CS1-C-Run5
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c7950-c8d9-7ed0-af5b-7191eb6bfaad)
> **Model**: GPT-5.2 (via Codex)

---

**題目**
ストリーミングRAGにおける不変引用番号付与の設計分析

### §1. 問題定義
#### §1.1 背景
RAGシステムでは、検索で得た内部ID（例: `source_3`, `source_7`）を参照しつつ、LLMがトークンを逐次生成します。ユーザー体験上は内部IDではなく、可読な連番引用（`[1]`, `[2]`）が望まれます。しかし、ストリーミング中は最終文面が未確定であり、引用の出現順・出現有無は事前確定できません。

#### §1.2 矛盾する要求（対立するトレードオフ）
1. 即時性 vs 確定性
ストリーミングで即時表示したい一方、最終的に使われる引用集合は完了時まで不確定です。
2. 可読な連番化 vs 不変性
連番を最適化（後で詰め直し）すると可読性は上がる一方、一度表示した番号が変化し得ます。
3. 厳密整合性 vs 低遅延
厳密な検証を増やすほど整合性は高まる一方、表示遅延が増加します。

#### §1.3 本文書の範囲
本稿は「引用番号のオンライン採番と最終整合性」の設計に限定し、検索精度、引用妥当性（意味的正しさ）、UI美観の詳細設計は対象外とします。

### §2. 現状のアーキテクチャと制約
典型構成は、`Retriever -> LLM -> Stream Renderer` です。制約は以下です。
1. 出力は逐次コミットされ、過去表示の安全な巻き戻しは困難。
2. LLMはどの `source_i` をいつ参照するかを事前確定しない。
3. ユーザー向けには内部ID非表示で連番が必要。
4. 完了時には本文中引用とソース一覧の一貫性が必須。

### §3. 既存アプローチとその限界
#### §3.1 アプローチ1: 後処理リナンバリング
手法: ストリーム中は仮表示し、完了後に全文再走査して `[1..N]` に再採番。
利点: 最終形は最も整った連番にできる。
限界: ストリーミング中の番号不変性を満たせません。

#### §3.2 アプローチ2: 検索順位固定マッピング
手法: 検索結果順に事前に `source_i -> [k]` を固定。
利点: 番号は不変で実装容易。
限界: 未使用ソースの番号が混在し、本文の初出順と乖離しやすく可読性が下がります。

#### §3.3 アプローチ3: 一時番号＋後方修正
手法: 一時番号を即時表示し、後で確定番号へ置換。
利点: 即時表示は容易。
限界: 「一度表示した番号が変わらない」要件に反します。

### §4. 問題の本質
本問題は「部分観測下のオンライン識別子割当」です。
必要条件は、(a) 単調性（再割当なし）、(b) 即時性（低遅延）、(c) 終了時整合性（本文と一覧の同型）です。
したがって、採番は「初出時に一度だけ確定する append-only 台帳」として扱う必要があります。

### §5. 提案手法
#### §5.1 基本原理
**Monotonic Citation Ledger (MCL)** を提案します。
1. 引用は自由文文字列ではなく構造化イベント `cite(source_id)` として受信。
2. `source_id` 初出時にのみ次番号を割当（`next = 1,2,3...`）。
3. 既出 `source_id` は既存番号を再利用。
4. 台帳は追記専用で、割当済み番号の変更を禁止。
5. 完了時ソース一覧は台帳から機械的に生成。

#### §5.2 実装アーキテクチャ
構成要素:
`Retriever`、`Source Registry`、`LLM`、`Citation Event Parser`、`MCL Indexer`、`Stream Renderer`、`Finalizer`

処理規則:
```text
state: map source_to_num, list num_to_source, int next=1

on cite(s):
  validate s in Source Registry
  if s not in source_to_num:
    source_to_num[s] = next
    num_to_source[next] = s
    next += 1
  emit "[" + source_to_num[s] + "]"
```

完了時:
`[1..next-1]` の順に `num_to_source` を引いてソース一覧を生成します。
これにより、本文中番号と一覧番号は定義上一致します。

### §6. 検証可能な性質（Given/When/Then）
1. 初出採番
Given 台帳が空
When `cite(source_7)` を受信
Then `[1]` を出力し、`source_7 -> 1` を保存する。

2. 再引用の不変性
Given `source_7 -> 1` が存在
When 再度 `cite(source_7)` を受信
Then 常に `[1]` を出力し、番号は変化しない。

3. 後続イベント非干渉
Given `[1]` が既に表示済み
When 新規 `cite(source_3)` を受信
Then `[2]` を出力し、既表示の `[1]` は不変。

4. 完了時整合性
Given ストリーム中に `[1],[2],[1]` が表示
When ストリーム完了
Then ソース一覧は `[1]=source_7, [2]=source_3` となり本文と整合する。

5. リアルタイム性
Given `cite(s)` が時刻 `t` に到着
When Indexer が処理
Then `t+Δ`（設計目標例: 50ms以内）までに番号表示される。

6. 不正ID遮断
Given `source_x` が Registry 外
When `cite(source_x)` を受信
Then 正式番号は割当てず、エラーイベントとして記録する。

### §7. 制約と今後の課題
1. 本手法は「番号整合性」を保証しますが、「引用の意味的正しさ」は保証しません。
2. LLMが途中で論旨を自己修正する場合、既表示引用の情報的冗長は残り得ます。
3. マルチターン会話での番号持越し方針（ターンごとリセットか全体通番か）は別設計が必要です。
4. 今後は、構造化デコード強制、引用妥当性検証（claim-source alignment）、障害復旧時の台帳永続化検証を進めるべきです。
