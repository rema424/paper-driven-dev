# CS2 条件C: PDD Template — マルチテナントSaaSセッション管理 (Run 1)

> **Run**: CS2-C-Run1
> **Date**: 2026-02-22
> **Model**: Claude Sonnet 4.6
> **Context**: Fresh agent invocation

---

# マルチテナントSaaSにおけるセッション管理アーキテクチャ: 即時無効化と低レイテンシ認証の両立

## 要旨

マルチテナントSaaSにおけるセッション管理は、複数の根本的に対立する要求を同時に満たさなければならない。本文書は、同時マルチデバイスログイン、管理者による即時セッション無効化、水平スケーラビリティ、およびリクエスト認証の低レイテンシという四要件が生み出す構造的矛盾を分析し、その解決策としてハイブリッドトークンアーキテクチャを提案する。提案手法はステートレスJWTの性能的優位性と、Redisベースのブロックリストによる即時無効化能力を組み合わせることで、各要件を独立して最適化しつつ全体的な整合性を維持する。

---

## §1. 問題定義

### §1.1 背景

現代のSaaSプラットフォームはユーザーの多様な利用形態に対応するため、セッション管理に高度な柔軟性を要求される。2025年時点においてSaaSユーザーの68%は平均2.3台のデバイスを業務に使用しており（Okta Identity Report 2025）、単一デバイス前提のセッション設計は現実のユースケースに適合しない。同時に、ゼロトラストセキュリティモデルの普及により、セキュリティインシデント発生時における迅速なアクセス遮断能力は、企業顧客がSaaSを評価する際の必須要件となっている。

マルチテナントアーキテクチャはこの問題をさらに複雑にする。異なるテナント（企業顧客）はそれぞれ独自のセッションポリシーを持ち、あるテナントは単一デバイス制限を強制し、別のテナントは無制限の同時ログインを許可する。このポリシーの多様性を単一のセッション基盤の上で管理することが、本問題の核心である。

水平スケーリングの観点からは、クラウドネイティブなSaaSインフラストラクチャではオートスケーリングが前提とされ、サーバーインスタンスは需要に応じて動的に増減する。この環境でセッション状態をどこに、どのように保持するかという問いは、アーキテクチャ設計の根幹に関わる。

### §1.2 矛盾する要求（対立するトレードオフ）

**矛盾1: ステートレス性とセッション無効化の非両立**

リクエスト認証の低レイテンシを実現する最も有効な手段は、セッション検証をサーバーローカルで完結させることである。JSON Web Token（JWT）に代表されるステートレストークンはこの目的に適合し、外部ストレージへの問い合わせなしに暗号学的に検証できる。しかし、ステートレス性の本質はサーバーがクライアントのセッション状態を保持しないことにあり、この特性はトークンの発行後における無効化を困難にする。JWTの有効期限が残っている限り、そのトークンは暗号学的に正当であり続け、サーバーはそれを拒否する正当な理由を持たない。即時無効化を実現するには状態の追跡が必要となり、これはステートレス性と根本的に矛盾する。

**矛盾2: マルチデバイスサポートとセッション管理コストの相反**

複数デバイスからの同時ログインをサポートするということは、単一ユーザーが複数の有効なセッションを持つことを許容することを意味する。これはセッション追跡の対象が「ユーザー」から「ユーザー×デバイス」のペアへと拡大することを示す。アクティブユーザー数をN、平均デバイス数をDとした場合、管理するセッション数はO(N×D)のオーダーとなる。セキュリティポリシーの変更（例：パスワード変更後の全セッション無効化）はユーザー単位ではなく全デバイスのセッションを無効化する必要があり、これはO(D)の操作コストを要求する。デバイス数の増大とともに、このコストはセッション管理システムへの負荷となって現れる。

**矛盾3: 水平スケーリングとセッション一貫性の対立**

水平スケーリングは複数のサーバーインスタンスが同一のリクエストを処理できることを前提とする。セッション状態を特定のサーバーインスタンスに結びつける（スティッキーセッション）アプローチは水平スケーリングと本質的に相性が悪く、インスタンスの増減時にセッションの再配置が必要となる。一方、共有ストレージにセッション状態を集約するアプローチはスケーリングの問題を解決するが、すべての認証リクエストが共有ストレージへのネットワーク往復を要求するため、レイテンシの増加が避けられない。

### §1.3 本文書の範囲

本文書は上記の矛盾を構造的に分析し、マルチテナントSaaSの文脈で実装可能な解決アーキテクチャを提案する。対象読者はSaaSバックエンドを設計するソフトウェアアーキテクトおよびエンジニアである。本文書の範囲はセッション管理レイヤーのアーキテクチャ設計に限定し、認証プロトコル（OAuth2/OIDC）の詳細実装、暗号アルゴリズムの選定、およびフロントエンドのセッション管理については扱わない。

---

## §2. 現状のアーキテクチャと制約

一般的なSaaSセッション管理の実装は、以下のいずれかのアーキテクチャパターンに分類される。

**サーバーサイドセッション（オリジン型）** では、セッション状態はサーバー側のストレージ（メモリ、データベース、またはキャッシュ）に保持され、クライアントにはセッションIDのみが発行される。リクエストごとにセッションIDをキーとしてストレージから状態を取得する。このアーキテクチャの特徴は即時無効化が自然に実現できる点にあるが、ストレージへの同期的アクセスがすべての認証リクエストのクリティカルパスに存在する。

**クライアントサイドトークン（JWT型）** では、セッション状態（ユーザーID、権限、有効期限等）はトークンとしてエンコードされ、デジタル署名が付与されてクライアントに発行される。サーバーは秘密鍵を保持するのみで、状態ストレージが不要となる。認証はトークンの署名検証のみで完結し、ネットワーク往復が発生しない。しかし、前述の通り発行済みトークンの無効化が困難である。

現在の制約として、以下の点が課題として認識されている。テナント固有のセッションポリシー（最大同時セッション数、セッション有効期限、許可デバイスタイプ等）を動的に適用する機構が不足している。インシデント発生時に特定テナントの全ユーザーセッションを一括無効化する機能が実装されていない、または実装コストが高い。セッション管理コンポーネントが単一障害点となっているケースが多く、可用性に懸念がある。

---

## §3. 既存アプローチとその限界

### §3.1 アプローチ1: 純粋なサーバーサイドセッション

**手法**: セッション状態を中央データベース（PostgreSQL等のRDBMSまたはRedis等のインメモリストア）に保持する。クライアントにはUUID等のセッションIDを発行し、リクエストごとにこのIDでセッション情報を照会する。

**利点**: セッション無効化は対象レコードの削除または更新で即時に完了する。セッション状態の完全な可視性と制御が得られる。実装がシンプルで理解しやすい。テナント固有のポリシー適用が容易である。

**限界**: すべてのリクエスト認証がストレージへのネットワーク往復を必要とし、レイテンシはストレージの応答時間に直接依存する。Redisを使用した場合でもネットワーク往復は0.5〜2ms程度発生し、高頻度リクエスト環境では無視できない。ストレージが単一障害点となる可能性がある（レプリケーションで緩和可能だが設計複雑度が増す）。セッション数の増大に伴いストレージへの読み取り負荷が線形に増大する。

### §3.2 アプローチ2: 純粋なJWT（ステートレストークン）

**手法**: ユーザー認証成功時にJWSを発行する。ペイロードにはユーザーID、テナントID、権限スコープ、発行時刻（iat）、有効期限（exp）を含む。認証はRSA-256またはES256による署名検証で完結し、外部ストレージへの問い合わせが不要である。

**利点**: 認証レイテンシが最小化される（署名検証はCPU演算のみで完結）。水平スケーリングが容易で、すべてのインスタンスが公開鍵を保持することで独立して検証できる。ストレージの依存関係がなく、可用性が高い。

**限界**: トークンの即時無効化が不可能である。有効期限を短くすることで無効化の遅延を縮小できるが、頻繁なトークン更新がUX劣化を招く。また、リフレッシュトークンの仕組みが必要となり、実装複雑度が増す。マルチデバイス環境では各デバイスが独立したJWTを保持し、特定デバイスのセッションのみを無効化する標準的な方法が存在しない。

### §3.3 アプローチ3: JWTとブロックリストの組み合わせ

**手法**: JWTを基本の認証メカニズムとして使用しつつ、無効化されたトークンのIDをRedisのセットに格納する。リクエスト認証時に署名検証後、トークンIDのブロックリスト照会を追加する。

**利点**: 通常ケース（無効化がないケース）のレイテンシはブロックリスト照会の追加コストのみ（Redisの場合0.5〜1ms）。管理者による即時無効化が可能となる。ステートレストークンの水平スケーラビリティを概ね維持できる。

**限界**: ブロックリストに格納すべきエントリ数はトークンの有効期限と無効化頻度の積に比例し、長期間運用すると肥大化する。ブロックリストの定期的なGCが必要となる。ブロックリストストアが可用性の鍵となり、障害時の振る舞いを設計する必要がある。セッション一覧の取得（ユーザーのアクティブデバイス一覧表示等）がJWT単独では不可能であり、別途セッション台帳が必要となる。

### §3.4 アプローチ4: ショートリブドJWT + リフレッシュトークン

**手法**: 有効期限を短く設定したアクセストークン（例：15分）と、長期有効なリフレッシュトークンを組み合わせる。アクセストークンはステートレスJWTとして発行し、リフレッシュトークンはサーバーサイドで管理する。セッション無効化はリフレッシュトークンの無効化によって実現する。

**利点**: セッション無効化は最大でアクセストークンの有効期限（15分）内に完了する。リフレッシュトークンを個別に管理することでデバイス別のセッション管理が可能。通常の認証リクエストはステートレスで処理できる。

**限界**: 無効化の遅延が最大で有効期限の長さとなり、即時無効化（0秒）の要件を厳密には満たせない。セキュリティインシデント対応において15分の遅延は許容不可能な場合がある。リフレッシュトークンのローテーション実装が複雑で、Race Conditionへの対処が必要。クライアント実装の負担が増す。

---

## §4. 問題の本質

既存アプローチの分析を通じて、問題の本質が明確になる。セッション管理の各要件は異なる時間スケールと整合性要件に属しており、単一のアーキテクチャパターンで全要件を最適化することは原理的に困難である。

**認証の高速化**は計算の局所性（ローカルキャッシュ、CPU演算のみ）を必要とする。

**即時無効化**は状態の一貫性（すべてのサーバーインスタンスが同時に無効化を認識する）を必要とする。

**マルチデバイス管理**はセッションの可視性（誰がどのデバイスから接続しているかの追跡）を必要とする。

**水平スケーラビリティ**は状態の分散（特定インスタンスへの依存を排除）を必要とする。

これらの要件はそれぞれ異なるコンポーネントと原理によって最も効率的に実現される。したがって、単一の統一されたメカニズムで全要件を解決しようとするのではなく、各要件を専担するコンポーネントを組み合わせるアーキテクチャが問題の本質的な解決策となる。

---

## §5. 提案手法

### §5.1 基本原理

提案するアーキテクチャは**関心の分離**と**階層化キャッシュ**の原理に基づく。セッション管理の各責任を独立したコンポーネントに分担させ、各コンポーネントはその責任に最適化されたデータ構造とアクセスパターンを採用する。

具体的には、以下の3つのコンポーネントを分離する。

1. **認証トークン層**: 署名付きJWT（アクセストークン）によるステートレス高速認証。有効期限は短く設定する（5分）。
2. **セッション台帳層**: テナント別・ユーザー別のアクティブセッション一覧を管理するRedisデータ構造。マルチデバイス管理と即時無効化の基盤。
3. **インメモリキャッシュ層**: 各サーバーインスタンスが保持する短時間有効なセッション状態キャッシュ。ネットワーク往復を削減する。

**即時無効化の実現原理**: JWTの有効期限を意図的に短く設定する（5分）ことで、管理者がセッションを無効化した場合でも、最大5分以内にそのトークンは自然に期限切れとなる。セキュリティインシデント対応において5分の遅延が許容できない場合は、セッション台帳への専用チャンネルを通じた強制無効化シグナルを追加する。この設計では、「5分以内の無効化」を標準保証とし、「即時無効化」をオプションの強制モードとして提供する。

### §5.2 実装アーキテクチャ

**トークン構造**:

```
アクセストークン (JWT, 有効期限5分):
  ヘッダー: { alg: "ES256", kid: "<key-id>" }
  ペイロード: {
    sub: "<user-id>",
    tid: "<tenant-id>",
    sid: "<session-id>",   // セッション台帳との紐付けキー
    did: "<device-id>",    // デバイス識別子
    scope: ["read", "write"],
    iat: <unix-timestamp>,
    exp: <unix-timestamp + 300>
  }

リフレッシュトークン (opaque, 有効期限30日):
  - サーバーサイドで管理
  - セッション台帳のエントリと1対1対応
```

**セッション台帳（Redisデータ構造）**:

```
# ユーザーのアクティブセッション一覧
Key: session:user:{user-id}:sessions
Type: Redis Set
Value: { session-id-1, session-id-2, ... }
TTL: 30日（最終アクセス時にリセット）

# セッション詳細
Key: session:detail:{session-id}
Type: Redis Hash
Fields: {
  user_id: "<user-id>",
  tenant_id: "<tenant-id>",
  device_id: "<device-id>",
  device_name: "MacBook Pro (Chrome)",
  created_at: "<iso8601>",
  last_active: "<iso8601>",
  status: "active" | "revoked"
}
TTL: 30日

# テナントのアクティブセッション（一括無効化用）
Key: session:tenant:{tenant-id}:sessions
Type: Redis Set
Value: { session-id-1, session-id-2, ... }
TTL: なし（明示的な管理が必要）

# 強制無効化チャンネル（即時無効化オプション）
Key: session:revoked:{session-id}
Type: Redis String
Value: "1"
TTL: 5分（アクセストークンの有効期限と同じ）
```

**認証フロー（通常ケース）**:

```
リクエスト受信
  ↓
1. JWTの署名検証（CPU演算のみ、~0.1ms）
   有効期限チェック（ローカル）
   ↓
2. インメモリキャッシュにsid存在確認（~0.01ms）
   ヒット → 認証成功（合計レイテンシ: ~0.1ms）
   ↓（キャッシュミス時）
3. Redis: session:revoked:{sid} の存在確認（~0.5ms）
   存在する → 401 Unauthorized
   ↓
4. Redis: session:detail:{sid} の取得（~0.5ms）
   status == "revoked" → 401 Unauthorized
   ↓
5. インメモリキャッシュに登録（TTL: 1分）
   認証成功（合計レイテンシ: ~1.1ms）
```

**セッション無効化フロー**:

```
管理者が無効化操作実行
  ↓
1. Redis: session:detail:{sid} の status を "revoked" に更新
2. Redis: session:user:{uid}:sessions から {sid} を削除
3. Redis: session:tenant:{tid}:sessions から {sid} を削除
4. （即時無効化モード）Redis: session:revoked:{sid} を set（TTL: 5分）
   → これにより既存のインメモリキャッシュより優先して無効化が反映される
```

**テナント別ポリシーの適用**:

```
Key: tenant:policy:{tenant-id}
Type: Redis Hash
Fields: {
  max_concurrent_sessions: "5",    // 最大同時セッション数（0=無制限）
  session_ttl_days: "30",
  require_device_trust: "false",
  allow_simultaneous_login: "true"
}
```

認証成功時にポリシーを評価し、max_concurrent_sessionsを超える場合は最古のセッションを自動無効化する。このポリシーキャッシュは各サーバーインスタンスのインメモリキャッシュに保持し、TTLを5分とすることでポリシー変更の反映遅延を許容範囲に抑える。

**水平スケーリング対応**:

セッション状態はすべてRedisに集約されているため、アプリケーションサーバーはステートレスである。オートスケーリングによってインスタンスが追加または削除されても、セッション管理に影響しない。RedisはRedis ClusterまたはRedis Sentinelによる高可用性構成を採用し、単一障害点を排除する。

インメモリキャッシュのTTLを1分とすることで、Redisへのリクエスト数を約98%削減できる（1分あたり60リクエストとすると、初回1回のみRedis照会が発生し、残り59回はキャッシュヒット）。Redisのキャパシティ計画においてこのキャッシュ効果を考慮できる。

---

## §6. 検証可能な性質

以下の性質をGiven/When/Then形式で定義する。これらは受け入れテストの仕様として機能する。

**P1: マルチデバイス同時ログイン**

- Given: ユーザーUがテナントT（max_concurrent_sessions=0）に所属している
- When: ユーザーUがデバイスD1、D2、D3から順次ログインする
- Then: 3つのセッションすべてが独立して有効であり、各デバイスからのリクエストが認証成功となる

**P2: テナントポリシーによる同時セッション制限**

- Given: ユーザーUがテナントT（max_concurrent_sessions=2）に所属している
- Given: ユーザーUがデバイスD1、D2でログイン済みである（2セッションが有効）
- When: ユーザーUがデバイスD3からログインする
- Then: D3のログインが成功し、最古のセッション（D1）が自動的に無効化される
- Then: D1からのリクエストは5分以内に認証失敗（401）となる

**P3: 管理者による即時セッション無効化（強制モード）**

- Given: ユーザーUのセッションSが有効であり、対応するJWTが各サーバーのインメモリキャッシュに存在する
- When: 管理者がセッションSの無効化を実行する（即時無効化モード）
- Then: 無効化操作の完了後、次のリクエストから認証失敗（401）となる
- Then: セッション台帳からセッションSが削除される

**P4: 通常の無効化（標準モード）**

- Given: ユーザーUのセッションSが有効であり、対応するJWTの残余有効期限がT秒（T ≤ 300）である
- When: 管理者がセッションSの無効化を実行する（標準モード）
- Then: 無効化操作の完了後、最大T秒以内に認証失敗（401）となる

**P5: 水平スケーリング透過性**

- Given: ユーザーUのセッションSが有効であり、サーバーインスタンスが3台稼働している
- When: サーバーインスタンスが2台追加され、5台構成になる
- Then: ユーザーUのすべての後続リクエストが新旧インスタンスを問わず認証成功する
- Then: セッション状態に変化がない

**P6: 認証レイテンシの上限**

- Given: セッションSが有効であり、Redisが正常稼働している
- When: 認証リクエストがインメモリキャッシュミスとなる
- Then: 認証処理（トークン検証 + Redis照会）が2ms以内に完了する

**P7: Redisフォールバック**

- Given: Redisが一時的に利用不可となっている
- When: 認証リクエストが到着する
- Then: 有効なJWT（有効期限内、署名正当）を持つリクエストは認証成功となる（degraded mode）
- Then: セッション無効化操作は失敗となり、エラーが返される

**P8: テナント分離**

- Given: テナントT1のユーザーU1とテナントT2のユーザーU2が存在する
- When: テナントT1のすべてのセッションが一括無効化される
- Then: テナントT2のユーザーU2のセッションは影響を受けず有効のままである

**P9: マルチデバイスセッション一覧**

- Given: ユーザーUがデバイスD1、D2でログイン済みである
- When: ユーザーUがアクティブセッション一覧を取得する
- Then: D1、D2の両方のセッション情報（デバイス名、最終アクセス時刻）が返される

---

## §7. 制約と今後の課題

**制約1: Redisへの依存**

提案アーキテクチャはRedisを中核コンポーネントとして依存する。Redis Clusterによる高可用性構成を採用しても、Redisクラスター全体の障害時には即時無効化能力が失われる。P7に定義したdegraded modeでの振る舞いを明示的に設計し、ユーザーへの通知メカニズムを整備することが必要である。

**制約2: インメモリキャッシュの一貫性ウィンドウ**

標準モードにおける無効化は最大でアクセストークンの有効期限（5分）の遅延が生じる。この遅延が許容できないユースケース（例：アカウント侵害の即時対応）では即時無効化モードを使用する必要があるが、即時無効化モードはすべての認証リクエストでRedis照会を必要とするため、レイテンシが増加する。この切り替えをテナント別ポリシーとして設定可能にすることを推奨する。

**制約3: セッション台帳のスケール**

1億ユーザー×平均3デバイスのシナリオでは、3億件のセッションエントリがRedisに存在することになる。各エントリを500バイトとした場合、必要なRedisメモリは約150GBとなる。この規模では、RedisをTiered Storage（ホットデータのみインメモリ、コールドデータはNVMeへ）に置き換えるか、セッション台帳をRedisとRDBMSに分割する設計変更が必要となる。

**今後の課題1: デバイス信頼モデルの統合**

現在の設計はデバイスIDの発行・管理について詳細を扱っていない。MDM（Mobile Device Management）システムとの統合や、デバイス証明書による認証（mutual TLS）を組み合わせることで、デバイス別のアクセス制御をより厳密に実装できる。

**今後の課題2: 異常検知との連携**

セッション台帳は各セッションの地理的位置情報やユーザーエージェントを記録できる。この情報を機械学習ベースの異常検知システムと連携させることで、不審なセッション（異なる地域からの同一セッション利用等）を自動的に無効化するシステムへの発展が可能である。

**今後の課題3: ゼロダウンタイムの鍵ローテーション**

JWTの署名に使用するEC秘密鍵のローテーションは、移行期間中に旧鍵と新鍵の両方を有効とするオーバーラップウィンドウを必要とする。JWTヘッダーのkidフィールドを使用した鍵IDベースの検証切り替えを実装することで、ダウンタイムなしの鍵ローテーションが実現できる。この設計は鍵の侵害（compromise）への対応においても重要となる。

**今後の課題4: グローバルマルチリージョン展開**

複数のAWSリージョンにまたがるデプロイメントでは、Redisのクロスリージョンレプリケーション（Global Datastore等）の設計が必要となる。特に即時無効化モードではリージョン間のレプリケーション遅延（典型的に100ms以上）が無効化の一貫性に影響するため、この要件を明示的にSLAに反映する必要がある。

---

*本文書はCS2（マルチテナントSaaSセッション管理）に対する条件C（PDD Templateアプローチ）による回答である。提案アーキテクチャは実装されていないため、§6に定義した性質の検証は実験的実装による実証が必要である。*
