# CS2 条件B: Paper Format — マルチテナントSaaSセッション管理 (Run 2)

> **Run**: CS2-B-Run2
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c7952-e5b1-74a2-8cf0-6fa4c77edca1)
> **Model**: GPT-5.2 (via Codex)

---

**低遅延かつ即時失効可能なマルチテナントSaaS向け分散セッション管理方式**

**要旨**
本稿は、マルチテナントSaaSにおいて、(R1) 同一ユーザーの複数端末同時ログイン、(R2) 管理者による即時セッション無効化、(R3) 水平スケーリング、(R4) 認証レイテンシ最小化、を同時達成するセッション管理方式を提案する。提案方式は、短寿命アクセストークン（JWT）と集中セッション状態（Redis Cluster）を組み合わせたハイブリッド構成を採用し、失効通知をPub/Subで全APIノードへ伝播する。これにより通常時はローカル検証中心で低遅延を維持しつつ、管理操作時はユーザー単位またはセッション単位の失効をサブ秒で反映できる。さらに、ユーザー失効エポック（`user_epoch`）を導入し、全端末一括失効をO(1)で実現する。理論評価により、キャッシュヒット率99%以上で平均認証遅延をサブミリ秒級に抑えつつ、運用上の「即時失効」（例: 1秒未満）を満たせることを示す。

**キーワード**
マルチテナントSaaS、セッション管理、JWT、失効、水平スケーリング、低遅延

### 1. はじめに
SaaSのマルチテナント化では、認証基盤に対して「分離性」「可用性」「即時制御」「性能」を同時に要求する。特に、毎リクエストで集中認可サーバーへ問い合わせる方式は失効制御に有利だが高遅延化しやすい。一方、完全な自己完結トークン方式は低遅延だが即時失効が難しい。そこで本稿は両者の利点を統合する設計を提示する。

### 2. 問題設定
要件を以下の4点に定義する。
1. R1: ユーザーは複数端末から同時ログイン可能。
2. R2: 管理者は特定ユーザー（または特定端末）のセッションを即時無効化可能。
3. R3: APIサーバー台数の増減時に状態整合性を維持。
4. R4: 認証処理の平均・p99レイテンシを最小化。

### 3. 提案方式
#### 3.1 全体アーキテクチャ
構成要素は `Auth Service`、`API Nodes (stateless)`、`Redis Cluster`、`Event Bus (Pub/Sub)` とする。
アクセストークンは短寿命JWT（例: 120秒）、リフレッシュトークンは端末単位で発行・ローテーションする。
JWTクレームに `tid`（テナントID）, `uid`, `sid`（端末セッションID）, `ue`（user_epoch）を含める。

#### 3.2 データモデル
Redisに以下を保持する。
1. `user_epoch:{tid}:{uid}`: ユーザー全体の失効世代（整数）。
2. `session:{tid}:{sid}`: 端末セッション状態（active/revoked, expires_at）。
3. `refresh:{tid}:{sid}`: ハッシュ化したリフレッシュトークン管理情報。

管理者が全端末失効する場合は `user_epoch` を原子的に `INCR` する。
特定端末のみ失効する場合は該当 `session` を `revoked` に更新する。

#### 3.3 認証アルゴリズム
通常リクエスト時:
1. APIノードでJWT署名・`exp`・`aud`・`tid`をローカル検証。
2. `ue` とローカルキャッシュ中の `user_epoch` を比較。
3. `sid` がローカル失効集合にあれば拒否。
4. キャッシュミス時のみRedis参照。

失効時:
1. 管理操作をRedisへ反映。
2. `revoke_user` または `revoke_session` イベントをPub/Sub配信。
3. 全APIノードがローカルキャッシュを即時更新。

### 4. 要件適合性
| 要件 | 充足メカニズム |
|---|---|
| R1 複数端末同時ログイン | `sid` を端末ごとに発行し、独立セッションとして管理 |
| R2 即時無効化 | `user_epoch` の更新 + Pub/Sub配信、または `sid` 単位失効 |
| R3 水平スケーリング | API層をステートレス化、状態はRedis Clusterへ集約 |
| R4 低遅延認証 | JWTローカル検証を主経路化し、Redis参照はミス時のみ |

### 5. 性能評価（理論）
認証遅延を次式で近似する。
$$E[T] = T_{verify} + p \cdot T_{cache} + (1-p)\cdot (T_{cache}+T_{redis})$$
ここで $p$ はローカルキャッシュヒット率。
例として $T_{verify}=0.15$ms, $T_{cache}=0.02$ms, $T_{redis}=0.8$ms, $p=0.99$ とすると、
$E[T]\approx 0.18$ms となる。
したがって通常時はサブミリ秒級を維持し、失効イベント時のみ局所的に追加コストが発生する。

### 6. 考察
分散系ではネットワーク分断時に「理論上の完全即時性」は保証困難である。実運用では「失効反映1秒未満」などSLOを定義し、分断時の上限リスクを短寿命アクセストークンで抑制する設計が妥当である。加えて、監査ログ、鍵ローテーション、時刻同期（NTP）は必須である。

### 7. 結論
提案方式は、短寿命JWTの低遅延性と集中状態管理の制御性を統合し、4要件を同時に満たす。特に `user_epoch` による全端末失効は、実装単純性と即時性の両立に有効である。今後は実機ベンチマーク（p99, 障害注入試験）による定量検証を進める。

**参考文献**
[1] RFC 7519: JSON Web Token (JWT).
[2] RFC 6749: The OAuth 2.0 Authorization Framework.
[3] RFC 7009: OAuth 2.0 Token Revocation.
