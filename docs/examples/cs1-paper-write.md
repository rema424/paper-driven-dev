# CS1 条件B2: Paper-write — RAG 引用リナンバリング

> **実験条件**: Model: GPT-5.2 (via Codex) | Date: 2026-02 | Prompt language: Japanese
> **プロンプト**: 「以下の技術的な問題について、論文を書いてください。」

---

# ストリーミングRAGにおける引用番号のオンライン正規化 ― `[source_N]` から表示用 `[1..k]` への変換設計

## 要旨
RAG（Retrieval-Augmented Generation）では、LLMが検索結果ID（例: `source_3`, `source_7`）を本文中に埋め込みつつ、ストリーミングでJSON（`{ body, citedSourceIds }`）を返すことがある。ユーザー表示では、実際に出現した引用のみを `[1], [2], ...` の連番にリナンバリングしたいが、ストリーミング中は全文が未確定である。本稿は、**ストリーミングでも番号が後から変わらない（UIが揺れない）**ことを最優先要件として、**「初出順に番号を確定するオンライン・リナンバリング」**を提案し、その成立条件と実装要点、代替案のトレードオフを整理する。

---

## 1. 問題設定
LLMは本文 `body` 内で `[source_7]` のような検索結果IDを参照する。一方、UIでは脚注・参考文献の慣習に合わせ、本文中の参照を `[1]` 等の短い連番にしたい。ここで連番は通常「**本文中の初出順**」で決まるが、ストリーミングでは将来どの `source_*` が現れるかが不明であり、素朴には「最終確定まで番号を決められない」ように見える。

---

## 2. 要件定義（設計上の核心）
本問題は、引用番号付け規則がストリーミング（追記）に対して**安定**かどうかに帰着する。

- **要件R1（安定性）**: いったん表示した引用番号が後から変わらない（UIの差し替え・再描画を最小化）。
- **要件R2（正当性）**: 最終的な全文を左から走査して得られる連番規則と一致する。
- **要件R3（低遅延）**: `[source_N]` が到来した時点で即座に `[i]` を描画する。
- **要件R4（堅牢性）**: チャンク境界でトークンが分断（`"[sou"` + `"rce_7]"`）されても誤変換しない。

重要なのは、**番号付け規則が「接頭辞（prefix）安定」**であることだ。すなわち「これまでに出現した引用の番号が、後続テキストが追加されても変わらない」性質が必要である。

---

## 3. 提案手法：初出順に確定するオンライン・リナンバリング
### 3.1 基本アイデア
本文ストリームを左から読む際、`[source_X]` を初めて観測した瞬間に表示番号を割り当て、その後は同じ `source_X` を常に同番号で表示する。

- 状態:
  - `map: sourceId -> displayNo`（例: `"source_7" -> 1`）
  - `next = 1`
- ルール:
  - `[source_X]` を見つけたら
    - `map` に無ければ `map[source_X] = next; next++`
    - 表示は常に `[map[source_X]]`

この規則は、最終全文に対する「初出順採番」と**同値**である。なぜなら、ストリームは本文を左から順に確定させていく（基本的に追記のみ）ため、`source_X` の「初出」は観測順と一致し、いったん初出を過ぎた後に"より早い初出"が発生することはないからである。

### 3.2 例
ストリーム本文（元ID）:
- `... [source_7] ... [source_3] ... [source_7] ...`

オンライン変換（表示）:
- `... [1] ... [2] ... [1] ...`

脚注（表示番号→元ID）:
- `[1] = source_7`
- `[2] = source_3`

---

## 4. ストリーミング実装の要点
### 4.1 チャンク分断への対処（インクリメンタル検出）
`[source_123]` のようなパターンはチャンク境界で分かれ得るため、単純なチャンク単位の正規表現置換は誤動作する。実装上は以下が要点となる。

- **末尾保留バッファ（tail）**を持つ
  - `tail` に「パターンが未完成かもしれない末尾」を残し、次チャンクと連結して再走査する。
  - 目安として `tail` は最大で `len("[source_") + 数字最大長 + len("]") - 1` 程度を保持すればよい。
- 変換器は「確定部分のみ」逐次出力し、未確定部分は次回へ持ち越す。

この設計で **R4（堅牢性）**を満たしつつ、確定した `[i]` は後から変わらないため **R1（安定性）**も満たす。

### 4.2 `citedSourceIds` との整合
`citedSourceIds` は（LLMが正しく出力するなら）本文に出た引用の集合（あるいは列）を後段で与える補助情報である。ストリーミング描画の主根拠を本文中の検出に置き、

- ストリーミング中: 本文から **map** を構築してUI表示を進める
- 完了時: `citedSourceIds` と `map.keys()` を突合し、差分があればログ・修正（LLM出力の不整合検知）

とすると、遅延なく描画でき、かつ最終品質も担保しやすい。

---

## 5. 代替案とトレードオフ
### 5.1 プレースホルダ方式（後で確定番号に置換）
ストリーミング中は `[source_7]` を仮表示（または `[*]`）し、完了後に全文を走査して `[1..k]` を確定し、本文を差し替える方式。
- 長所: 任意の並べ替え規則（例: 検索順位順、source番号昇順）にも対応可能
- 短所: **完了まで番号が確定しない**／差し替えが発生（R1, R3に不利）

### 5.2 "並べ替え規則"を変えるとストリーミングが破綻しやすい
もし表示番号を「`source_3` を常に先（小さい番号）」のように **元ID順**で決めたい場合、後から `source_1` が出てきた瞬間に既存番号を繰り下げる必要があり、番号が揺れる。
したがって、**リアルタイム性と安定性を優先するなら、初出順（prefix安定）を仕様として採用する**ことが設計上の結論になる。

---

## 6. 結論
ストリーミング中に引用を連番表示するには、「最終全文が未確定だから決められない」という問題を、**番号付け規則のprefix安定性**として捉え直すのが有効である。本文中の `[source_N]` を観測した順に **一度だけ番号を割り当てて固定**するオンライン・リナンバリングは、(1) ストリーミング中に即時描画でき、(2) 完了後の初出順採番と一致し、(3) 表示番号が後から変わらない、という性質を同時に満たす。実装上は、チャンク分断に備えたインクリメンタル検出（末尾保留）と、完了時の `citedSourceIds` 照合による品質担保を組み合わせるのが実務的に最も堅牢である。
