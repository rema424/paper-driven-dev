# Output #030

**推奨設計（結論）**
「引用番号 = "初めてそのソースIDが出現した順に採番"」とする *Citation Registry（採番台帳）* をサーバ側で持ち、ストリーミング中に台帳へ登録→即座に `[n]` に置換して流します。これで **リアルタイム表示**・**番号不変**・**完了時に一覧と整合** を同時に満たせます。

**全体アーキテクチャ**
- 検索結果: `source_3`, `source_7` などの内部ID + メタデータ（title/url/snippet等）
- LLM出力: 引用を必ず機械判読できるマーカーで出す（例: `{{cite:source_3}}` / `{{cite:source_3,source_7}}`）
- ストリーム仲介（サーバ）: マーカー検出→採番→本文は `[1]` 形式で配信、同時に「[1] が何のソースか」もイベントで配信
- UI: 本文はそのまま表示、ソース一覧はイベントで増分更新（完了時に最終確定）

**採番ルール（不変性のコア）**
- `map[source_id] -> number` を保持
- マーカーで `source_id` を見つけたら
  - 既存ならその番号を使う（重複引用は同一番号）
  - 新規なら `next = map.size + 1` を割り当て（以後固定）
- ソース一覧は `number` 昇順で出す（= 初出順）

**ストリーミングの実装ポイント（破綻しやすい所）**
- マーカーがトークン境界で分断されるので、サーバ側で小さなバッファを持ち「マーカーが閉じるまで」本文として流さない（閉じた瞬間に `[n]` を出す）
- `source_id` の検証（検索結果に存在しないIDが来た場合）
  - 推奨: 番号は割り当てて固定しつつ、一覧側で「未解決」として表示/ログ（番号を後で詰めると要件違反）
- 複数引用: `{{cite:a,b}}` → `[1][2]` などに正規化（順序は `a,b` の順 or 事前にソート、どちらでも"一貫"させる）

**配信プロトコル例（SSE/WSいずれでも可）**
- `delta_text`: 置換済み本文断片（例: `"...です[1]"`)
- `citation_add`: 新規採番時のみ（例: `{number:1, source_id:"source_3", title:..., url:...}`）
- `done`: 最終的な `citations:[{1,...},{2,...}]` を送って締め（UIは整合チェック可能）

**代替案と欠点（要件観点）**
- 検索結果に事前採番（retrieval順位をそのまま番号）: 使われないソースが混ざる/番号が飛ぶ問題が出やすい
- 完了後に後処理で採番: リアルタイム表示要件を満たせない
- 後から番号を振り直す（差分更新で本文を書き換える）: 「一度表示した番号が変わらない」に反する
