# CS1 条件B: Paper Format — RAG引用リナンバリング (Run 5)

> **Run**: CS1-B-Run5
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c7958-e1f7-74b0-b971-377897c3f4b0)
> **Model**: GPT-5.2 (via Codex)

---

# ストリーミングRAGにおける不変引用番号付与方式の設計

## 要旨
RAGのストリーミング応答では、生成中に参照ソースが逐次現れるため、可読な連番引用（`[1]`, `[2]`）と最終整合性の両立が難しい。本稿は、`source_3` 等の内部IDを外部表示番号へオンライン割当する「初出時固定方式」を提案する。提案方式は、(i) リアルタイム表示、(ii) 表示済み番号の不変性、(iii) 完了時の引用一覧整合性を同時に満たす。

## 1. 問題設定
生成トークン列中に引用イベント `cite(source_id)` が挿入されるとする。要求は以下である。
1. ストリーミング中に即時表示できること。
2. 一度表示した番号が後で変わらないこと。
3. ストリーム終了時、本文中番号と参考ソース一覧が一致すること。

## 2. 提案手法
### 2.1 設計原則
LLMには表示番号を直接生成させず、構造化タグ（例: `<cite id="source_7"/>`）のみを出力させる。番号付与はオーケストレータ側で行う。

### 2.2 オンライン割当アルゴリズム
```text
state:
  map sid_to_idx = {}
  list idx_to_sid = []
  next = 1

on_cite(sid):
  csid = canonicalize(sid)   # 同一文書のチャンク統合
  if csid not in sid_to_idx:
      sid_to_idx[csid] = next
      idx_to_sid.append(csid)
      next += 1
  emit("[" + sid_to_idx[csid] + "]")

on_finish():
  for i, sid in enumerate(idx_to_sid, start=1):
      render_reference(i, sid)
```

## 3. 正当性
**命題1（不変性）**: `sid_to_idx` は初回挿入のみで更新されるため、表示済み番号は不変。
**命題2（リアルタイム性）**: 各 `on_cite` はハッシュ参照のみで `O(1)`、即時表示可能。
**命題3（最終整合性）**: 本文番号と参考一覧が同一状態 `sid_to_idx / idx_to_sid` から生成されるため必ず一致する。

## 4. 実装上の注意
1. 引用順序決定は「受信順（トークン順）」で固定する。
2. 複数チャンク同一文書は `canonicalize` で1件に統合する。
3. 失敗時（未知ID）は `"[?]"` を出し、監査ログに記録して再実行可能にする。

## 5. 結論
初出時固定方式は、ストリーミングRAGにおける引用番号問題に対して、要件3点を単純な状態管理で満たす。特に「番号生成をLLMから分離」する点が、実運用での安定性と検証容易性を高める。
