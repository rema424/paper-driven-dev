# Output #003

§1. 問題定義

§1.1 背景
RAG（Retrieval-Augmented Generation）では、LLM が検索結果の断片（例: `source_3`, `source_7`）を根拠として回答を生成します。ユーザー体験の観点からは、本文中の参照を `[1] [2] [3]` のような可読な連番にし、末尾に対応するソース一覧を提示する形が望まれます。一方でストリーミング生成は「出力が確定していない途中状態」を逐次公開するため、最終的にどのソースが引用されるか・引用順はどうなるかが事前に確定しません。

§1.2 矛盾する要求（対立するトレードオフ）
(1) 低遅延な逐次表示 vs. 事後確定が必要な整形
- 連番引用は通常「全文を見てから」整形すると簡単ですが、それではリアルタイム表示を満たしません。
(2) 番号の不変性 vs. 生成の可変性（推敲・取り消し）
- ストリーミングでは一度表示したトークンを取り消せません。引用番号を途中で変えないためには、生成側に「引用の撤回や挿入による再番号付け」を事実上許さない設計が必要です。
(3) "使用したものだけ"を列挙したい vs. 先に番号を割り当てたい
- 先に全ソースへ番号を固定すると不変性は満たせますが、未使用ソースが一覧に混入したり、本文の `[n]` が飛び番号になったりします。

§1.3 本文書の範囲
本稿は「(a) ストリーミング中に引用番号を即時表示」「(b) 一度出した番号は不変」「(c) 完了時にソース一覧と整合」を同時に満たすための、生成パイプライン／プロトコル／UI 連携を含む設計を分析します。検索品質・根拠抽出自体の改善（retriever/reranker の精度問題）は主題から外します。

---

§2. 現状のアーキテクチャと制約
典型的な構成は以下です。
- Retriever: クエリ→候補ソース集合 `{source_i}` を取得
- Context Builder: ソース本文や要約を LLM コンテキストへ投入（ID 付き）
- Generator (LLM): ストリーミングで本文トークン列を生成し、適宜「`source_3`」等を参照
- Client: 受信したトークンを逐次描画

制約は「出力の単調性」です。ストリーミングは基本的に append-only であり、(i) 既に表示した引用表記の差し替え、(ii) 既出部分への新しい引用挿入、(iii) 番号の再割当はできません。よって「本文の引用表記」と「末尾の一覧」を整合させるには、整合性が崩れる操作（再番号付け・引用撤回）を設計上禁止または強く抑制する必要があります。

---

§3. 既存アプローチとその限界

§3.1 アプローチ1: 事後整形（Post-hoc Renumbering）
- 手法: 全文生成後、出現順に `source_*` を `[1..]` に置換し、一覧を生成
- 利点: 実装が簡単、最終整合性が高い
- 限界: ストリーミング中のリアルタイム表示を満たさない（完了まで番号が出せない／出しても後で変わる）

§3.2 アプローチ2: 取得順で固定番号（Pre-number by Retrieval Order）
- 手法: Retriever が返した順に `source_1→[1]` のように事前固定
- 利点: ストリーミング中も番号が不変、置換不要
- 限界: 本文で未使用の番号が生じる、引用の出現順と番号順が直感に反する、一覧に未使用ソースが混入しやすい

§3.3 アプローチ3: 2パス生成（Plan then Stream）
- 手法: まず非表示で「使うソース集合と引用計画」を生成→確定後に本文をストリーミング
- 利点: 安定番号と一覧整合性を両立しやすい
- 限界: レイテンシ増、計画と本生成が乖離すると破綻（計画にないソースを途中で引用したくなる）

§3.4 アプローチ4: 初出時割当（First-mention Assignment）
- 手法: ストリーミング中、ある `source_k` が初めて引用された瞬間に次の連番を割当て、以後固定
- 利点: リアルタイム・不変・"使用したものだけ"を自然に満たす
- 限界: 生成が引用を撤回できない前提が必要、引用マーカーの機械可読性（途中分割・誤記）に弱い場合がある

---

§4. 問題の本質
本質は「ストリーム上で、将来の出現を知らずに、後戻り不能な番号付けを行う」点にあります。これは、(i) 状態を持つ変換器（transducer）としての"引用番号割当"を、(ii) 取り消し不能な出力列に対して適用し、(iii) 最終的に本文内参照と一覧を一致させる、という **オンライン一貫性（online consistency）問題**です。
したがって解は、番号付けを「事後の整形」ではなく「ストリーム処理の一部（状態機械）」として定義し、LLM の出力をその前提に合わせて制約する必要があります。

---

§5. 提案手法

§5.1 基本原理
提案は **単調引用割当（Monotonic Citation Allocation; MCA）** です。
- LLM は可読な `[n]` を直接出力しない
- 代わりに、機械可読な引用マーカー（例: `[[CITE:source_7]]`）を本文中に出力する
- ストリーム処理層（Citation Manager）が、初出の `source_id` に対してのみ新番号を割当て、以後は同じ番号を再利用する
- Client には即時に `[n]` を流し、同時に「番号→ソース」対応表を更新する
- 完了時は対応表からソース一覧を生成し、本文と整合させる

これにより、(a) 番号は初出時に確定し (b) 確定後は不変、(c) 一覧は対応表を単一の真実（single source of truth）として生成されるため整合します。

§5.2 実装アーキテクチャ
(1) 入力（Retriever→LLM）
- すべての候補ソースに **安定な内部ID** を付与（例: `source_3`、または URL ハッシュ）
- LLM には「引用は `[[CITE:<id>]]` のみ使用」「引用は主張の直後に置く」等の制約を与える
- 可能なら構造化出力（イベント列）を使い、引用を `{"type":"cite","id":"source_3"}` のようにトークン分割されない形で運ぶ

(2) ストリーム処理（Citation Manager）
- 状態: `map: source_id -> number` と `next_number`
- 逐次変換:
  - `[[CITE:source_k]]` を検出
  - `source_k` が未登録なら `map[source_k]=next_number; next_number++`
  - 出力は常に `[` + map[source_k] + `]`
- これにより「一度表示した番号が後から変わらない」を機械的に保証

(3) 完了処理（References Builder）
- ストリーム終了時、`map` を番号順に並べ替え、ソース一覧を生成
- 一覧は「番号・タイトル・URL・取得日時」等のメタデータを出す（メタデータは Retriever 側で確保）

(4) 例外制御（整合性を壊さないための防波堤）
- 未知IDの引用は原則禁止（LLM に渡した候補集合にない）
- どうしても発生する場合は、ストリームをエラーとして終了し再生成（"番号を後で直す"選択肢は要件上許されないため）

---

§6. 検証可能な性質 — Given/When/Then

性質1（番号不変）
- Given: `source_a` が初めて `[[CITE:source_a]]` として出現し `[k]` が表示された
- When: 後続で再び `[[CITE:source_a]]` が出現する
- Then: 常に同じ `[k]` が表示される

性質2（単調増加・再番号付けなし）
- Given: これまでに `{source_a→1, source_b→2}` が割当済み
- When: 新規の `[[CITE:source_c]]` が出現する
- Then: `source_c` は必ず `[3]` を得て、既存の 1,2 は変化しない

性質3（完了時の一覧整合）
- Given: ストリーム中に表示された引用番号集合が `{1..m}` で、対応表 `map` が保持されている
- When: ストリーム完了時にソース一覧を `map` から生成する
- Then: 一覧は各番号 `[1]..[m]` に対して一意のソースを持ち、本文中の各 `[i]` は必ず一覧中の `[i]` に参照可能である

性質4（"使用したものだけ"の列挙）
- Given: `map` は「実際にストリームで引用マーカーが出現したソース」に対してのみ追加される
- When: ソース一覧を `map` のみから生成する
- Then: 一覧には本文で一度も引用されていないソースが含まれない

---

§7. 制約と今後の課題
- 生成の自由度制約: 「引用を後から差し込む」「さっきの主張を取り消す」などの推敲が、ストリーミング特性上ほぼ不可能です（引用は主張と同時に確定させる必要があります）。
- 引用マーカーの堅牢性: プレーンテキスト中の `[[CITE:...]]` は分割・誤生成のリスクがあるため、構造化イベント（citeイベント）や制約デコーディングの採用が望まれます。
- エラー時の扱い: 未知ID引用や不正形式が出た場合、「後で直す」ことができないため、再生成戦略（どの時点で中断しリトライするか）がUX/コストに直結します。
- UI/プロトコル設計: 本文末尾に一覧を"追加で流す"方式のほか、クライアントがサイドパネルで `map` を逐次更新表示する方式（本文と一覧の分離）も検討価値があります。
- マルチターン整合: 追加質問で同じソースを再利用する場合、番号を会話全体で維持するか（会話スコープ）／回答ごとにリセットするか（応答スコープ）で要件が変わります。会話スコープは「過去の番号との衝突回避」と「ユーザーの理解負荷」のトレードオフがあります。
