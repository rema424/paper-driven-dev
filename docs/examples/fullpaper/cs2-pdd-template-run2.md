# CS2 条件C: PDD Template — マルチテナントSaaSセッション管理 (Run 2)

> **Run**: CS2-C-Run2
> **Date**: 2026-02-20
> **Thread**: 新規 (Codex MCP: 019c795e-998b-7131-bc3d-351266fa0e73)
> **Model**: GPT-5.2 (via Codex)

---

§1. 問題定義
§1.1 背景
マルチテナントSaaSでは、認証基盤に対して「高い運用性」「高い安全性」「低遅延」を同時に要求されます。特にセッション管理は、ユーザー体験（再ログイン頻度）とインシデント対応（強制失効）の双方に直結するため、分散環境での整合性設計が中核課題となります。

§1.2 矛盾する要求（対立するトレードオフ）
1. 低遅延認証（各ノードでローカル検証）と即時失効（集中状態参照）は本質的に対立します。
2. 複数端末同時ログイン（セッション許容）と不正利用時の被害最小化（一括失効・厳格制御）は運用上対立します。
3. 水平スケーリング（ステートレス化）と強整合な失効判定（分散同期）はアーキテクチャ上対立します。

§1.3 本文書の範囲
本稿は、APIリクエスト認証におけるセッション制御を対象とし、ログインUI・MFA詳細・課金連携は扱いません。単一リージョンを前提とし、将来のマルチリージョン拡張可能性を考慮します。

§2. 現状のアーキテクチャと制約
典型構成は `LB -> Stateless API Nodes -> Auth/Session Store` です。制約は以下です。
1. テナント分離: `tenant_id` を全キー空間と監査ログに必須化。
2. 可用性: ノード増減時にスティッキーセッションへ依存しない。
3. 低遅延: 認証判定は業務処理の前段で実行されるため、p99を厳しく抑制。
4. 監査性: 管理者失効操作は追跡可能で再現可能であること。
5. 分散時刻誤差: `iat/exp` 判定のためクロックスキュー耐性が必要。

§3. 既存アプローチとその限界
§3.1 アプローチ1: ノード内メモリセッション — 手法 / 利点 / 限界
手法: 各アプリノードのメモリにセッション保持。
利点: 参照が最速。
限界: ノード障害で消失、水平拡張時の整合が困難、即時一括失効が難しい。

§3.2 アプローチ2: 完全ステートレスJWT — 手法 / 利点 / 限界
手法: 署名検証と `exp` のみで認証。
利点: 高スケーラビリティ、低遅延。
限界: 失効は有効期限待ちになり、管理者の即時無効化要件を満たしにくい。

§3.3 アプローチ3: 毎リクエスト集中イントロスペクション — 手法 / 利点 / 限界
手法: 不透明トークンを集中ストアで毎回照会。
利点: 即時失効と一元管理が容易。
限界: ネットワーク往復増加、集中ストアがボトルネック化。

§4. 問題の本質
本質は「局所的高速判定」と「全体的失効統制」の同時成立です。
受理条件を
`accept = sig_valid ∧ not_expired ∧ session_active ∧ token_iat > revoked_after(user)`
と定義すると、難所は `revoked_after` を分散ノードへ低遅延かつ欠落なく反映する点にあります。

§5. 提案手法
§5.1 基本原理
1. 二層トークン: 短寿命Access Token（例: 2–5分）+ 回転Refresh Token。
2. 中央真実源: Redis Clusterにセッション状態（`session_id, tenant_id, user_id, status, revoked_after`）を保持。
3. 版管理失効: ユーザー単位の `revocation_version` を導入し、失効時に単調増加。
4. プッシュ無効化: 失効イベントをPub/Sub配信し、各ノードのL1キャッシュを即時破棄。
5. フェイルセーフ: キャッシュ不整合時は中央照会へフォールバックし、拒否優先。

§5.2 実装アーキテクチャ
構成要素は `Auth Service`, `Session Authority`, `Redis Cluster`, `Event Bus`, `Stateless API Nodes(L1 cache)`。
処理フローは以下です。
1. ログイン時: 端末ごとに独立 `session_id` を発行し、複数同時ログインを許容。
2. 認証時: 署名をローカル検証後、`session_id` と `revocation_version` をL1で確認。ミス時のみRedis参照。
3. 管理者失効時: 対象ユーザーの全セッションを `revoked` 化し、`revocation_version++`、イベント配信。
4. 水平拡張時: 新規ノードは状態を持たず参加し、同一判定ロジックで即時処理可能。

§6. 検証可能な性質（Given/When/Then）
1. Given 同一ユーザーが未ログイン
When 2端末から同時ログイン
Then 2つの `session_id` が同時に `active` となり、双方の認証が成功する。

2. Given 対象ユーザーが3端末で `active`
When 管理者が「ユーザー失効」を実行
Then 反映SLA（例: 500ms）以内に全端末の次回リクエストが401となる。

3. Given APIノードN台で稼働中
When ノードをN+M台へ増設
Then スティッキー設定なしで認証結果が既存ノードと一致する。

4. Given 定常負荷かつL1ヒット率95%以上
When 認証処理を計測
Then 追加認証レイテンシのp99が目標値（例: 5ms以下）を満たす。

5. Given `tenant_id=A` の管理者が失効操作
When 同一 `user_id` が `tenant_id=B` に存在
Then `tenant_id=B` のセッション状態は変化しない。

§7. 制約と今後の課題
本手法は、イベント伝播遅延に依存するため「厳密な同時即時性」ではなく「SLA付き即時性」です。また、Redis障害時の方針（拒否優先/限定許可）を明示的に選ぶ必要があります。今後は、マルチリージョン整合（グローバル順序付け）、失効嵐時の負荷平準化、形式検証による安全性保証の強化が課題です。
