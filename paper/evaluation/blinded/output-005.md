# Output #005

# 即時失効と低遅延認証を両立するマルチテナントSaaS向けセッション管理方式

## 概要
マルチテナントSaaSでは、(i) 同一ユーザーの複数端末同時ログイン、(ii) 管理者による特定ユーザーの即時セッション無効化、(iii) 水平スケーリング、(iv) リクエスト認証レイテンシ最小化、を同時に満たす必要がある。本稿では、**外部リクエストの認証をゲートウェイで一度だけ行い**、**権威情報として分散インメモリ・セッションストア**を用いる設計を提案する。セッションは端末単位で発行し、管理者失効はセッション集合の原子的削除により即時反映する。バックエンド間はリクエスト単位の内部署名トークンで伝搬し、サービス横断の再検証を不要化して低遅延を実現する。

**キーワード**: マルチテナント, セッション管理, 即時失効, 水平スケール, 低レイテンシ, ゲートウェイ

## 1. はじめに
セッション管理は「認証状態の継続」を提供する一方、失効の即時性やスケール、レイテンシ要求とトレードオフを持つ。特に自己完結型トークン（例: 長寿命JWT）のみで構成すると、サーバ側状態を参照しないため低遅延だが、管理者の即時失効が困難になる。本稿は、**即時失効を"権威ストアでの状態変更"として保証しつつ、検証回数を最小化してレイテンシを抑える**設計を与える。

## 2. 要件と課題
**要件**
- R1: 同一ユーザーの複数端末同時ログイン
- R2: 管理者が特定ユーザーのセッションを即座に無効化
- R3: 水平スケーリング（サーバ増減）
- R4: リクエスト認証レイテンシ最小化

**主要課題**
- C1: 即時失効には「共有される権威状態」または「即時伝播する失効情報」が必要
- C2: 共有状態の参照はネットワーク往復を伴いレイテンシ要因
- C3: マイクロサービス構成ではサービスごとの再認証が増えると遅延・負荷が線形増加

## 3. 提案方式

### 3.1 アーキテクチャ概要
- **Authサービス**: ログイン/更新/ログアウト、管理者失効APIを提供
- **APIゲートウェイ（またはEdge認証ミドルウェア）**: 外部リクエストの認証を一度だけ実施
- **セッションストア（分散インメモリKVS）**: セッション状態の権威情報（例: Redis Cluster 等）
- **バックエンド各サービス**: ゲートウェイが付与した内部署名情報を検証（ローカル計算のみ）

この構成により、外部リクエストあたりの「共有状態参照」を**最大1回**に抑え、サービス数に依存する遅延増を回避する（C3の解消）。

### 3.2 データモデル（マルチテナント分離）
テナント識別子 `tid` は、(a) サブドメイン、(b) リクエストヘッダ、(c) トークン接頭辞、等から導出し、**全キーを `tid` で名前空間化**する。

- セッションレコード: `T:{tid}:S:{sid} -> {uid, device_id, scopes, expires_at, status, ...}`（TTL付与）
- ユーザー→セッション集合: `T:{tid}:U:{uid}:SESS -> {sid1, sid2, ...}`

`sess集合` を持つことで、ユーザー単位の一括失効を高速化する。

### 3.3 トークン設計（外部）
クライアントへは **不透明（opaque）なセッショントークン**（十分長い乱数）を配布する。トークン自体に個人情報や権限を入れず、漏洩時の被害を「そのセッションの乗っ取り」に限定する。必要に応じて、ストア上では `HMAC(token)` をキーにして秘匿性を高める（ストア漏洩対策）。

R1（複数端末）に対し、端末ごとに別 `sid` を発行する。

### 3.4 認証フロー（リクエスト時）
外部リクエストごとに、ゲートウェイで以下を実施する。

1. `tid` を確定（ホスト名等から）
2. クライアント提示トークンから `sid` を得る（または `sid = HMAC(token)`）
3. セッションストアへ1回参照: `GET/HGET T:{tid}:S:{sid}`
4. 存在し、`status=active` かつ `expires_at` 有効なら認証成功
5. ゲートウェイが **内部署名トークン（Internal Assertion）** を生成し、バックエンドへ転送
   - 内容例: `{tid, uid, scopes, req_id, issued_at}` を署名
   - 有効範囲: **当該リクエスト内**（リプレイ困難化のため `req_id` や短寿命を付与）

バックエンド各サービスは内部署名の検証のみ行い、セッションストア参照を不要化する（R4）。

### 3.5 失効フロー（管理者による即時無効化）
管理者が `tid, uid` を指定して失効する。

- 手順（原子的に実行することが望ましい）
  1) `T:{tid}:U:{uid}:SESS` を取得
  2) 各 `sid` に対して `DEL T:{tid}:S:{sid}`
  3) 集合キーも削除（または空にする）

次のリクエストから、ゲートウェイのストア参照で不在となり即時拒否される。内部署名はリクエスト単位で生成されるため、「失効後にバックエンドが古い内部トークンだけで通してしまう」窓は原理的に発生しない（R2を満たす）。

### 3.6 水平スケーリング
- アプリ/ゲートウェイは**ステートレス**（セッション状態はストアへ集約）
- セッションストアは **クラスタ構成（シャーディング＋レプリケーション）** とし、スループットを台数で伸ばす
- 接続プール、タイムアウト、サーキットブレーカにより障害時の波及を抑制

これにより、サーバ増減に対応可能（R3）。

### 3.7 低遅延化の実装要点
- **参照回数の削減**: 認証はゲートウェイで一度だけ（サービスごとに再参照しない）
- **参照コストの削減**: セッション検証は KVS の単純GET（複雑な結合やDB参照を避ける）
- **書き込み抑制**: `last_seen` 更新は間引き（例: N秒に1回）や非同期化
- **局所キャッシュ（任意）**: ゲートウェイ内で短TTLのL1キャッシュを置き、ヒット時はストア参照を省略
  ※ただし即時失効要件が厳密な場合、キャッシュは「TTLを極小」「失効イベントで明示無効化」等の条件で運用する。

## 4. 要件充足性の整理
- R1（複数端末）: `uid` に対し端末別 `sid` を複数保持
- R2（即時無効化）: ユーザーの `sid` 群を権威ストアから削除 → 次リクエストで必ず失敗
- R3（水平スケール）: セッションは共有ストア、アプリはステートレス
- R4（低レイテンシ）: 外部リクエストあたりストア参照は最大1回、以降は内部署名のローカル検証のみ

## 5. 考察
- **自己完結型トークンのみ**（長寿命JWT等）は、即時失効のためにブラックリスト照合やイントロスペクションが必要となり、結局ネットワーク参照が戻る。本提案は「即時失効を権威ストアで保証」しつつ「参照箇所をゲートウェイに集約」してレイテンシを抑える。
- **ユーザーのセッション数上限**（例: N端末まで）を設けると、失効処理の最悪計算量を抑えられる。
- **マルチリージョン**ではストア参照のRTTが支配的になり得るため、リージョン内完結（リージョン別セッション）やグローバルKVSの選択、あるいはゲートウェイのリージョン配置が重要となる。

## 6. 関連技術
OAuth 2.0（RFC 6749）、トークン失効（RFC 7009）、トークンイントロスペクション（RFC 7662）、JWT（RFC 7519）等は、セッション・トークンの設計指針を与える。一方、即時失効と低遅延を同時に満たすには、運用前提（ゲートウェイ集約、権威ストア、イベント/キャッシュ戦略）を含めたアーキテクチャ設計が不可欠である。

## 7. 結論
本稿は、マルチテナントSaaSにおいて「複数端末」「即時失効」「水平スケール」「低遅延」を両立するセッション管理方式として、(1) 分散インメモリKVSを権威ストアとする不透明セッション、(2) 失効はユーザーのセッション集合削除で即時反映、(3) 認証はゲートウェイで一度だけ行い内部署名で伝搬、を提案した。これにより、即時性と性能のトレードオフを、参照回数の最小化によって実務的に解決できる。

参考文献: RFC 6749, RFC 7009, RFC 7662, RFC 7519.
