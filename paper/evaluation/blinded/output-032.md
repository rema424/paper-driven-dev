# Output #032

# マルチテナントSaaSにおける低遅延・即時失効可能な分散セッション管理方式

## 要旨
本稿は、マルチテナントSaaS向けに、(1) 同一ユーザーの複数端末同時ログイン、(2) 管理者による即時セッション無効化、(3) 水平スケーリング、(4) 認証レイテンシ最小化、を同時達成するセッション管理方式を提案します。中核は「短命アクセストークン + 状態管理付きリフレッシュトークン + ユーザー単位エポック（論理時計）」です。認証時は署名検証をローカル実行し、失効判定はL1キャッシュと分散KVSを併用します。無効化はエポック更新をO(1)で実施し、イベント配信で全ノードへ即時反映します。これにより、スケールアウト時にも低遅延かつ運用可能な失効整合性を実現します。

**キーワード**: SaaS, マルチテナント, セッション管理, トークン失効, 低レイテンシ, 分散システム

## 1. 問題設定
従来のステートレスJWTは低遅延ですが、即時失効が難しいという課題があります。一方、完全ステートフルな都度DB照会は失効制御に強い反面、レイテンシとスループットに不利です。したがって本問題は、失効整合性と認証性能の両立が本質です。

## 2. 提案方式
### 2.1 アーキテクチャ
- API/Authノード: 完全ステートレス（水平スケール対象）
- 分散KVS（例: Redis Cluster）: `user_epoch` とセッションメタデータ保持
- 永続DB（例: PostgreSQL）: 監査・長期保存
- イベントバス（例: Redis Streams/Kafka）: 失効イベント配信
- ノード内L1キャッシュ: `user_epoch` の超短TTL保持

### 2.2 トークンと状態
- アクセストークン（短命, 例2-5分）
  主クレーム: `tid, uid, sid, uep(epoch), iat, exp`
- リフレッシュトークン（長命, ローテーション）
- KVSキー
  - `user_epoch:{tid}:{uid} -> int`
  - `session:{sid} -> {tid, uid, status, ...}`
  - `refresh_valid_after:{tid}:{uid} -> timestamp`

### 2.3 認証アルゴリズム
1. JWT署名検証（ローカル）
2. `user_epoch` をL1参照（ミス時のみKVS参照）
3. `token.uep == current_epoch` を検証
4. 必要時のみ `session:{sid}` を追加確認（高リスク操作など）

この構成により、通常経路は「ローカル署名検証 + ローカルメモリ参照」で完結します。

### 2.4 管理者による即時失効
対象ユーザー無効化時に以下を原子的に実行します。
- `INCR user_epoch:{tid}:{uid}`
- `SET refresh_valid_after:{tid}:{uid} = now()`
- 失効イベントを配信

これにより、旧エポックのアクセストークンは次リクエストから拒否され、既存リフレッシュトークンも再発行不能になります。
注: 既に処理中のリクエストは停止できないため、保証対象は「無効化確定以降に到着した新規リクエスト」です。

## 3. 要件適合性
| 要件 | 提案方式での充足 |
|---|---|
| 複数端末同時ログイン | 端末ごとに `sid` を独立発行し併存可能 |
| 管理者による即時無効化 | `user_epoch` 更新で全端末トークンを一括失効 |
| 水平スケーリング | APIノードは無状態、状態は共有ストアへ集約 |
| 低レイテンシ | 署名検証ローカル化 + L1キャッシュ高ヒット設計 |

## 4. 性能モデル
認証遅延の期待値を以下で近似します。
\[
E[L_{auth}] = L_{sig} + h \cdot L_{L1} + (1-h)\cdot L_{KVS}
\]
- \(h\): L1ヒット率
- \(L_{sig}\): 署名検証遅延
- \(L_{KVS}\): 分散KVS往復遅延

実運用で \(h \approx 0.99\) を維持できれば、KVS往復は稀となり、p95遅延を小さく保てます。

## 5. 実装上の要点
- すべてのキーとクレームに `tid` を含め、テナント境界を強制
- 失効イベント遅延監視（遅延増加時は一時的にKVS直参照へフェイルセーフ）
- 鍵管理はKMS連携、鍵ローテーション対応
- 監査ログ（誰が誰をいつ失効したか）を必ず永続化

## 6. 結論
提案方式は、JWTの高速性とステート管理の失効制御を統合し、マルチテナントSaaSで要求される4要件を同時達成します。特に、`user_epoch` を軸にしたO(1)失効は、運用負荷と性能のバランスが良く、大規模環境への適用性が高い設計です。

## 参考文献
1. Jones et al., "JSON Web Token (JWT)," RFC 7519, 2015.
2. Lodderstedt et al., "OAuth 2.0 Security Best Current Practice," IETF Draft/RFC群.
3. Kleppmann, *Designing Data-Intensive Applications*, O'Reilly, 2017.
